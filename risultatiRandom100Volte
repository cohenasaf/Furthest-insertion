
Optimal 15780
_________________
d198
randomInsertion 1.102796507365485

[('d198', 1.102796507365485)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0308591 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.8      0.8      0.0          n = self.numCity
   115         1       1320.8   1320.8      4.3          distances = np.array(self.adj)
   116         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.8      0.8      0.0          in_path = {0}
   118         1         17.0     17.0      0.1          notInPath = [x for x in range(1, n)]
   119         1        214.9    214.9      0.7          random.shuffle(notInPath)
   120                                           
   121       198         58.1      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         50.2      0.3      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         48.1      0.2      0.2              best_increase = np.inf
   127       197         27.4      0.1      0.1              best_position = None
   128     19700       3184.0      0.2     10.3              for i in range(len(path)):
   129     19503       4694.9      0.2     15.2                  next_i = (i + 1) % len(path)
   130     19503      16054.8      0.8     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3814.8      0.2     12.4                  if increase < best_increase:
   132      3732        531.1      0.1      1.7                      best_increase = increase
   133      3732        571.8      0.2      1.9                      best_position = next_i
   134                                           
   135       197         85.7      0.4      0.3              path.insert(best_position, to_insert)
   136       197         73.8      0.4      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.2      2.2      0.0          self.tour = path
   139         1        107.0    107.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1323997013334681

[('d198', 1.1323997013334681)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0312017 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.9      0.9      0.0          n = self.numCity
   115         1       1302.2   1302.2      4.2          distances = np.array(self.adj)
   116         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1         17.0     17.0      0.1          notInPath = [x for x in range(1, n)]
   119         1        309.2    309.2      1.0          random.shuffle(notInPath)
   120                                           
   121       198         59.1      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         51.3      0.3      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         47.0      0.2      0.2              best_increase = np.inf
   127       197         28.0      0.1      0.1              best_position = None
   128     19700       3331.4      0.2     10.7              for i in range(len(path)):
   129     19503       4900.5      0.3     15.7                  next_i = (i + 1) % len(path)
   130     19503      16303.6      0.8     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3977.3      0.2     12.7                  if increase < best_increase:
   132      2000        290.3      0.1      0.9                      best_increase = increase
   133      2000        314.3      0.2      1.0                      best_position = next_i
   134                                           
   135       197         88.5      0.4      0.3              path.insert(best_position, to_insert)
   136       197         66.9      0.3      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.0      2.0      0.0          self.tour = path
   139         1        110.4    110.4      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0593957430943097

[('d198', 1.0593957430943097)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0302131 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.2      1.2      0.0          n = self.numCity
   115         1       1309.9   1309.9      4.3          distances = np.array(self.adj)
   116         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.9      0.9      0.0          in_path = {0}
   118         1         19.5     19.5      0.1          notInPath = [x for x in range(1, n)]
   119         1        245.1    245.1      0.8          random.shuffle(notInPath)
   120                                           
   121       198         57.2      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         49.2      0.2      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         48.6      0.2      0.2              best_increase = np.inf
   127       197         25.7      0.1      0.1              best_position = None
   128     19700       2870.5      0.1      9.5              for i in range(len(path)):
   129     19503       4548.7      0.2     15.1                  next_i = (i + 1) % len(path)
   130     19503      15735.7      0.8     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3731.5      0.2     12.4                  if increase < best_increase:
   132      4546        607.9      0.1      2.0                      best_increase = increase
   133      4546        683.1      0.2      2.3                      best_position = next_i
   134                                           
   135       197         85.4      0.4      0.3              path.insert(best_position, to_insert)
   136       197         70.7      0.4      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.1      2.1      0.0          self.tour = path
   139         1        119.9    119.9      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0887061841224974

[('d198', 1.0887061841224974)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0310626 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.1      1.1      0.0          n = self.numCity
   115         1       1286.4   1286.4      4.1          distances = np.array(self.adj)
   116         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.5      1.5      0.0          in_path = {0}
   118         1         16.0     16.0      0.1          notInPath = [x for x in range(1, n)]
   119         1        199.3    199.3      0.6          random.shuffle(notInPath)
   120                                           
   121       198         58.5      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         48.8      0.2      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         48.9      0.2      0.2              best_increase = np.inf
   127       197         26.4      0.1      0.1              best_position = None
   128     19700       3204.8      0.2     10.3              for i in range(len(path)):
   129     19503       4752.8      0.2     15.3                  next_i = (i + 1) % len(path)
   130     19503      15986.6      0.8     51.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3813.4      0.2     12.3                  if increase < best_increase:
   132      4315        639.5      0.1      2.1                      best_increase = increase
   133      4315        711.0      0.2      2.3                      best_position = next_i
   134                                           
   135       197         84.6      0.4      0.3              path.insert(best_position, to_insert)
   136       197         68.3      0.3      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.1      2.1      0.0          self.tour = path
   139         1        112.1    112.1      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0803912943431448

[('d198', 1.0803912943431448)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0303264 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.9      0.9      0.0          n = self.numCity
   115         1       1271.8   1271.8      4.2          distances = np.array(self.adj)
   116         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.9      0.9      0.0          in_path = {0}
   118         1         19.3     19.3      0.1          notInPath = [x for x in range(1, n)]
   119         1        279.9    279.9      0.9          random.shuffle(notInPath)
   120                                           
   121       198         62.0      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         48.7      0.2      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         49.9      0.3      0.2              best_increase = np.inf
   127       197         28.1      0.1      0.1              best_position = None
   128     19700       3249.8      0.2     10.7              for i in range(len(path)):
   129     19503       4364.5      0.2     14.4                  next_i = (i + 1) % len(path)
   130     19503      16297.6      0.8     53.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3900.7      0.2     12.9                  if increase < best_increase:
   132      1657        223.5      0.1      0.7                      best_increase = increase
   133      1657        251.4      0.2      0.8                      best_position = next_i
   134                                           
   135       197         92.3      0.5      0.3              path.insert(best_position, to_insert)
   136       197         70.9      0.4      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.5      2.5      0.0          self.tour = path
   139         1        111.1    111.1      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0612255140003226

[('d198', 1.0612255140003226)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0318157 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.7      0.7      0.0          n = self.numCity
   115         1       1614.4   1614.4      5.1          distances = np.array(self.adj)
   116         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.9      0.9      0.0          in_path = {0}
   118         1         19.2     19.2      0.1          notInPath = [x for x in range(1, n)]
   119         1        212.0    212.0      0.7          random.shuffle(notInPath)
   120                                           
   121       198         58.9      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         47.9      0.2      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         47.5      0.2      0.1              best_increase = np.inf
   127       197         28.2      0.1      0.1              best_position = None
   128     19700       3142.7      0.2      9.9              for i in range(len(path)):
   129     19503       5011.6      0.3     15.8                  next_i = (i + 1) % len(path)
   130     19503      16277.3      0.8     51.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       4168.7      0.2     13.1                  if increase < best_increase:
   132      2974        423.7      0.1      1.3                      best_increase = increase
   133      2974        471.6      0.2      1.5                      best_position = next_i
   134                                           
   135       197         87.3      0.4      0.3              path.insert(best_position, to_insert)
   136       197         82.1      0.4      0.3              in_path.add(to_insert)
   137                                           
   138         1          2.5      2.5      0.0          self.tour = path
   139         1        117.7    117.7      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0634225594093132

[('d198', 1.0634225594093132)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0309686 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.0      1.0      0.0          n = self.numCity
   115         1       1304.5   1304.5      4.2          distances = np.array(self.adj)
   116         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.0      1.0      0.0          in_path = {0}
   118         1         17.1     17.1      0.1          notInPath = [x for x in range(1, n)]
   119         1        203.7    203.7      0.7          random.shuffle(notInPath)
   120                                           
   121       198         60.6      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         52.0      0.3      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         51.0      0.3      0.2              best_increase = np.inf
   127       197         26.5      0.1      0.1              best_position = None
   128     19700       3115.2      0.2     10.1              for i in range(len(path)):
   129     19503       4693.0      0.2     15.2                  next_i = (i + 1) % len(path)
   130     19503      16063.0      0.8     51.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3881.5      0.2     12.5                  if increase < best_increase:
   132      3876        577.1      0.1      1.9                      best_increase = increase
   133      3876        628.2      0.2      2.0                      best_position = next_i
   134                                           
   135       197         90.8      0.5      0.3              path.insert(best_position, to_insert)
   136       197         84.8      0.4      0.3              in_path.add(to_insert)
   137                                           
   138         1          2.6      2.6      0.0          self.tour = path
   139         1        114.7    114.7      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0844125411130467

[('d198', 1.0844125411130467)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.031087 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.7      0.7      0.0          n = self.numCity
   115         1       1313.2   1313.2      4.2          distances = np.array(self.adj)
   116         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.7      1.7      0.0          in_path = {0}
   118         1         18.8     18.8      0.1          notInPath = [x for x in range(1, n)]
   119         1        211.4    211.4      0.7          random.shuffle(notInPath)
   120                                           
   121       198         58.4      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         52.3      0.3      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         52.8      0.3      0.2              best_increase = np.inf
   127       197         26.5      0.1      0.1              best_position = None
   128     19700       3128.4      0.2     10.1              for i in range(len(path)):
   129     19503       4711.4      0.2     15.2                  next_i = (i + 1) % len(path)
   130     19503      16024.4      0.8     51.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3814.8      0.2     12.3                  if increase < best_increase:
   132      4700        643.4      0.1      2.1                      best_increase = increase
   133      4700        755.6      0.2      2.4                      best_position = next_i
   134                                           
   135       197         86.2      0.4      0.3              path.insert(best_position, to_insert)
   136       197         68.3      0.3      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.1      2.1      0.0          self.tour = path
   139         1        116.1    116.1      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0502183656396322

[('d198', 1.0502183656396322)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.030518 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.7      1.7      0.0          n = self.numCity
   115         1       1306.2   1306.2      4.3          distances = np.array(self.adj)
   116         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.9      0.9      0.0          in_path = {0}
   118         1         29.8     29.8      0.1          notInPath = [x for x in range(1, n)]
   119         1        199.0    199.0      0.7          random.shuffle(notInPath)
   120                                           
   121       198         59.2      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         50.3      0.3      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         47.3      0.2      0.2              best_increase = np.inf
   127       197         26.5      0.1      0.1              best_position = None
   128     19700       3045.8      0.2     10.0              for i in range(len(path)):
   129     19503       4811.1      0.2     15.8                  next_i = (i + 1) % len(path)
   130     19503      15972.5      0.8     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3797.7      0.2     12.4                  if increase < best_increase:
   132      3046        421.8      0.1      1.4                      best_increase = increase
   133      3046        466.3      0.2      1.5                      best_position = next_i
   134                                           
   135       197         99.5      0.5      0.3              path.insert(best_position, to_insert)
   136       197         70.4      0.4      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.9      2.9      0.0          self.tour = path
   139         1        108.6    108.6      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0641506304366017

[('d198', 1.0641506304366017)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.031921 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.9      0.9      0.0          n = self.numCity
   115         1       1290.4   1290.4      4.0          distances = np.array(self.adj)
   116         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.8      1.8      0.0          in_path = {0}
   118         1         19.2     19.2      0.1          notInPath = [x for x in range(1, n)]
   119         1        212.5    212.5      0.7          random.shuffle(notInPath)
   120                                           
   121       198         62.0      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         47.6      0.2      0.1              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         50.1      0.3      0.2              best_increase = np.inf
   127       197         27.7      0.1      0.1              best_position = None
   128     19700       3221.7      0.2     10.1              for i in range(len(path)):
   129     19503       4806.3      0.2     15.1                  next_i = (i + 1) % len(path)
   130     19503      16762.6      0.9     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3836.2      0.2     12.0                  if increase < best_increase:
   132      4184        613.1      0.1      1.9                      best_increase = increase
   133      4184        684.3      0.2      2.1                      best_position = next_i
   134                                           
   135       197         87.6      0.4      0.3              path.insert(best_position, to_insert)
   136       197         76.3      0.4      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.3      2.3      0.0          self.tour = path
   139         1        117.6    117.6      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0699936359808249

[('d198', 1.0699936359808249)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0364235 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.5      1.5      0.0          n = self.numCity
   115         1       2130.4   2130.4      5.8          distances = np.array(self.adj)
   116         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.0      1.0      0.0          in_path = {0}
   118         1         25.3     25.3      0.1          notInPath = [x for x in range(1, n)]
   119         1        278.8    278.8      0.8          random.shuffle(notInPath)
   120                                           
   121       198         71.6      0.4      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         65.0      0.3      0.2              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         75.2      0.4      0.2              best_increase = np.inf
   127       197         32.8      0.2      0.1              best_position = None
   128     19700       3690.5      0.2     10.1              for i in range(len(path)):
   129     19503       5455.4      0.3     15.0                  next_i = (i + 1) % len(path)
   130     19503      18647.5      1.0     51.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       4277.0      0.2     11.7                  if increase < best_increase:
   132      3988        665.2      0.2      1.8                      best_increase = increase
   133      3988        680.5      0.2      1.9                      best_position = next_i
   134                                           
   135       197        124.4      0.6      0.3              path.insert(best_position, to_insert)
   136       197         81.4      0.4      0.2              in_path.add(to_insert)
   137                                           
   138         1          2.4      2.4      0.0          self.tour = path
   139         1        116.8    116.8      0.3          self.calculateCost()

