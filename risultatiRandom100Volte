
Optimal 15780
_________________
d198
randomInsertion 1.0763964853726828

[('d198', 1.0763964853726828)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0302815 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2106.8   2106.8      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         18.4     18.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        200.2    200.2      0.7          random.shuffle(notInPath)
   119                                           
   120       198         51.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.0      0.2      0.1              best_increase = np.inf
   126       197         25.2      0.1      0.1              best_position = None
   127     19700       3131.4      0.2     10.3              for i in range(len(path)):
   128     19503       4639.4      0.2     15.3                  next_i = (i + 1) % len(path)
   129     19503      14712.1      0.8     48.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3736.1      0.2     12.3                  if increase < best_increase:
   131      4719        667.1      0.1      2.2                      best_increase = increase
   132      4719        726.4      0.2      2.4                      best_position = next_i
   133                                           
   134       197         56.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1         84.1     84.1      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.068482779212667

[('d198', 1.068482779212667)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297919 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2098.6   2098.6      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         29.1     29.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        403.7    403.7      1.4          random.shuffle(notInPath)
   119                                           
   120       198         52.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.1      0.2      0.1              best_increase = np.inf
   126       197         26.1      0.1      0.1              best_position = None
   127     19700       2887.1      0.1      9.7              for i in range(len(path)):
   128     19503       4638.6      0.2     15.6                  next_i = (i + 1) % len(path)
   129     19503      14366.3      0.7     48.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3742.3      0.2     12.6                  if increase < best_increase:
   131      4446        610.0      0.1      2.0                      best_increase = increase
   132      4446        680.3      0.2      2.3                      best_position = next_i
   133                                           
   134       197         56.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         47.1      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         74.6     74.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.06996469495124

[('d198', 1.06996469495124)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0448854 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2123.5   2123.5      4.7          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         32.1     32.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        389.5    389.5      0.9          random.shuffle(notInPath)
   119                                           
   120       198         82.9      0.4      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         61.8      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         64.4      0.3      0.1              best_increase = np.inf
   126       197         35.3      0.2      0.1              best_position = None
   127     19700       4481.1      0.2     10.0              for i in range(len(path)):
   128     19503       6792.1      0.3     15.1                  next_i = (i + 1) % len(path)
   129     19503      23461.7      1.2     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       5395.0      0.3     12.0                  if increase < best_increase:
   131      3940        801.4      0.2      1.8                      best_increase = increase
   132      3940        865.4      0.2      1.9                      best_position = next_i
   133                                           
   134       197        108.3      0.5      0.2              path.insert(best_position, to_insert)
   135       197         79.1      0.4      0.2              in_path.add(to_insert)
   136                                           
   137         1          2.5      2.5      0.0          self.tour = path
   138         1        107.3    107.3      0.2          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0438749664708473

[('d198', 1.0438749664708473)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.030322 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2084.0   2084.0      6.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         18.4     18.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        231.4    231.4      0.8          random.shuffle(notInPath)
   119                                           
   120       198         51.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.0      0.2      0.1              best_increase = np.inf
   126       197         26.3      0.1      0.1              best_position = None
   127     19700       3070.6      0.2     10.1              for i in range(len(path)):
   128     19503       4446.8      0.2     14.7                  next_i = (i + 1) % len(path)
   129     19503      15273.5      0.8     50.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3728.8      0.2     12.3                  if increase < best_increase:
   131      3749        523.7      0.1      1.7                      best_increase = increase
   132      3749        590.4      0.2      1.9                      best_position = next_i
   133                                           
   134       197         61.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         84.1     84.1      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1109264687669824

[('d198', 1.1109264687669824)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.028629 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       1735.6   1735.6      6.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         17.6     17.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        204.9    204.9      0.7          random.shuffle(notInPath)
   119                                           
   120       198         50.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         35.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.3      0.2      0.1              best_increase = np.inf
   126       197         25.6      0.1      0.1              best_position = None
   127     19700       3103.2      0.2     10.8              for i in range(len(path)):
   128     19503       4354.3      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      14481.7      0.7     50.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3690.5      0.2     12.9                  if increase < best_increase:
   131      2484        346.6      0.1      1.2                      best_increase = increase
   132      2484        365.7      0.1      1.3                      best_position = next_i
   133                                           
   134       197         53.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.7      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         79.4     79.4      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0878153577335459

[('d198', 1.0878153577335459)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0279216 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       1120.0   1120.0      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         18.2     18.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        248.8    248.8      0.9          random.shuffle(notInPath)
   119                                           
   120       198         52.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.5      0.2      0.1              best_increase = np.inf
   126       197         25.7      0.1      0.1              best_position = None
   127     19700       2796.0      0.1     10.0              for i in range(len(path)):
   128     19503       4404.5      0.2     15.8                  next_i = (i + 1) % len(path)
   129     19503      14492.9      0.7     51.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3792.5      0.2     13.6                  if increase < best_increase:
   131      2414        343.0      0.1      1.2                      best_increase = increase
   132      2414        369.8      0.2      1.3                      best_position = next_i
   133                                           
   134       197         57.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.1      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         74.9     74.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0428754267682838

[('d198', 1.0428754267682838)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0285764 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2054.2   2054.2      7.2          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.6     15.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        215.4    215.4      0.8          random.shuffle(notInPath)
   119                                           
   120       198         50.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.5      0.2      0.1              best_increase = np.inf
   126       197         25.3      0.1      0.1              best_position = None
   127     19700       3011.6      0.2     10.5              for i in range(len(path)):
   128     19503       4327.9      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14381.4      0.7     50.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3598.0      0.2     12.6                  if increase < best_increase:
   131      2250        315.4      0.1      1.1                      best_increase = increase
   132      2250        322.9      0.1      1.1                      best_position = next_i
   133                                           
   134       197         56.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         47.8      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.5     75.5      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.053113531997814

[('d198', 1.053113531997814)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0291789 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2066.1   2066.1      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         32.9     32.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        357.7    357.7      1.2          random.shuffle(notInPath)
   119                                           
   120       198         49.3      0.2      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.6      0.2      0.1              best_increase = np.inf
   126       197         27.1      0.1      0.1              best_position = None
   127     19700       2983.2      0.2     10.2              for i in range(len(path)):
   128     19503       4162.9      0.2     14.3                  next_i = (i + 1) % len(path)
   129     19503      14178.6      0.7     48.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3729.8      0.2     12.8                  if increase < best_increase:
   131      4547        639.0      0.1      2.2                      best_increase = increase
   132      4547        693.2      0.2      2.4                      best_position = next_i
   133                                           
   134       197         55.5      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.4      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1         80.9     80.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1216059068667612

[('d198', 1.1216059068667612)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0303241 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2125.3   2125.3      7.0          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.0     29.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        385.8    385.8      1.3          random.shuffle(notInPath)
   119                                           
   120       198         52.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.1      0.2      0.1              best_increase = np.inf
   126       197         26.2      0.1      0.1              best_position = None
   127     19700       3163.4      0.2     10.4              for i in range(len(path)):
   128     19503       4287.4      0.2     14.1                  next_i = (i + 1) % len(path)
   129     19503      15200.5      0.8     50.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3745.0      0.2     12.3                  if increase < best_increase:
   131      3499        511.2      0.1      1.7                      best_increase = increase
   132      3499        522.2      0.1      1.7                      best_position = next_i
   133                                           
   134       197         69.9      0.4      0.2              path.insert(best_position, to_insert)
   135       197         48.0      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         77.7     77.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0617124813877534

[('d198', 1.0617124813877534)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297434 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2102.6   2102.6      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         28.8     28.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        295.8    295.8      1.0          random.shuffle(notInPath)
   119                                           
   120       198         51.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         50.2      0.3      0.2              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         34.4      0.2      0.1              best_increase = np.inf
   126       197         25.0      0.1      0.1              best_position = None
   127     19700       3180.6      0.2     10.7              for i in range(len(path)):
   128     19503       4306.1      0.2     14.5                  next_i = (i + 1) % len(path)
   129     19503      14476.2      0.7     48.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3767.2      0.2     12.7                  if increase < best_increase:
   131      4225        582.1      0.1      2.0                      best_increase = increase
   132      4225        657.5      0.2      2.2                      best_position = next_i
   133                                           
   134       197         59.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         47.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.8     75.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.058342509455872

[('d198', 1.058342509455872)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0305628 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2085.7   2085.7      6.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         32.7     32.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        386.1    386.1      1.3          random.shuffle(notInPath)
   119                                           
   120       198         52.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.3      0.2      0.1              best_increase = np.inf
   126       197         26.7      0.1      0.1              best_position = None
   127     19700       3170.7      0.2     10.4              for i in range(len(path)):
   128     19503       4560.2      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14924.4      0.8     48.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3823.5      0.2     12.5                  if increase < best_increase:
   131      4245        578.8      0.1      1.9                      best_increase = increase
   132      4245        658.1      0.2      2.2                      best_position = next_i
   133                                           
   134       197         57.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.0      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         74.6     74.6      0.2          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.083093122736471

[('d198', 1.083093122736471)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0295415 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2117.6   2117.6      7.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         29.0     29.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        394.2    394.2      1.3          random.shuffle(notInPath)
   119                                           
   120       198         56.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         43.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.7      0.2      0.1              best_increase = np.inf
   126       197         26.5      0.1      0.1              best_position = None
   127     19700       3130.6      0.2     10.6              for i in range(len(path)):
   128     19503       4370.7      0.2     14.8                  next_i = (i + 1) % len(path)
   129     19503      14534.5      0.7     49.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3797.1      0.2     12.9                  if increase < best_increase:
   131      2763        380.6      0.1      1.3                      best_increase = increase
   132      2763        421.0      0.2      1.4                      best_position = next_i
   133                                           
   134       197         58.5      0.3      0.2              path.insert(best_position, to_insert)
   135       197         52.7      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         87.9     87.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0824764713942283

[('d198', 1.0824764713942283)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297062 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2048.6   2048.6      6.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.7     15.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        199.2    199.2      0.7          random.shuffle(notInPath)
   119                                           
   120       198         52.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.0      0.2      0.1              best_increase = np.inf
   126       197         25.0      0.1      0.1              best_position = None
   127     19700       3032.9      0.2     10.2              for i in range(len(path)):
   128     19503       4638.2      0.2     15.6                  next_i = (i + 1) % len(path)
   129     19503      14501.6      0.7     48.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3676.9      0.2     12.4                  if increase < best_increase:
   131      4226        581.7      0.1      2.0                      best_increase = increase
   132      4226        675.9      0.2      2.3                      best_position = next_i
   133                                           
   134       197         56.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.6      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         78.2     78.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0839899439317773

[('d198', 1.0839899439317773)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0298273 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.3      1.3      0.0          n = self.numCity
   114         1       2094.6   2094.6      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.5     31.5      0.1          notInPath = [x for x in range(1, n)]
   118         1        381.8    381.8      1.3          random.shuffle(notInPath)
   119                                           
   120       198         54.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.3      0.2      0.1              best_increase = np.inf
   126       197         27.4      0.1      0.1              best_position = None
   127     19700       3064.9      0.2     10.3              for i in range(len(path)):
   128     19503       4305.1      0.2     14.4                  next_i = (i + 1) % len(path)
   129     19503      14683.4      0.8     49.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3756.7      0.2     12.6                  if increase < best_increase:
   131      3843        552.8      0.1      1.9                      best_increase = increase
   132      3843        591.5      0.2      2.0                      best_position = next_i
   133                                           
   134       197         60.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         62.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         79.6     79.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.03677777729898

[('d198', 1.03677777729898)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0308459 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.3      1.3      0.0          n = self.numCity
   114         1       1928.1   1928.1      6.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         16.1     16.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        198.7    198.7      0.6          random.shuffle(notInPath)
   119                                           
   120       198         53.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.9      0.2      0.1              best_increase = np.inf
   126       197         28.7      0.1      0.1              best_position = None
   127     19700       3251.4      0.2     10.5              for i in range(len(path)):
   128     19503       4587.0      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      15262.5      0.8     49.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3866.0      0.2     12.5                  if increase < best_increase:
   131      4513        640.5      0.1      2.1                      best_increase = increase
   132      4513        702.5      0.2      2.3                      best_position = next_i
   133                                           
   134       197         65.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.9      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        108.2    108.2      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1049112532021352

[('d198', 1.1049112532021352)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299529 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2094.1   2094.1      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.0     31.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        380.4    380.4      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         45.1      0.2      0.2              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         41.6      0.2      0.1              best_increase = np.inf
   126       197         25.2      0.1      0.1              best_position = None
   127     19700       3243.1      0.2     10.8              for i in range(len(path)):
   128     19503       4516.2      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14799.6      0.8     49.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3460.7      0.2     11.6                  if increase < best_increase:
   131      3828        522.2      0.1      1.7                      best_increase = increase
   132      3828        551.4      0.1      1.8                      best_position = next_i
   133                                           
   134       197         58.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.0      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         75.3     75.3      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0536271961817607

[('d198', 1.0536271961817607)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0292445 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2137.5   2137.5      7.3          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         29.7     29.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        384.3    384.3      1.3          random.shuffle(notInPath)
   119                                           
   120       198         53.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         42.9      0.2      0.1              best_increase = np.inf
   126       197         27.1      0.1      0.1              best_position = None
   127     19700       3111.1      0.2     10.6              for i in range(len(path)):
   128     19503       4351.7      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14385.2      0.7     49.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3645.3      0.2     12.5                  if increase < best_increase:
   131      2750        413.4      0.2      1.4                      best_increase = increase
   132      2750        433.5      0.2      1.5                      best_position = next_i
   133                                           
   134       197         57.6      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.4      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         77.1     77.1      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0553151620969228

[('d198', 1.0553151620969228)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.030459 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2074.3   2074.3      6.8          distances = np.array(self.adj)
   115         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.4     31.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        379.8    379.8      1.2          random.shuffle(notInPath)
   119                                           
   120       198         57.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         44.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.2      0.2      0.1              best_increase = np.inf
   126       197         24.5      0.1      0.1              best_position = None
   127     19700       3100.1      0.2     10.2              for i in range(len(path)):
   128     19503       4531.4      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      15123.4      0.8     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3775.9      0.2     12.4                  if increase < best_increase:
   131      3932        550.6      0.1      1.8                      best_increase = increase
   132      3932        539.1      0.1      1.8                      best_position = next_i
   133                                           
   134       197         59.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.9      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.0     75.0      0.2          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0462089836551889

[('d198', 1.0462089836551889)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0298634 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2076.3   2076.3      7.0          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         30.9     30.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        389.9    389.9      1.3          random.shuffle(notInPath)
   119                                           
   120       198         57.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         54.9      0.3      0.2              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.6      0.2      0.1              best_increase = np.inf
   126       197         27.4      0.1      0.1              best_position = None
   127     19700       3221.7      0.2     10.8              for i in range(len(path)):
   128     19503       4338.9      0.2     14.5                  next_i = (i + 1) % len(path)
   129     19503      14558.2      0.7     48.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3581.4      0.2     12.0                  if increase < best_increase:
   131      4571        621.1      0.1      2.1                      best_increase = increase
   132      4571        677.7      0.1      2.3                      best_position = next_i
   133                                           
   134       197         60.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.5      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         74.8     74.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0836644958530373

[('d198', 1.0836644958530373)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0291914 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2115.3   2115.3      7.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.1      1.1      0.0          in_path = {0}
   117         1         29.4     29.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        389.5    389.5      1.3          random.shuffle(notInPath)
   119                                           
   120       198         53.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.7      0.2      0.1              best_increase = np.inf
   126       197         26.7      0.1      0.1              best_position = None
   127     19700       3045.6      0.2     10.4              for i in range(len(path)):
   128     19503       4234.0      0.2     14.5                  next_i = (i + 1) % len(path)
   129     19503      14276.3      0.7     48.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3642.8      0.2     12.5                  if increase < best_increase:
   131      3889        516.1      0.1      1.8                      best_increase = increase
   132      3889        597.1      0.2      2.0                      best_position = next_i
   133                                           
   134       197         57.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.7      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         76.9     76.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0552052200053672

[('d198', 1.0552052200053672)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0301008 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2099.3   2099.3      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.9     29.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        371.4    371.4      1.2          random.shuffle(notInPath)
   119                                           
   120       198         52.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.1      0.2      0.1              best_increase = np.inf
   126       197         24.6      0.1      0.1              best_position = None
   127     19700       3026.9      0.2     10.1              for i in range(len(path)):
   128     19503       4400.8      0.2     14.6                  next_i = (i + 1) % len(path)
   129     19503      14994.7      0.8     49.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3561.3      0.2     11.8                  if increase < best_increase:
   131      4350        621.4      0.1      2.1                      best_increase = increase
   132      4350        601.0      0.1      2.0                      best_position = next_i
   133                                           
   134       197        106.4      0.5      0.4              path.insert(best_position, to_insert)
   135       197         50.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         77.0     77.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.034573983926304

[('d198', 1.034573983926304)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297721 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2094.1   2094.1      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.8     31.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        350.0    350.0      1.2          random.shuffle(notInPath)
   119                                           
   120       198         64.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.3      0.2      0.1              best_increase = np.inf
   126       197         26.1      0.1      0.1              best_position = None
   127     19700       2882.6      0.1      9.7              for i in range(len(path)):
   128     19503       4622.7      0.2     15.5                  next_i = (i + 1) % len(path)
   129     19503      14612.1      0.7     49.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3711.4      0.2     12.5                  if increase < best_increase:
   131      3695        538.5      0.1      1.8                      best_increase = increase
   132      3695        583.4      0.2      2.0                      best_position = next_i
   133                                           
   134       197         55.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         44.0      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         76.6     76.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0637863922240645

[('d198', 1.0637863922240645)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0287932 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       2095.3   2095.3      7.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.3     31.3      0.1          notInPath = [x for x in range(1, n)]
   118         1        381.4    381.4      1.3          random.shuffle(notInPath)
   119                                           
   120       198         51.8      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         36.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.3      0.2      0.1              best_increase = np.inf
   126       197         24.0      0.1      0.1              best_position = None
   127     19700       2814.7      0.1      9.8              for i in range(len(path)):
   128     19503       4465.9      0.2     15.5                  next_i = (i + 1) % len(path)
   129     19503      14280.9      0.7     49.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3523.0      0.2     12.2                  if increase < best_increase:
   131      3049        406.6      0.1      1.4                      best_increase = increase
   132      3049        463.9      0.2      1.6                      best_position = next_i
   133                                           
   134       197         55.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.1      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         74.7     74.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0568958469598824

[('d198', 1.0568958469598824)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0296117 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2068.1   2068.1      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         30.6     30.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        377.0    377.0      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.7      0.2      0.1              best_increase = np.inf
   126       197         28.1      0.1      0.1              best_position = None
   127     19700       2974.8      0.2     10.0              for i in range(len(path)):
   128     19503       4462.7      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14562.6      0.7     49.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3514.7      0.2     11.9                  if increase < best_increase:
   131      4428        602.6      0.1      2.0                      best_increase = increase
   132      4428        669.1      0.2      2.3                      best_position = next_i
   133                                           
   134       197         58.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.2      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.6     75.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0678858949757644

[('d198', 1.0678858949757644)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0293053 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2106.7   2106.7      7.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.5     31.5      0.1          notInPath = [x for x in range(1, n)]
   118         1        386.7    386.7      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.8      0.2      0.1              best_increase = np.inf
   126       197         24.5      0.1      0.1              best_position = None
   127     19700       3018.1      0.2     10.3              for i in range(len(path)):
   128     19503       4355.0      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14352.3      0.7     49.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3403.3      0.2     11.6                  if increase < best_increase:
   131      4526        656.8      0.1      2.2                      best_increase = increase
   132      4526        649.8      0.1      2.2                      best_position = next_i
   133                                           
   134       197         58.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.3      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         75.4     75.4      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0622300468480808

[('d198', 1.0622300468480808)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0300475 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2072.2   2072.2      6.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.1     31.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        391.6    391.6      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.6      0.2      0.1              best_increase = np.inf
   126       197         27.3      0.1      0.1              best_position = None
   127     19700       3117.2      0.2     10.4              for i in range(len(path)):
   128     19503       4422.5      0.2     14.7                  next_i = (i + 1) % len(path)
   129     19503      14842.8      0.8     49.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3720.5      0.2     12.4                  if increase < best_increase:
   131      3492        501.1      0.1      1.7                      best_increase = increase
   132      3492        558.6      0.2      1.9                      best_position = next_i
   133                                           
   134       197         58.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         72.3      0.4      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         92.6     92.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.075309641742893

[('d198', 1.075309641742893)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299069 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2110.1   2110.1      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         32.9     32.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        399.1    399.1      1.3          random.shuffle(notInPath)
   119                                           
   120       198         54.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.1      0.2      0.1              best_increase = np.inf
   126       197         27.1      0.1      0.1              best_position = None
   127     19700       3098.4      0.2     10.4              for i in range(len(path)):
   128     19503       4621.3      0.2     15.5                  next_i = (i + 1) % len(path)
   129     19503      14412.4      0.7     48.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3535.8      0.2     11.8                  if increase < best_increase:
   131      4524        657.1      0.1      2.2                      best_increase = increase
   132      4524        681.6      0.2      2.3                      best_position = next_i
   133                                           
   134       197         63.6      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.2      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         81.5     81.5      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.068665480219682

[('d198', 1.068665480219682)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297774 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.2      1.2      0.0          n = self.numCity
   114         1       2094.5   2094.5      7.0          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.4     29.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        380.5    380.5      1.3          random.shuffle(notInPath)
   119                                           
   120       198         57.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.4      0.2      0.1              best_increase = np.inf
   126       197         29.3      0.1      0.1              best_position = None
   127     19700       3152.5      0.2     10.6              for i in range(len(path)):
   128     19503       4537.9      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      14367.4      0.7     48.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3962.0      0.2     13.3                  if increase < best_increase:
   131      2938        420.3      0.1      1.4                      best_increase = increase
   132      2938        472.6      0.2      1.6                      best_position = next_i
   133                                           
   134       197         60.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.6      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         78.0     78.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0543208868685905

[('d198', 1.0543208868685905)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299933 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2094.9   2094.9      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         29.0     29.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        284.0    284.0      0.9          random.shuffle(notInPath)
   119                                           
   120       198         54.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.4      0.2      0.1              best_increase = np.inf
   126       197         25.9      0.1      0.1              best_position = None
   127     19700       2978.0      0.2      9.9              for i in range(len(path)):
   128     19503       4485.2      0.2     15.0                  next_i = (i + 1) % len(path)
   129     19503      14635.7      0.8     48.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3813.3      0.2     12.7                  if increase < best_increase:
   131      4407        642.8      0.1      2.1                      best_increase = increase
   132      4407        688.1      0.2      2.3                      best_position = next_i
   133                                           
   134       197         54.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.7      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         76.0     76.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0205818421381305

[('d198', 1.0205818421381305)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0290845 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       1907.1   1907.1      6.6          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         15.7     15.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        205.7    205.7      0.7          random.shuffle(notInPath)
   119                                           
   120       198         54.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         36.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.0      0.2      0.1              best_increase = np.inf
   126       197         26.8      0.1      0.1              best_position = None
   127     19700       3138.4      0.2     10.8              for i in range(len(path)):
   128     19503       4527.7      0.2     15.6                  next_i = (i + 1) % len(path)
   129     19503      14438.8      0.7     49.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3667.2      0.2     12.6                  if increase < best_increase:
   131      2959        385.6      0.1      1.3                      best_increase = increase
   132      2959        456.2      0.2      1.6                      best_position = next_i
   133                                           
   134       197         55.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.6     77.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0490226903417932

[('d198', 1.0490226903417932)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297625 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2090.5   2090.5      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         28.8     28.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        389.3    389.3      1.3          random.shuffle(notInPath)
   119                                           
   120       198         54.5      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         51.9      0.3      0.2              best_increase = np.inf
   126       197         27.6      0.1      0.1              best_position = None
   127     19700       2997.2      0.2     10.1              for i in range(len(path)):
   128     19503       4516.2      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      14614.7      0.7     49.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3665.6      0.2     12.3                  if increase < best_increase:
   131      3654        529.1      0.1      1.8                      best_increase = increase
   132      3654        569.1      0.2      1.9                      best_position = next_i
   133                                           
   134       197         56.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.8     75.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0594927115008765

[('d198', 1.0594927115008765)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0295425 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2125.9   2125.9      7.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.9     31.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        395.7    395.7      1.3          random.shuffle(notInPath)
   119                                           
   120       198         52.8      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.0      0.2      0.1              best_increase = np.inf
   126       197         26.6      0.1      0.1              best_position = None
   127     19700       3076.6      0.2     10.4              for i in range(len(path)):
   128     19503       4397.8      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14674.9      0.8     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3740.4      0.2     12.7                  if increase < best_increase:
   131      2511        341.8      0.1      1.2                      best_increase = increase
   132      2511        409.6      0.2      1.4                      best_position = next_i
   133                                           
   134       197         58.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.0      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         78.5     78.5      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0984711357389008

[('d198', 1.0984711357389008)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0289409 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.5      1.5      0.0          n = self.numCity
   114         1       2047.9   2047.9      7.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         17.5     17.5      0.1          notInPath = [x for x in range(1, n)]
   118         1        202.4    202.4      0.7          random.shuffle(notInPath)
   119                                           
   120       198         53.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         35.7      0.2      0.1              best_increase = np.inf
   126       197         23.1      0.1      0.1              best_position = None
   127     19700       3013.2      0.2     10.4              for i in range(len(path)):
   128     19503       4586.9      0.2     15.8                  next_i = (i + 1) % len(path)
   129     19503      14203.6      0.7     49.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3318.3      0.2     11.5                  if increase < best_increase:
   131      4258        577.0      0.1      2.0                      best_increase = increase
   132      4258        632.7      0.1      2.2                      best_position = next_i
   133                                           
   134       197         55.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.1      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         79.2     79.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.043995351275297

[('d198', 1.043995351275297)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0300607 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2074.7   2074.7      6.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.0     31.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        390.1    390.1      1.3          random.shuffle(notInPath)
   119                                           
   120       198         52.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.8      0.2      0.1              best_increase = np.inf
   126       197         26.6      0.1      0.1              best_position = None
   127     19700       2932.4      0.1      9.8              for i in range(len(path)):
   128     19503       4606.8      0.2     15.3                  next_i = (i + 1) % len(path)
   129     19503      14768.9      0.8     49.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3679.6      0.2     12.2                  if increase < best_increase:
   131      4320        588.0      0.1      2.0                      best_increase = increase
   132      4320        644.3      0.1      2.1                      best_position = next_i
   133                                           
   134       197         58.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.9      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.3     75.3      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0478726019917384

[('d198', 1.0478726019917384)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0290581 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2090.9   2090.9      7.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.7     29.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        382.9    382.9      1.3          random.shuffle(notInPath)
   119                                           
   120       198         54.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         49.9      0.3      0.2              best_increase = np.inf
   126       197         25.7      0.1      0.1              best_position = None
   127     19700       3060.1      0.2     10.5              for i in range(len(path)):
   128     19503       4271.9      0.2     14.7                  next_i = (i + 1) % len(path)
   129     19503      14381.3      0.7     49.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3540.0      0.2     12.2                  if increase < best_increase:
   131      3356        454.1      0.1      1.6                      best_increase = increase
   132      3356        489.6      0.1      1.7                      best_position = next_i
   133                                           
   134       197         61.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.6      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         78.7     78.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.074033087465833

[('d198', 1.074033087465833)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0295906 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       2074.9   2074.9      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         34.2     34.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        387.1    387.1      1.3          random.shuffle(notInPath)
   119                                           
   120       198         56.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.3      0.2      0.1              best_increase = np.inf
   126       197         27.8      0.1      0.1              best_position = None
   127     19700       3081.6      0.2     10.4              for i in range(len(path)):
   128     19503       4503.7      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      14323.3      0.7     48.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3651.3      0.2     12.3                  if increase < best_increase:
   131      4059        540.4      0.1      1.8                      best_increase = increase
   132      4059        641.0      0.2      2.2                      best_position = next_i
   133                                           
   134       197         58.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.3      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         81.7     81.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0751392792644945

[('d198', 1.0751392792644945)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0287087 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       2046.3   2046.3      7.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         18.5     18.5      0.1          notInPath = [x for x in range(1, n)]
   118         1        220.1    220.1      0.8          random.shuffle(notInPath)
   119                                           
   120       198         50.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         34.4      0.2      0.1              best_increase = np.inf
   126       197         22.5      0.1      0.1              best_position = None
   127     19700       2912.8      0.1     10.1              for i in range(len(path)):
   128     19503       4315.5      0.2     15.0                  next_i = (i + 1) % len(path)
   129     19503      14288.3      0.7     49.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3494.3      0.2     12.2                  if increase < best_increase:
   131      3984        523.5      0.1      1.8                      best_increase = increase
   132      3984        555.8      0.1      1.9                      best_position = next_i
   133                                           
   134       197         59.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         47.1      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         77.0     77.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0819508289839643

[('d198', 1.0819508289839643)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0293882 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2096.1   2096.1      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.3     31.3      0.1          notInPath = [x for x in range(1, n)]
   118         1        384.4    384.4      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.5      0.2      0.1              best_increase = np.inf
   126       197         27.2      0.1      0.1              best_position = None
   127     19700       2819.2      0.1      9.6              for i in range(len(path)):
   128     19503       4385.1      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14727.6      0.8     50.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3656.0      0.2     12.4                  if increase < best_increase:
   131      3227        450.2      0.1      1.5                      best_increase = increase
   132      3227        483.1      0.1      1.6                      best_position = next_i
   133                                           
   134       197         60.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.6      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         80.6     80.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.088099656636176

[('d198', 1.088099656636176)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0286405 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       1137.3   1137.3      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         17.1     17.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        198.7    198.7      0.7          random.shuffle(notInPath)
   119                                           
   120       198         50.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.6      0.2      0.1              best_increase = np.inf
   126       197         25.5      0.1      0.1              best_position = None
   127     19700       2986.4      0.2     10.4              for i in range(len(path)):
   128     19503       4181.6      0.2     14.6                  next_i = (i + 1) % len(path)
   129     19503      15258.9      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3757.9      0.2     13.1                  if increase < best_increase:
   131      2662        358.1      0.1      1.3                      best_increase = increase
   132      2662        405.9      0.2      1.4                      best_position = next_i
   133                                           
   134       197         57.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.3      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         78.6     78.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.146812678799505

[('d198', 1.146812678799505)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0295797 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2066.7   2066.7      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.6     31.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        385.4    385.4      1.3          random.shuffle(notInPath)
   119                                           
   120       198         56.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.2      0.2      0.1              best_increase = np.inf
   126       197         25.4      0.1      0.1              best_position = None
   127     19700       3018.7      0.2     10.2              for i in range(len(path)):
   128     19503       4419.3      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14432.5      0.7     48.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3713.7      0.2     12.6                  if increase < best_increase:
   131      4078        561.2      0.1      1.9                      best_increase = increase
   132      4078        598.9      0.1      2.0                      best_position = next_i
   133                                           
   134       197         62.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.6      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         74.0     74.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0954086659944893

[('d198', 1.0954086659944893)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0306653 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       1121.6   1121.6      3.7          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         18.9     18.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        303.1    303.1      1.0          random.shuffle(notInPath)
   119                                           
   120       198         53.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.1      0.2      0.1              best_increase = np.inf
   126       197         27.0      0.1      0.1              best_position = None
   127     19700       3301.4      0.2     10.8              for i in range(len(path)):
   128     19503       4944.5      0.3     16.1                  next_i = (i + 1) % len(path)
   129     19503      15411.8      0.8     50.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       4268.9      0.2     13.9                  if increase < best_increase:
   131      2831        401.5      0.1      1.3                      best_increase = increase
   132      2831        508.7      0.2      1.7                      best_position = next_i
   133                                           
   134       197         64.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.7      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.4      1.4      0.0          self.tour = path
   138         1        106.2    106.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0410741712633953

[('d198', 1.0410741712633953)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299566 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2090.2   2090.2      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.4     31.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        334.2    334.2      1.1          random.shuffle(notInPath)
   119                                           
   120       198         49.3      0.2      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.3      0.2      0.1              best_increase = np.inf
   126       197         22.9      0.1      0.1              best_position = None
   127     19700       3066.6      0.2     10.2              for i in range(len(path)):
   128     19503       4507.0      0.2     15.0                  next_i = (i + 1) % len(path)
   129     19503      14854.3      0.8     49.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3471.4      0.2     11.6                  if increase < best_increase:
   131      4483        635.6      0.1      2.1                      best_increase = increase
   132      4483        630.1      0.1      2.1                      best_position = next_i
   133                                           
   134       197         57.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.3      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         80.4     80.4      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.069564534106177

[('d198', 1.069564534106177)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0293202 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       1946.2   1946.2      6.6          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.0     15.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        196.0    196.0      0.7          random.shuffle(notInPath)
   119                                           
   120       198         51.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.0      0.2      0.1              best_increase = np.inf
   126       197         25.0      0.1      0.1              best_position = None
   127     19700       3009.2      0.2     10.3              for i in range(len(path)):
   128     19503       4279.2      0.2     14.6                  next_i = (i + 1) % len(path)
   129     19503      14603.7      0.7     49.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3748.1      0.2     12.8                  if increase < best_increase:
   131      4194        560.5      0.1      1.9                      best_increase = increase
   132      4194        625.2      0.1      2.1                      best_position = next_i
   133                                           
   134       197         57.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.3      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         78.2     78.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0795264785287924

[('d198', 1.0795264785287924)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0302016 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.4      1.4      0.0          n = self.numCity
   114         1       2094.5   2094.5      6.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.1     29.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        384.4    384.4      1.3          random.shuffle(notInPath)
   119                                           
   120       198         54.5      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         43.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.6      0.2      0.1              best_increase = np.inf
   126       197         27.5      0.1      0.1              best_position = None
   127     19700       3086.5      0.2     10.2              for i in range(len(path)):
   128     19503       4555.4      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      15229.8      0.8     50.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3844.5      0.2     12.7                  if increase < best_increase:
   131      2015        301.4      0.1      1.0                      best_increase = increase
   132      2015        312.6      0.2      1.0                      best_position = next_i
   133                                           
   134       197         62.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         53.9      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         79.1     79.1      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.070814797028822

[('d198', 1.070814797028822)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0291852 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       1910.2   1910.2      6.5          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         16.2     16.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        207.5    207.5      0.7          random.shuffle(notInPath)
   119                                           
   120       198         51.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.1      0.2      0.1              best_increase = np.inf
   126       197         26.1      0.1      0.1              best_position = None
   127     19700       2854.0      0.1      9.8              for i in range(len(path)):
   128     19503       4496.2      0.2     15.4                  next_i = (i + 1) % len(path)
   129     19503      14511.1      0.7     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3611.8      0.2     12.4                  if increase < best_increase:
   131      4226        587.2      0.1      2.0                      best_increase = increase
   132      4226        653.2      0.2      2.2                      best_position = next_i
   133                                           
   134       197         59.5      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.0      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         73.8     73.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.061456184220118

[('d198', 1.061456184220118)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0319256 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2090.7   2090.7      6.5          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.1     29.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        396.6    396.6      1.2          random.shuffle(notInPath)
   119                                           
   120       198         56.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         43.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         47.9      0.2      0.1              best_increase = np.inf
   126       197         27.7      0.1      0.1              best_position = None
   127     19700       3382.5      0.2     10.6              for i in range(len(path)):
   128     19503       4569.3      0.2     14.3                  next_i = (i + 1) % len(path)
   129     19503      15874.8      0.8     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3824.9      0.2     12.0                  if increase < best_increase:
   131      4441        662.9      0.1      2.1                      best_increase = increase
   132      4441        681.3      0.2      2.1                      best_position = next_i
   133                                           
   134       197         71.2      0.4      0.2              path.insert(best_position, to_insert)
   135       197         56.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          2.4      2.4      0.0          self.tour = path
   138         1        106.2    106.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0545041319990944

[('d198', 1.0545041319990944)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0305702 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2138.2   2138.2      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         31.6     31.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        319.8    319.8      1.0          random.shuffle(notInPath)
   119                                           
   120       198         56.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.5      0.2      0.1              best_increase = np.inf
   126       197         25.0      0.1      0.1              best_position = None
   127     19700       3133.3      0.2     10.2              for i in range(len(path)):
   128     19503       4458.6      0.2     14.6                  next_i = (i + 1) % len(path)
   129     19503      15178.7      0.8     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3719.2      0.2     12.2                  if increase < best_increase:
   131      4174        578.7      0.1      1.9                      best_increase = increase
   132      4174        627.9      0.2      2.1                      best_position = next_i
   133                                           
   134       197         60.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.6      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        107.4    107.4      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0510008174708119

[('d198', 1.0510008174708119)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0296599 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2075.6   2075.6      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.0     31.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        405.9    405.9      1.4          random.shuffle(notInPath)
   119                                           
   120       198         54.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.2      0.2      0.1              best_increase = np.inf
   126       197         25.2      0.1      0.1              best_position = None
   127     19700       3203.1      0.2     10.8              for i in range(len(path)):
   128     19503       4297.5      0.2     14.5                  next_i = (i + 1) % len(path)
   129     19503      14667.0      0.8     49.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3408.1      0.2     11.5                  if increase < best_increase:
   131      4611        606.3      0.1      2.0                      best_increase = increase
   132      4611        621.6      0.1      2.1                      best_position = next_i
   133                                           
   134       197         59.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         47.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.3     75.3      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0727807885448088

[('d198', 1.0727807885448088)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0292561 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2076.4   2076.4      7.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.2     31.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        385.0    385.0      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.1      0.2      0.1              best_increase = np.inf
   126       197         26.8      0.1      0.1              best_position = None
   127     19700       2828.2      0.1      9.7              for i in range(len(path)):
   128     19503       4588.6      0.2     15.7                  next_i = (i + 1) % len(path)
   129     19503      14328.4      0.7     49.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3783.3      0.2     12.9                  if increase < best_increase:
   131      3049        416.2      0.1      1.4                      best_increase = increase
   132      3049        467.4      0.2      1.6                      best_position = next_i
   133                                           
   134       197         59.6      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.2      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.8     75.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.05208576217798

[('d198', 1.05208576217798)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299848 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2094.6   2094.6      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.0     31.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        392.8    392.8      1.3          random.shuffle(notInPath)
   119                                           
   120       198         54.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.3      0.2      0.1              best_increase = np.inf
   126       197         26.1      0.1      0.1              best_position = None
   127     19700       2968.4      0.2      9.9              for i in range(len(path)):
   128     19503       4443.5      0.2     14.8                  next_i = (i + 1) % len(path)
   129     19503      15186.8      0.8     50.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3924.2      0.2     13.1                  if increase < best_increase:
   131      1958        296.1      0.2      1.0                      best_increase = increase
   132      1958        298.8      0.2      1.0                      best_position = next_i
   133                                           
   134       197         58.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.2      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1         75.2     75.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.082551894876127

[('d198', 1.082551894876127)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299617 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.5      1.5      0.0          n = self.numCity
   114         1       2095.1   2095.1      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.8     31.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        384.0    384.0      1.3          random.shuffle(notInPath)
   119                                           
   120       198         57.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.3      0.2      0.1              best_increase = np.inf
   126       197         28.2      0.1      0.1              best_position = None
   127     19700       3170.1      0.2     10.6              for i in range(len(path)):
   128     19503       4534.0      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14506.1      0.7     48.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3881.2      0.2     13.0                  if increase < best_increase:
   131      3289        480.0      0.1      1.6                      best_increase = increase
   132      3289        519.2      0.2      1.7                      best_position = next_i
   133                                           
   134       197         60.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.3      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         78.7     78.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0918435692174124

[('d198', 1.0918435692174124)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.029837 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2094.9   2094.9      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         28.7     28.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        466.7    466.7      1.6          random.shuffle(notInPath)
   119                                           
   120       198         55.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.5      0.2      0.1              best_increase = np.inf
   126       197         27.0      0.1      0.1              best_position = None
   127     19700       2870.0      0.1      9.6              for i in range(len(path)):
   128     19503       4578.6      0.2     15.3                  next_i = (i + 1) % len(path)
   129     19503      14721.7      0.8     49.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3716.8      0.2     12.5                  if increase < best_increase:
   131      3188        469.8      0.1      1.6                      best_increase = increase
   132      3188        486.1      0.2      1.6                      best_position = next_i
   133                                           
   134       197         78.5      0.4      0.3              path.insert(best_position, to_insert)
   135       197         50.3      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        108.2    108.2      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0477845966410007

[('d198', 1.0477845966410007)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299672 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2099.0   2099.0      7.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         29.2     29.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        329.4    329.4      1.1          random.shuffle(notInPath)
   119                                           
   120       198         53.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.7      0.2      0.1              best_increase = np.inf
   126       197         26.4      0.1      0.1              best_position = None
   127     19700       3005.7      0.2     10.0              for i in range(len(path)):
   128     19503       4286.5      0.2     14.3                  next_i = (i + 1) % len(path)
   129     19503      14702.4      0.8     49.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3868.0      0.2     12.9                  if increase < best_increase:
   131      4267        653.6      0.2      2.2                      best_increase = increase
   132      4267        653.7      0.2      2.2                      best_position = next_i
   133                                           
   134       197         56.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.0      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1         80.0     80.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.092535094111598

[('d198', 1.092535094111598)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0292431 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2081.2   2081.2      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         18.6     18.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        230.0    230.0      0.8          random.shuffle(notInPath)
   119                                           
   120       198         54.8      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.2      0.2      0.1              best_increase = np.inf
   126       197         24.9      0.1      0.1              best_position = None
   127     19700       2819.6      0.1      9.6              for i in range(len(path)):
   128     19503       4419.9      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14431.2      0.7     49.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3727.1      0.2     12.7                  if increase < best_increase:
   131      4042        540.9      0.1      1.8                      best_increase = increase
   132      4042        608.1      0.2      2.1                      best_position = next_i
   133                                           
   134       197         84.9      0.4      0.3              path.insert(best_position, to_insert)
   135       197         45.6      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.5     77.5      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0557715511943728

[('d198', 1.0557715511943728)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0290718 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       1156.7   1156.7      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         17.7     17.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        313.0    313.0      1.1          random.shuffle(notInPath)
   119                                           
   120       198         53.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.2      0.2      0.1              best_increase = np.inf
   126       197         25.0      0.1      0.1              best_position = None
   127     19700       2906.2      0.1     10.0              for i in range(len(path)):
   128     19503       4562.8      0.2     15.7                  next_i = (i + 1) % len(path)
   129     19503      14321.0      0.7     49.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       4237.2      0.2     14.6                  if increase < best_increase:
   131      4129        602.2      0.1      2.1                      best_increase = increase
   132      4129        608.8      0.1      2.1                      best_position = next_i
   133                                           
   134       197         61.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         74.6     74.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0501461119097124

[('d198', 1.0501461119097124)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0293033 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2097.4   2097.4      7.2          distances = np.array(self.adj)
   115         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.0     29.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        412.5    412.5      1.4          random.shuffle(notInPath)
   119                                           
   120       198         57.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         45.3      0.2      0.2              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.7      0.2      0.1              best_increase = np.inf
   126       197         26.9      0.1      0.1              best_position = None
   127     19700       3006.5      0.2     10.3              for i in range(len(path)):
   128     19503       4273.3      0.2     14.6                  next_i = (i + 1) % len(path)
   129     19503      14846.3      0.8     50.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3651.7      0.2     12.5                  if increase < best_increase:
   131      2061        291.8      0.1      1.0                      best_increase = increase
   132      2061        332.2      0.2      1.1                      best_position = next_i
   133                                           
   134       197         59.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.9      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         78.8     78.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0511926356084242

[('d198', 1.0511926356084242)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0293849 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2000.0   2000.0      6.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.7     15.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        205.4    205.4      0.7          random.shuffle(notInPath)
   119                                           
   120       198         54.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         41.4      0.2      0.1              best_increase = np.inf
   126       197         25.4      0.1      0.1              best_position = None
   127     19700       3322.3      0.2     11.3              for i in range(len(path)):
   128     19503       4497.2      0.2     15.3                  next_i = (i + 1) % len(path)
   129     19503      14673.7      0.8     49.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3596.5      0.2     12.2                  if increase < best_increase:
   131      2573        354.2      0.1      1.2                      best_increase = increase
   132      2573        370.2      0.1      1.3                      best_position = next_i
   133                                           
   134       197         58.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.8      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1         80.6     80.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1359503609955635

[('d198', 1.1359503609955635)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297433 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2078.5   2078.5      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         28.7     28.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        418.5    418.5      1.4          random.shuffle(notInPath)
   119                                           
   120       198         54.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.8      0.2      0.1              best_increase = np.inf
   126       197         26.4      0.1      0.1              best_position = None
   127     19700       3037.7      0.2     10.2              for i in range(len(path)):
   128     19503       4430.0      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14772.4      0.8     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3606.9      0.2     12.1                  if increase < best_increase:
   131      3562        481.4      0.1      1.6                      best_increase = increase
   132      3562        534.3      0.2      1.8                      best_position = next_i
   133                                           
   134       197         60.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         52.1      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         77.9     77.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0699120183109976

[('d198', 1.0699120183109976)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.02902 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       1943.9   1943.9      6.7          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.1     15.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        191.0    191.0      0.7          random.shuffle(notInPath)
   119                                           
   120       198         53.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.1      0.2      0.1              best_increase = np.inf
   126       197         23.8      0.1      0.1              best_position = None
   127     19700       3204.4      0.2     11.0              for i in range(len(path)):
   128     19503       4516.8      0.2     15.6                  next_i = (i + 1) % len(path)
   129     19503      14545.1      0.7     50.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3495.5      0.2     12.0                  if increase < best_increase:
   131      2863        380.9      0.1      1.3                      best_increase = increase
   132      2863        391.5      0.1      1.3                      best_position = next_i
   133                                           
   134       197         59.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.7      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         76.4     76.4      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0640209238987994

[('d198', 1.0640209238987994)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0295095 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       2138.9   2138.9      7.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         29.1     29.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        401.2    401.2      1.4          random.shuffle(notInPath)
   119                                           
   120       198         53.4      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.0      0.2      0.1              best_increase = np.inf
   126       197         24.2      0.1      0.1              best_position = None
   127     19700       2986.4      0.2     10.1              for i in range(len(path)):
   128     19503       4458.0      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14467.2      0.7     49.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3418.7      0.2     11.6                  if increase < best_increase:
   131      4588        606.6      0.1      2.1                      best_increase = increase
   132      4588        657.7      0.1      2.2                      best_position = next_i
   133                                           
   134       197         58.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.5      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         78.9     78.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0753089461085643

[('d198', 1.0753089461085643)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0293122 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       1954.3   1954.3      6.7          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.9     15.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        206.5    206.5      0.7          random.shuffle(notInPath)
   119                                           
   120       198         52.8      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         34.2      0.2      0.1              best_increase = np.inf
   126       197         25.0      0.1      0.1              best_position = None
   127     19700       3074.0      0.2     10.5              for i in range(len(path)):
   128     19503       4451.5      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      14374.1      0.7     49.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3692.5      0.2     12.6                  if increase < best_increase:
   131      4250        576.3      0.1      2.0                      best_increase = increase
   132      4250        634.2      0.1      2.2                      best_position = next_i
   133                                           
   134       197         58.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.9      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         76.9     76.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1046738828165508

[('d198', 1.1046738828165508)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0291564 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2115.7   2115.7      7.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.0      1.0      0.0          in_path = {0}
   117         1         31.1     31.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        377.3    377.3      1.3          random.shuffle(notInPath)
   119                                           
   120       198         49.5      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.7      0.2      0.1              best_increase = np.inf
   126       197         25.2      0.1      0.1              best_position = None
   127     19700       3054.1      0.2     10.5              for i in range(len(path)):
   128     19503       4446.9      0.2     15.3                  next_i = (i + 1) % len(path)
   129     19503      14679.3      0.8     50.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3602.3      0.2     12.4                  if increase < best_increase:
   131      1757        238.7      0.1      0.8                      best_increase = increase
   132      1757        275.1      0.2      0.9                      best_position = next_i
   133                                           
   134       197         57.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.9     77.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0746240983309912

[('d198', 1.0746240983309912)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0300124 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2084.3   2084.3      6.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         29.1     29.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        371.8    371.8      1.2          random.shuffle(notInPath)
   119                                           
   120       198         54.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.5      0.2      0.1              best_increase = np.inf
   126       197         26.6      0.1      0.1              best_position = None
   127     19700       2980.0      0.2      9.9              for i in range(len(path)):
   128     19503       4254.8      0.2     14.2                  next_i = (i + 1) % len(path)
   129     19503      15244.7      0.8     50.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3700.6      0.2     12.3                  if increase < best_increase:
   131      3335        478.7      0.1      1.6                      best_increase = increase
   132      3335        514.0      0.2      1.7                      best_position = next_i
   133                                           
   134       197         60.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         60.0      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         75.5     75.5      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.068714362853354

[('d198', 1.068714362853354)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.029873 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2074.8   2074.8      6.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         28.8     28.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        391.5    391.5      1.3          random.shuffle(notInPath)
   119                                           
   120       198         56.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.9      0.2      0.1              best_increase = np.inf
   126       197         27.5      0.1      0.1              best_position = None
   127     19700       3078.4      0.2     10.3              for i in range(len(path)):
   128     19503       4448.8      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      15120.9      0.8     50.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3818.8      0.2     12.8                  if increase < best_increase:
   131      1759        269.0      0.2      0.9                      best_increase = increase
   132      1759        290.0      0.2      1.0                      best_position = next_i
   133                                           
   134       197         59.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.9     77.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.067765450984017

[('d198', 1.067765450984017)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0290641 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2093.6   2093.6      7.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.6     31.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        245.5    245.5      0.8          random.shuffle(notInPath)
   119                                           
   120       198         51.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         50.4      0.3      0.2              best_increase = np.inf
   126       197         25.2      0.1      0.1              best_position = None
   127     19700       2944.8      0.1     10.1              for i in range(len(path)):
   128     19503       4194.3      0.2     14.4                  next_i = (i + 1) % len(path)
   129     19503      14934.0      0.8     51.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3628.0      0.2     12.5                  if increase < best_increase:
   131      2203        308.2      0.1      1.1                      best_increase = increase
   132      2203        339.2      0.2      1.2                      best_position = next_i
   133                                           
   134       197         54.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         78.1     78.1      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0513029829228262

[('d198', 1.0513029829228262)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0291873 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2113.5   2113.5      7.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.0     29.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        381.5    381.5      1.3          random.shuffle(notInPath)
   119                                           
   120       198         52.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.9      0.2      0.1              best_increase = np.inf
   126       197         26.2      0.1      0.1              best_position = None
   127     19700       3019.0      0.2     10.3              for i in range(len(path)):
   128     19503       4179.1      0.2     14.3                  next_i = (i + 1) % len(path)
   129     19503      14297.5      0.7     49.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3617.4      0.2     12.4                  if increase < best_increase:
   131      4261        561.7      0.1      1.9                      best_increase = increase
   132      4261        630.1      0.1      2.2                      best_position = next_i
   133                                           
   134       197         76.4      0.4      0.3              path.insert(best_position, to_insert)
   135       197         46.8      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         75.9     75.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0877957379271361

[('d198', 1.0877957379271361)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0293552 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2084.3   2084.3      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.2     29.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        242.7    242.7      0.8          random.shuffle(notInPath)
   119                                           
   120       198         54.5      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.6      0.2      0.1              best_increase = np.inf
   126       197         28.5      0.1      0.1              best_position = None
   127     19700       3239.6      0.2     11.0              for i in range(len(path)):
   128     19503       4552.3      0.2     15.5                  next_i = (i + 1) % len(path)
   129     19503      14466.0      0.7     49.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3809.8      0.2     13.0                  if increase < best_increase:
   131      1814        276.2      0.2      0.9                      best_increase = increase
   132      1814        299.5      0.2      1.0                      best_position = next_i
   133                                           
   134       197         57.5      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.5      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         81.2     81.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.055129396159931

[('d198', 1.055129396159931)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0301973 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2072.8   2072.8      6.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.1     31.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        417.2    417.2      1.4          random.shuffle(notInPath)
   119                                           
   120       198         57.8      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.2      0.2      0.1              best_increase = np.inf
   126       197         27.7      0.1      0.1              best_position = None
   127     19700       3131.6      0.2     10.4              for i in range(len(path)):
   128     19503       4767.1      0.2     15.8                  next_i = (i + 1) % len(path)
   129     19503      15030.2      0.8     49.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3782.1      0.2     12.5                  if increase < best_increase:
   131      2040        299.8      0.1      1.0                      best_increase = increase
   132      2040        313.0      0.2      1.0                      best_position = next_i
   133                                           
   134       197         59.5      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.3      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         73.5     73.5      0.2          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.106294867900466

[('d198', 1.106294867900466)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297567 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2110.1   2110.1      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         29.2     29.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        390.0    390.0      1.3          random.shuffle(notInPath)
   119                                           
   120       198         56.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.3      0.2      0.1              best_increase = np.inf
   126       197         26.1      0.1      0.1              best_position = None
   127     19700       2843.6      0.1      9.6              for i in range(len(path)):
   128     19503       4487.1      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14773.0      0.8     49.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3694.7      0.2     12.4                  if increase < best_increase:
   131      3700        511.5      0.1      1.7                      best_increase = increase
   132      3700        569.8      0.2      1.9                      best_position = next_i
   133                                           
   134       197         57.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.2      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         79.0     79.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0514661295457781

[('d198', 1.0514661295457781)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0304066 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       2147.2   2147.2      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         28.8     28.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        387.6    387.6      1.3          random.shuffle(notInPath)
   119                                           
   120       198         58.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         43.7      0.2      0.1              best_increase = np.inf
   126       197         27.4      0.1      0.1              best_position = None
   127     19700       3058.8      0.2     10.1              for i in range(len(path)):
   128     19503       4431.7      0.2     14.6                  next_i = (i + 1) % len(path)
   129     19503      15025.1      0.8     49.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3766.9      0.2     12.4                  if increase < best_increase:
   131      3932        563.4      0.1      1.9                      best_increase = increase
   132      3932        631.7      0.2      2.1                      best_position = next_i
   133                                           
   134       197         63.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.9      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         76.0     76.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.089003647843404

[('d198', 1.089003647843404)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0289278 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2091.0   2091.0      7.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.4     31.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        259.7    259.7      0.9          random.shuffle(notInPath)
   119                                           
   120       198         54.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.3      0.2      0.1              best_increase = np.inf
   126       197         25.9      0.1      0.1              best_position = None
   127     19700       2942.0      0.1     10.2              for i in range(len(path)):
   128     19503       4533.5      0.2     15.7                  next_i = (i + 1) % len(path)
   129     19503      14377.3      0.7     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3688.7      0.2     12.8                  if increase < best_increase:
   131      2264        326.5      0.1      1.1                      best_increase = increase
   132      2264        338.7      0.1      1.2                      best_position = next_i
   133                                           
   134       197         56.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.2      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         76.1     76.1      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0510182931318188

[('d198', 1.0510182931318188)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0301667 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2005.7   2005.7      6.6          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         17.8     17.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        208.2    208.2      0.7          random.shuffle(notInPath)
   119                                           
   120       198         54.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         44.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.0      0.2      0.1              best_increase = np.inf
   126       197         27.1      0.1      0.1              best_position = None
   127     19700       3115.9      0.2     10.3              for i in range(len(path)):
   128     19503       4682.7      0.2     15.5                  next_i = (i + 1) % len(path)
   129     19503      14963.5      0.8     49.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3987.8      0.2     13.2                  if increase < best_increase:
   131      2658        399.1      0.2      1.3                      best_increase = increase
   132      2658        423.4      0.2      1.4                      best_position = next_i
   133                                           
   134       197         64.5      0.3      0.2              path.insert(best_position, to_insert)
   135       197         54.6      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         74.7     74.7      0.2          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0612791926701268

[('d198', 1.0612791926701268)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0297852 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.2      1.2      0.0          n = self.numCity
   114         1       2107.4   2107.4      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.3     31.3      0.1          notInPath = [x for x in range(1, n)]
   118         1        387.6    387.6      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.5      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         41.7      0.2      0.1              best_increase = np.inf
   126       197         26.9      0.1      0.1              best_position = None
   127     19700       3080.0      0.2     10.3              for i in range(len(path)):
   128     19503       4729.4      0.2     15.9                  next_i = (i + 1) % len(path)
   129     19503      14490.3      0.7     48.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3693.4      0.2     12.4                  if increase < best_increase:
   131      3092        428.0      0.1      1.4                      best_increase = increase
   132      3092        473.3      0.2      1.6                      best_position = next_i
   133                                           
   134       197         64.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.4      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         80.6     80.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0768644138235326

[('d198', 1.0768644138235326)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299978 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       2077.9   2077.9      6.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.7     31.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        383.3    383.3      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         42.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.0      0.2      0.1              best_increase = np.inf
   126       197         28.4      0.1      0.1              best_position = None
   127     19700       3202.4      0.2     10.7              for i in range(len(path)):
   128     19503       4226.8      0.2     14.1                  next_i = (i + 1) % len(path)
   129     19503      14808.2      0.8     49.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3794.4      0.2     12.6                  if increase < best_increase:
   131      3796        529.1      0.1      1.8                      best_increase = increase
   132      3796        588.4      0.2      2.0                      best_position = next_i
   133                                           
   134       197         60.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.0      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         76.1     76.1      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0798318774725746

[('d198', 1.0798318774725746)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0294137 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2080.5   2080.5      7.1          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.4     31.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        374.3    374.3      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.4      0.2      0.1              best_increase = np.inf
   126       197         24.4      0.1      0.1              best_position = None
   127     19700       3060.9      0.2     10.4              for i in range(len(path)):
   128     19503       4343.6      0.2     14.8                  next_i = (i + 1) % len(path)
   129     19503      15206.1      0.8     51.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3436.6      0.2     11.7                  if increase < best_increase:
   131      1979        266.8      0.1      0.9                      best_increase = increase
   132      1979        269.7      0.1      0.9                      best_position = next_i
   133                                           
   134       197         57.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.8      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         79.2     79.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0659494985837599

[('d198', 1.0659494985837599)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0285622 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2071.0   2071.0      7.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         18.1     18.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        238.2    238.2      0.8          random.shuffle(notInPath)
   119                                           
   120       198         53.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.0      0.2      0.1              best_increase = np.inf
   126       197         22.8      0.1      0.1              best_position = None
   127     19700       3057.7      0.2     10.7              for i in range(len(path)):
   128     19503       4530.9      0.2     15.9                  next_i = (i + 1) % len(path)
   129     19503      14349.0      0.7     50.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3390.0      0.2     11.9                  if increase < best_increase:
   131      2042        282.5      0.1      1.0                      best_increase = increase
   132      2042        292.4      0.1      1.0                      best_position = next_i
   133                                           
   134       197         54.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         48.3      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         74.4     74.4      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0392252658951844

[('d198', 1.0392252658951844)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0285733 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2098.7   2098.7      7.3          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.8     31.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        309.1    309.1      1.1          random.shuffle(notInPath)
   119                                           
   120       198         51.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         33.6      0.2      0.1              best_increase = np.inf
   126       197         22.4      0.1      0.1              best_position = None
   127     19700       3032.4      0.2     10.6              for i in range(len(path)):
   128     19503       4357.7      0.2     15.3                  next_i = (i + 1) % len(path)
   129     19503      14484.0      0.7     50.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3416.7      0.2     12.0                  if increase < best_increase:
   131      1834        260.7      0.1      0.9                      best_increase = increase
   132      1834        251.9      0.1      0.9                      best_position = next_i
   133                                           
   134       197         58.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.6      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         76.4     76.4      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.068035192729323

[('d198', 1.068035192729323)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0289987 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2094.4   2094.4      7.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.4     31.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        409.2    409.2      1.4          random.shuffle(notInPath)
   119                                           
   120       198         51.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.9      0.2      0.1              best_increase = np.inf
   126       197         22.8      0.1      0.1              best_position = None
   127     19700       2974.7      0.2     10.3              for i in range(len(path)):
   128     19503       4561.1      0.2     15.7                  next_i = (i + 1) % len(path)
   129     19503      14348.7      0.7     49.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3431.8      0.2     11.8                  if increase < best_increase:
   131      2973        398.3      0.1      1.4                      best_increase = increase
   132      2973        418.9      0.1      1.4                      best_position = next_i
   133                                           
   134       197         54.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.2      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1         78.9     78.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.065698689052698

[('d198', 1.065698689052698)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0286439 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       1763.4   1763.4      6.2          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.1     15.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        193.2    193.2      0.7          random.shuffle(notInPath)
   119                                           
   120       198         51.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.2      0.2      0.1              best_increase = np.inf
   126       197         26.4      0.1      0.1              best_position = None
   127     19700       3069.1      0.2     10.7              for i in range(len(path)):
   128     19503       4358.3      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      14334.4      0.7     50.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3626.5      0.2     12.7                  if increase < best_increase:
   131      3270        461.2      0.1      1.6                      best_increase = increase
   132      3270        482.3      0.1      1.7                      best_position = next_i
   133                                           
   134       197         57.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.7     77.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0572252732205045

[('d198', 1.0572252732205045)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0291068 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2084.7   2084.7      7.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         28.9     28.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        409.0    409.0      1.4          random.shuffle(notInPath)
   119                                           
   120       198         55.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.6      0.2      0.1              best_increase = np.inf
   126       197         25.5      0.1      0.1              best_position = None
   127     19700       2958.8      0.2     10.2              for i in range(len(path)):
   128     19503       4534.2      0.2     15.6                  next_i = (i + 1) % len(path)
   129     19503      14436.2      0.7     49.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3588.4      0.2     12.3                  if increase < best_increase:
   131      2422        326.7      0.1      1.1                      best_increase = increase
   132      2422        378.6      0.2      1.3                      best_position = next_i
   133                                           
   134       197         56.5      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.6      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         91.9     91.9      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0709309748539906

[('d198', 1.0709309748539906)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.028861 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       1165.3   1165.3      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         15.6     15.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        210.8    210.8      0.7          random.shuffle(notInPath)
   119                                           
   120       198         53.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.5      0.2      0.1              best_increase = np.inf
   126       197         26.0      0.1      0.1              best_position = None
   127     19700       3096.3      0.2     10.7              for i in range(len(path)):
   128     19503       4363.0      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      15014.0      0.8     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       4051.0      0.2     14.0                  if increase < best_increase:
   131      1970        284.6      0.1      1.0                      best_increase = increase
   132      1970        301.2      0.2      1.0                      best_position = next_i
   133                                           
   134       197         61.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         62.8      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         77.3     77.3      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.06330871668644

[('d198', 1.06330871668644)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0294377 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2113.6   2113.6      7.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.6     31.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        238.8    238.8      0.8          random.shuffle(notInPath)
   119                                           
   120       198         51.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         34.4      0.2      0.1              best_increase = np.inf
   126       197         22.5      0.1      0.1              best_position = None
   127     19700       2971.4      0.2     10.1              for i in range(len(path)):
   128     19503       4533.0      0.2     15.4                  next_i = (i + 1) % len(path)
   129     19503      14485.1      0.7     49.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3446.0      0.2     11.7                  if increase < best_increase:
   131      4342        571.5      0.1      1.9                      best_increase = increase
   132      4342        711.6      0.2      2.4                      best_position = next_i
   133                                           
   134       197         59.6      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.8      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         80.8     80.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1067635675589118

[('d198', 1.1067635675589118)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0288487 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2078.9   2078.9      7.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         29.3     29.3      0.1          notInPath = [x for x in range(1, n)]
   118         1        394.8    394.8      1.4          random.shuffle(notInPath)
   119                                           
   120       198         60.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         55.5      0.3      0.2              best_increase = np.inf
   126       197         25.9      0.1      0.1              best_position = None
   127     19700       2803.7      0.1      9.7              for i in range(len(path)):
   128     19503       4523.4      0.2     15.7                  next_i = (i + 1) % len(path)
   129     19503      14506.6      0.7     50.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3653.9      0.2     12.7                  if increase < best_increase:
   131      1666        223.8      0.1      0.8                      best_increase = increase
   132      1666        251.1      0.2      0.9                      best_position = next_i
   133                                           
   134       197         59.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.7      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         89.3     89.3      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.08123796849561

[('d198', 1.08123796849561)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.029777 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2100.5   2100.5      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.7     31.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        408.0    408.0      1.4          random.shuffle(notInPath)
   119                                           
   120       198         93.0      0.5      0.3          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.2      0.2      0.1              best_increase = np.inf
   126       197         24.3      0.1      0.1              best_position = None
   127     19700       3054.7      0.2     10.3              for i in range(len(path)):
   128     19503       4528.3      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      15021.5      0.8     50.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3646.9      0.2     12.2                  if increase < best_increase:
   131      2170        305.9      0.1      1.0                      best_increase = increase
   132      2170        298.0      0.1      1.0                      best_position = next_i
   133                                           
   134       197         57.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.0      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.6     77.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0522200127151116

[('d198', 1.0522200127151116)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0303543 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2100.5   2100.5      6.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.3     29.3      0.1          notInPath = [x for x in range(1, n)]
   118         1        397.3    397.3      1.3          random.shuffle(notInPath)
   119                                           
   120       198         58.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.8      0.2      0.1              best_increase = np.inf
   126       197         28.6      0.1      0.1              best_position = None
   127     19700       3302.1      0.2     10.9              for i in range(len(path)):
   128     19503       4592.1      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14665.3      0.8     48.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3700.4      0.2     12.2                  if increase < best_increase:
   131      4019        596.1      0.1      2.0                      best_increase = increase
   132      4019        620.6      0.2      2.0                      best_position = next_i
   133                                           
   134       197         57.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         47.8      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         76.7     76.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0565712689194149

[('d198', 1.0565712689194149)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0292818 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2073.8   2073.8      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.1     29.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        377.2    377.2      1.3          random.shuffle(notInPath)
   119                                           
   120       198         55.5      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         45.3      0.2      0.2              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         40.5      0.2      0.1              best_increase = np.inf
   126       197         27.5      0.1      0.1              best_position = None
   127     19700       3115.1      0.2     10.6              for i in range(len(path)):
   128     19503       4329.2      0.2     14.8                  next_i = (i + 1) % len(path)
   129     19503      14540.6      0.7     49.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3694.5      0.2     12.6                  if increase < best_increase:
   131      2591        359.7      0.1      1.2                      best_increase = increase
   132      2591        400.4      0.2      1.4                      best_position = next_i
   133                                           
   134       197         60.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         53.1      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.0     77.0      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0609031744865571

[('d198', 1.0609031744865571)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0289226 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2059.5   2059.5      7.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.5     15.5      0.1          notInPath = [x for x in range(1, n)]
   118         1        203.9    203.9      0.7          random.shuffle(notInPath)
   119                                           
   120       198         52.0      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.2      0.2      0.1              best_increase = np.inf
   126       197         25.5      0.1      0.1              best_position = None
   127     19700       2936.8      0.1     10.2              for i in range(len(path)):
   128     19503       4261.6      0.2     14.7                  next_i = (i + 1) % len(path)
   129     19503      14221.4      0.7     49.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3697.4      0.2     12.8                  if increase < best_increase:
   131      4153        558.8      0.1      1.9                      best_increase = increase
   132      4153        633.7      0.2      2.2                      best_position = next_i
   133                                           
   134       197         55.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         74.7     74.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0566017134357564

[('d198', 1.0566017134357564)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0291452 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2078.0   2078.0      7.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         28.4     28.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        380.0    380.0      1.3          random.shuffle(notInPath)
   119                                           
   120       198         54.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.6      0.2      0.1              best_increase = np.inf
   126       197         26.6      0.1      0.1              best_position = None
   127     19700       3017.3      0.2     10.4              for i in range(len(path)):
   128     19503       4357.5      0.2     15.0                  next_i = (i + 1) % len(path)
   129     19503      14730.2      0.8     50.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3554.5      0.2     12.2                  if increase < best_increase:
   131      2296        316.0      0.1      1.1                      best_increase = increase
   132      2296        332.9      0.1      1.1                      best_position = next_i
   133                                           
   134       197         58.0      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.7      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         78.2     78.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0836754653622425

[('d198', 1.0836754653622425)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0287021 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2063.7   2063.7      7.2          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         16.1     16.1      0.1          notInPath = [x for x in range(1, n)]
   118         1        217.1    217.1      0.8          random.shuffle(notInPath)
   119                                           
   120       198         50.9      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         51.1      0.3      0.2              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.9      0.2      0.1              best_increase = np.inf
   126       197         22.7      0.1      0.1              best_position = None
   127     19700       2973.6      0.2     10.4              for i in range(len(path)):
   128     19503       4368.9      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      14154.8      0.7     49.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3473.3      0.2     12.1                  if increase < best_increase:
   131      4022        534.7      0.1      1.9                      best_increase = increase
   132      4022        556.5      0.1      1.9                      best_position = next_i
   133                                           
   134       197         54.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.1      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         79.8     79.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.1069559881760287

[('d198', 1.1069559881760287)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0287454 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       1251.6   1251.6      4.4          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         16.8     16.8      0.1          notInPath = [x for x in range(1, n)]
   118         1        204.2    204.2      0.7          random.shuffle(notInPath)
   119                                           
   120       198         48.5      0.2      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         36.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         34.8      0.2      0.1              best_increase = np.inf
   126       197         26.6      0.1      0.1              best_position = None
   127     19700       3070.4      0.2     10.7              for i in range(len(path)):
   128     19503       4300.5      0.2     15.0                  next_i = (i + 1) % len(path)
   129     19503      14834.0      0.8     51.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3616.7      0.2     12.6                  if increase < best_increase:
   131      3953        527.4      0.1      1.8                      best_increase = increase
   132      3953        599.7      0.2      2.1                      best_position = next_i
   133                                           
   134       197         54.6      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.8      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         74.7     74.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0517045654260782

[('d198', 1.0517045654260782)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0284568 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       1989.1   1989.1      7.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         17.4     17.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        195.6    195.6      0.7          random.shuffle(notInPath)
   119                                           
   120       198         52.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.8      0.2      0.1              best_increase = np.inf
   126       197         25.4      0.1      0.1              best_position = None
   127     19700       2859.5      0.1     10.0              for i in range(len(path)):
   128     19503       4419.1      0.2     15.5                  next_i = (i + 1) % len(path)
   129     19503      14366.4      0.7     50.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3543.7      0.2     12.5                  if increase < best_increase:
   131      2617        351.3      0.1      1.2                      best_increase = increase
   132      2617        379.3      0.1      1.3                      best_position = next_i
   133                                           
   134       197         56.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         45.3      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         77.4     77.4      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.04462693794923

[('d198', 1.04462693794923)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.029899 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2087.6   2087.6      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         33.0     33.0      0.1          notInPath = [x for x in range(1, n)]
   118         1        334.1    334.1      1.1          random.shuffle(notInPath)
   119                                           
   120       198         49.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         35.3      0.2      0.1              best_increase = np.inf
   126       197         25.2      0.1      0.1              best_position = None
   127     19700       3197.1      0.2     10.7              for i in range(len(path)):
   128     19503       4525.3      0.2     15.1                  next_i = (i + 1) % len(path)
   129     19503      14545.4      0.7     48.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3569.0      0.2     11.9                  if increase < best_increase:
   131      4295        597.4      0.1      2.0                      best_increase = increase
   132      4295        677.3      0.2      2.3                      best_position = next_i
   133                                           
   134       197         55.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         50.0      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         75.6     75.6      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0522381224154524

[('d198', 1.0522381224154524)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0306816 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2103.6   2103.6      6.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         29.2     29.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        280.6    280.6      0.9          random.shuffle(notInPath)
   119                                           
   120       198         49.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         38.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         36.1      0.2      0.1              best_increase = np.inf
   126       197         25.8      0.1      0.1              best_position = None
   127     19700       2917.0      0.1      9.5              for i in range(len(path)):
   128     19503       4527.4      0.2     14.8                  next_i = (i + 1) % len(path)
   129     19503      15739.3      0.8     51.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3542.5      0.2     11.5                  if increase < best_increase:
   131      4283        554.6      0.1      1.8                      best_increase = increase
   132      4283        621.0      0.1      2.0                      best_position = next_i
   133                                           
   134       197         54.8      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.7      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        112.2    112.2      0.4          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0534720417834902

[('d198', 1.0534720417834902)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0296019 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2085.3   2085.3      7.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.2     31.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        401.2    401.2      1.4          random.shuffle(notInPath)
   119                                           
   120       198         54.7      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.3      0.2      0.1              best_increase = np.inf
   126       197         26.3      0.1      0.1              best_position = None
   127     19700       3044.8      0.2     10.3              for i in range(len(path)):
   128     19503       4412.1      0.2     14.9                  next_i = (i + 1) % len(path)
   129     19503      14470.6      0.7     48.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3669.0      0.2     12.4                  if increase < best_increase:
   131      3950        551.1      0.1      1.9                      best_increase = increase
   132      3950        590.9      0.1      2.0                      best_position = next_i
   133                                           
   134       197         59.4      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.2      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         75.8     75.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0627153859501075

[('d198', 1.0627153859501075)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0302729 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.3      1.3      0.0          n = self.numCity
   114         1       2134.6   2134.6      7.1          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.3     31.3      0.1          notInPath = [x for x in range(1, n)]
   118         1        409.6    409.6      1.4          random.shuffle(notInPath)
   119                                           
   120       198         67.6      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.7      0.2      0.1              best_increase = np.inf
   126       197         27.3      0.1      0.1              best_position = None
   127     19700       3201.0      0.2     10.6              for i in range(len(path)):
   128     19503       4453.2      0.2     14.7                  next_i = (i + 1) % len(path)
   129     19503      15121.3      0.8     49.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3915.7      0.2     12.9                  if increase < best_increase:
   131      2205        300.5      0.1      1.0                      best_increase = increase
   132      2205        345.7      0.2      1.1                      best_position = next_i
   133                                           
   134       197         60.7      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.9      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         73.1     73.1      0.2          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.051229974607186

[('d198', 1.051229974607186)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0292852 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.4      1.4      0.0          n = self.numCity
   114         1       1601.6   1601.6      5.5          distances = np.array(self.adj)
   115         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         21.7     21.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        218.0    218.0      0.7          random.shuffle(notInPath)
   119                                           
   120       198         54.8      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         37.0      0.2      0.1              best_increase = np.inf
   126       197         23.3      0.1      0.1              best_position = None
   127     19700       3068.7      0.2     10.5              for i in range(len(path)):
   128     19503       4659.2      0.2     15.9                  next_i = (i + 1) % len(path)
   129     19503      14787.1      0.8     50.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3521.6      0.2     12.0                  if increase < best_increase:
   131      3829        511.4      0.1      1.7                      best_increase = increase
   132      3829        523.8      0.1      1.8                      best_position = next_i
   133                                           
   134       197         59.3      0.3      0.2              path.insert(best_position, to_insert)
   135       197         51.5      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        100.3    100.3      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0684854543760356

[('d198', 1.0684854543760356)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.030468 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2099.8   2099.8      6.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         29.2     29.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        390.4    390.4      1.3          random.shuffle(notInPath)
   119                                           
   120       198         56.2      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         41.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         41.3      0.2      0.1              best_increase = np.inf
   126       197         26.8      0.1      0.1              best_position = None
   127     19700       3097.4      0.2     10.2              for i in range(len(path)):
   128     19503       4770.3      0.2     15.7                  next_i = (i + 1) % len(path)
   129     19503      14697.3      0.8     48.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3894.1      0.2     12.8                  if increase < best_increase:
   131      3883        552.5      0.1      1.8                      best_increase = increase
   132      3883        580.1      0.1      1.9                      best_position = next_i
   133                                           
   134       197         59.9      0.3      0.2              path.insert(best_position, to_insert)
   135       197         49.2      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.9      0.9      0.0          self.tour = path
   138         1         79.2     79.2      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0699866539617222

[('d198', 1.0699866539617222)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0298188 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       2140.8   2140.8      7.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         28.9     28.9      0.1          notInPath = [x for x in range(1, n)]
   118         1        354.2    354.2      1.2          random.shuffle(notInPath)
   119                                           
   120       198         52.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         39.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         39.3      0.2      0.1              best_increase = np.inf
   126       197         22.9      0.1      0.1              best_position = None
   127     19700       3009.3      0.2     10.1              for i in range(len(path)):
   128     19503       4413.9      0.2     14.8                  next_i = (i + 1) % len(path)
   129     19503      14878.3      0.8     49.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3434.9      0.2     11.5                  if increase < best_increase:
   131      4399        611.7      0.1      2.1                      best_increase = increase
   132      4399        600.8      0.1      2.0                      best_position = next_i
   133                                           
   134       197         63.1      0.3      0.2              path.insert(best_position, to_insert)
   135       197         46.5      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1         79.7     79.7      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0694831053702911

[('d198', 1.0694831053702911)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0309334 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2105.7   2105.7      6.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         32.6     32.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        355.8    355.8      1.2          random.shuffle(notInPath)
   119                                           
   120       198         54.3      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         40.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         38.4      0.2      0.1              best_increase = np.inf
   126       197         26.4      0.1      0.1              best_position = None
   127     19700       3054.9      0.2      9.9              for i in range(len(path)):
   128     19503       4712.1      0.2     15.2                  next_i = (i + 1) % len(path)
   129     19503      15198.6      0.8     49.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3885.9      0.2     12.6                  if increase < best_increase:
   131      3947        563.7      0.1      1.8                      best_increase = increase
   132      3947        637.0      0.2      2.1                      best_position = next_i
   133                                           
   134       197         63.6      0.3      0.2              path.insert(best_position, to_insert)
   135       197         53.3      0.3      0.2              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        106.8    106.8      0.3          self.calculateCost()


Optimal 15780
_________________
d198
randomInsertion 1.0608580093125792

[('d198', 1.0608580093125792)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0281951 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       1110.7   1110.7      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         15.6     15.6      0.1          notInPath = [x for x in range(1, n)]
   118         1        208.7    208.7      0.7          random.shuffle(notInPath)
   119                                           
   120       198         52.1      0.3      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       197         37.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       197         35.8      0.2      0.1              best_increase = np.inf
   126       197         24.7      0.1      0.1              best_position = None
   127     19700       3097.8      0.2     11.0              for i in range(len(path)):
   128     19503       4553.0      0.2     16.1                  next_i = (i + 1) % len(path)
   129     19503      14519.8      0.7     51.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     19503       3611.7      0.2     12.8                  if increase < best_increase:
   131      2628        357.0      0.1      1.3                      best_increase = increase
   132      2628        387.0      0.1      1.4                      best_position = next_i
   133                                           
   134       197         55.2      0.3      0.2              path.insert(best_position, to_insert)
   135       197         47.6      0.2      0.2              in_path.add(to_insert)
   136                                           
   137         1          0.8      0.8      0.0          self.tour = path
   138         1         78.3     78.3      0.3          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.095432290859395

[('lin318', 1.095432290859395)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0730515 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2806.9   2806.9      3.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         25.3     25.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        305.2    305.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         60.9      0.2      0.1              best_increase = np.inf
   126       317         40.3      0.1      0.1              best_position = None
   127     50720       8002.2      0.2     11.0              for i in range(len(path)):
   128     50403      11714.9      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      38392.2      0.8     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9530.8      0.2     13.0                  if increase < best_increase:
   131      6104        825.4      0.1      1.1                      best_increase = increase
   132      6104        888.3      0.1      1.2                      best_position = next_i
   133                                           
   134       317         95.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         86.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        132.1    132.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0981085134750455

[('lin318', 1.0981085134750455)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0710876 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2760.9   2760.9      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         22.8     22.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        304.1    304.1      0.4          random.shuffle(notInPath)
   119                                           
   120       318         80.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.3      0.2      0.1              best_increase = np.inf
   126       317         39.5      0.1      0.1              best_position = None
   127     50720       7623.3      0.2     10.7              for i in range(len(path)):
   128     50403      11728.3      0.2     16.5                  next_i = (i + 1) % len(path)
   129     50403      37226.0      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9297.6      0.2     13.1                  if increase < best_increase:
   131      5514        747.9      0.1      1.1                      best_increase = increase
   132      5514        800.1      0.1      1.1                      best_position = next_i
   133                                           
   134       317         93.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         85.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        155.4    155.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0922775794707218

[('lin318', 1.0922775794707218)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0796574 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3404.9   3404.9      4.3          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.3      1.3      0.0          in_path = {0}
   117         1         28.0     28.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        320.5    320.5      0.4          random.shuffle(notInPath)
   119                                           
   120       318         93.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         67.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         67.4      0.2      0.1              best_increase = np.inf
   126       317         44.5      0.1      0.1              best_position = None
   127     50720       8008.7      0.2     10.1              for i in range(len(path)):
   128     50403      12696.8      0.3     15.9                  next_i = (i + 1) % len(path)
   129     50403      42618.2      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10097.0      0.2     12.7                  if increase < best_increase:
   131      5995        855.7      0.1      1.1                      best_increase = increase
   132      5995        921.2      0.2      1.2                      best_position = next_i
   133                                           
   134       317        109.4      0.3      0.1              path.insert(best_position, to_insert)
   135       317         96.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        223.2    223.2      0.3          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0901518971012252

[('lin318', 1.0901518971012252)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0730009 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.4      1.4      0.0          n = self.numCity
   114         1       2948.4   2948.4      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         23.9     23.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        332.9    332.9      0.5          random.shuffle(notInPath)
   119                                           
   120       318         84.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         63.3      0.2      0.1              best_increase = np.inf
   126       317         44.2      0.1      0.1              best_position = None
   127     50720       7953.4      0.2     10.9              for i in range(len(path)):
   128     50403      11656.6      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      38733.8      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9505.3      0.2     13.0                  if increase < best_increase:
   131      4116        550.4      0.1      0.8                      best_increase = increase
   132      4116        647.4      0.2      0.9                      best_position = next_i
   133                                           
   134       317        102.4      0.3      0.1              path.insert(best_position, to_insert)
   135       317         92.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.6      2.6      0.0          self.tour = path
   138         1        193.2    193.2      0.3          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0963592735558008

[('lin318', 1.0963592735558008)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.07619 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       3335.8   3335.8      4.4          distances = np.array(self.adj)
   115         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         26.8     26.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        339.3    339.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318        103.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         72.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         65.1      0.2      0.1              best_increase = np.inf
   126       317         41.8      0.1      0.1              best_position = None
   127     50720       8371.5      0.2     11.0              for i in range(len(path)):
   128     50403      11578.0      0.2     15.2                  next_i = (i + 1) % len(path)
   129     50403      40962.2      0.8     53.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9646.3      0.2     12.7                  if increase < best_increase:
   131      4296        589.5      0.1      0.8                      best_increase = increase
   132      4296        661.6      0.2      0.9                      best_position = next_i
   133                                           
   134       317        113.1      0.4      0.1              path.insert(best_position, to_insert)
   135       317        106.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        173.0    173.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0931753389918029

[('lin318', 1.0931753389918029)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0757262 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       3281.0   3281.0      4.3          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         25.7     25.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        330.2    330.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         87.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         65.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         99.3      0.3      0.1              best_increase = np.inf
   126       317         38.4      0.1      0.1              best_position = None
   127     50720       8085.9      0.2     10.7              for i in range(len(path)):
   128     50403      11992.6      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      40010.6      0.8     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9359.7      0.2     12.4                  if increase < best_increase:
   131      6662        946.2      0.1      1.2                      best_increase = increase
   132      6662       1020.1      0.2      1.3                      best_position = next_i
   133                                           
   134       317        102.3      0.3      0.1              path.insert(best_position, to_insert)
   135       317         96.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        181.2    181.2      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1118486481243162

[('lin318', 1.1118486481243162)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0814731 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3149.3   3149.3      3.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.2      1.2      0.0          in_path = {0}
   117         1         27.2     27.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        291.8    291.8      0.4          random.shuffle(notInPath)
   119                                           
   120       318         95.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         77.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         73.4      0.2      0.1              best_increase = np.inf
   126       317         42.8      0.1      0.1              best_position = None
   127     50720       8056.5      0.2      9.9              for i in range(len(path)):
   128     50403      13111.5      0.3     16.1                  next_i = (i + 1) % len(path)
   129     50403      43560.9      0.9     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10420.4      0.2     12.8                  if increase < best_increase:
   131      6632        971.3      0.1      1.2                      best_increase = increase
   132      6632       1076.3      0.2      1.3                      best_position = next_i
   133                                           
   134       317        129.1      0.4      0.2              path.insert(best_position, to_insert)
   135       317        116.7      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.9      2.9      0.0          self.tour = path
   138         1        267.4    267.4      0.3          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1122898009646487

[('lin318', 1.1122898009646487)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.074621 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       3043.9   3043.9      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         27.6     27.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        334.4    334.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         88.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         80.9      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         74.9      0.2      0.1              best_increase = np.inf
   126       317         40.3      0.1      0.1              best_position = None
   127     50720       7345.4      0.1      9.8              for i in range(len(path)):
   128     50403      12392.9      0.2     16.6                  next_i = (i + 1) % len(path)
   129     50403      39634.6      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9717.6      0.2     13.0                  if increase < best_increase:
   131      4883        720.8      0.1      1.0                      best_increase = increase
   132      4883        735.0      0.2      1.0                      best_position = next_i
   133                                           
   134       317        114.5      0.4      0.2              path.insert(best_position, to_insert)
   135       317         92.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        173.7    173.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1112083143232194

[('lin318', 1.1112083143232194)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0746793 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       3025.6   3025.6      4.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         24.9     24.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        346.2    346.2      0.5          random.shuffle(notInPath)
   119                                           
   120       318         87.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         68.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         67.4      0.2      0.1              best_increase = np.inf
   126       317         39.0      0.1      0.1              best_position = None
   127     50720       8220.0      0.2     11.0              for i in range(len(path)):
   128     50403      12317.6      0.2     16.5                  next_i = (i + 1) % len(path)
   129     50403      39231.4      0.8     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9578.5      0.2     12.8                  if increase < best_increase:
   131      4397        616.0      0.1      0.8                      best_increase = increase
   132      4397        661.2      0.2      0.9                      best_position = next_i
   133                                           
   134       317        120.2      0.4      0.2              path.insert(best_position, to_insert)
   135       317         94.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        175.7    175.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0912537853107867

[('lin318', 1.0912537853107867)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0825699 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       3295.5   3295.5      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.0      1.0      0.0          in_path = {0}
   117         1         26.0     26.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        359.8    359.8      0.4          random.shuffle(notInPath)
   119                                           
   120       318        106.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         81.1      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         81.3      0.3      0.1              best_increase = np.inf
   126       317         43.6      0.1      0.1              best_position = None
   127     50720       9110.0      0.2     11.0              for i in range(len(path)):
   128     50403      13486.3      0.3     16.3                  next_i = (i + 1) % len(path)
   129     50403      43695.1      0.9     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10416.1      0.2     12.6                  if increase < best_increase:
   131      4648        703.6      0.2      0.9                      best_increase = increase
   132      4648        719.3      0.2      0.9                      best_position = next_i
   133                                           
   134       317        151.2      0.5      0.2              path.insert(best_position, to_insert)
   135       317        116.7      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        173.6    173.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1295013577786848

[('lin318', 1.1295013577786848)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0779643 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4225.9   4225.9      5.4          distances = np.array(self.adj)
   115         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.3      1.3      0.0          in_path = {0}
   117         1         49.7     49.7      0.1          notInPath = [x for x in range(1, n)]
   118         1        438.0    438.0      0.6          random.shuffle(notInPath)
   119                                           
   120       318         93.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         67.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         73.3      0.2      0.1              best_increase = np.inf
   126       317         42.9      0.1      0.1              best_position = None
   127     50720       7983.2      0.2     10.2              for i in range(len(path)):
   128     50403      13155.4      0.3     16.9                  next_i = (i + 1) % len(path)
   129     50403      40000.4      0.8     51.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9888.8      0.2     12.7                  if increase < best_increase:
   131      5057        724.0      0.1      0.9                      best_increase = increase
   132      5057        791.8      0.2      1.0                      best_position = next_i
   133                                           
   134       317        133.8      0.4      0.2              path.insert(best_position, to_insert)
   135       317        107.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        182.8    182.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0918683201856334

[('lin318', 1.0918683201856334)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0846134 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       3304.6   3304.6      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         25.9     25.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        302.7    302.7      0.4          random.shuffle(notInPath)
   119                                           
   120       318        101.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         77.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         72.2      0.2      0.1              best_increase = np.inf
   126       317         42.7      0.1      0.1              best_position = None
   127     50720       8588.8      0.2     10.2              for i in range(len(path)):
   128     50403      12112.6      0.2     14.3                  next_i = (i + 1) % len(path)
   129     50403      46703.6      0.9     55.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10863.8      0.2     12.8                  if increase < best_increase:
   131      6295        890.8      0.1      1.1                      best_increase = increase
   132      6295       1089.3      0.2      1.3                      best_position = next_i
   133                                           
   134       317        137.2      0.4      0.2              path.insert(best_position, to_insert)
   135       317        118.8      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.2      2.2      0.0          self.tour = path
   138         1        177.2    177.2      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.122700964623324

[('lin318', 1.122700964623324)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0744764 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       3032.4   3032.4      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         30.1     30.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        340.7    340.7      0.5          random.shuffle(notInPath)
   119                                           
   120       318         88.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         66.0      0.2      0.1              best_increase = np.inf
   126       317         41.2      0.1      0.1              best_position = None
   127     50720       8038.1      0.2     10.8              for i in range(len(path)):
   128     50403      12043.3      0.2     16.2                  next_i = (i + 1) % len(path)
   129     50403      39005.6      0.8     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9629.5      0.2     12.9                  if increase < best_increase:
   131      6055        865.1      0.1      1.2                      best_increase = increase
   132      6055        895.6      0.1      1.2                      best_position = next_i
   133                                           
   134       317         98.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317         91.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.4      1.4      0.0          self.tour = path
   138         1        144.0    144.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1206694672328084

[('lin318', 1.1206694672328084)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0790346 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3234.7   3234.7      4.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.0      1.0      0.0          in_path = {0}
   117         1         28.2     28.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        348.4    348.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         88.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         67.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         70.6      0.2      0.1              best_increase = np.inf
   126       317         43.9      0.1      0.1              best_position = None
   127     50720       8749.4      0.2     11.1              for i in range(len(path)):
   128     50403      12307.5      0.2     15.6                  next_i = (i + 1) % len(path)
   129     50403      41810.4      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10216.3      0.2     12.9                  if increase < best_increase:
   131      5349        780.9      0.1      1.0                      best_increase = increase
   132      5349        874.2      0.2      1.1                      best_position = next_i
   133                                           
   134       317        123.0      0.4      0.2              path.insert(best_position, to_insert)
   135       317        114.9      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        172.4    172.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0992925743043875

[('lin318', 1.0992925743043875)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0752874 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3054.0   3054.0      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         24.2     24.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        343.6    343.6      0.5          random.shuffle(notInPath)
   119                                           
   120       318         91.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         65.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         61.5      0.2      0.1              best_increase = np.inf
   126       317         44.5      0.1      0.1              best_position = None
   127     50720       7965.7      0.2     10.6              for i in range(len(path)):
   128     50403      11980.6      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      39283.9      0.8     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9992.2      0.2     13.3                  if increase < best_increase:
   131      6471        947.2      0.1      1.3                      best_increase = increase
   132      6471       1048.7      0.2      1.4                      best_position = next_i
   133                                           
   134       317        103.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         94.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        182.3    182.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1064395445386384

[('lin318', 1.1064395445386384)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0771388 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       3443.2   3443.2      4.5          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         31.7     31.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        318.7    318.7      0.4          random.shuffle(notInPath)
   119                                           
   120       318         90.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         68.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         72.6      0.2      0.1              best_increase = np.inf
   126       317         43.8      0.1      0.1              best_position = None
   127     50720       8390.7      0.2     10.9              for i in range(len(path)):
   128     50403      11565.9      0.2     15.0                  next_i = (i + 1) % len(path)
   129     50403      41420.9      0.8     53.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9740.8      0.2     12.6                  if increase < best_increase:
   131      5185        731.2      0.1      0.9                      best_increase = increase
   132      5185        805.2      0.2      1.0                      best_position = next_i
   133                                           
   134       317        118.1      0.4      0.2              path.insert(best_position, to_insert)
   135       317        110.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        182.5    182.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1101187098390983

[('lin318', 1.1101187098390983)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0741981 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       3039.2   3039.2      4.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         24.7     24.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        316.3    316.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         88.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         61.8      0.2      0.1              best_increase = np.inf
   126       317         42.0      0.1      0.1              best_position = None
   127     50720       7696.0      0.2     10.4              for i in range(len(path)):
   128     50403      12065.7      0.2     16.3                  next_i = (i + 1) % len(path)
   129     50403      39048.1      0.8     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9598.3      0.2     12.9                  if increase < best_increase:
   131      6044        854.1      0.1      1.2                      best_increase = increase
   132      6044        908.7      0.2      1.2                      best_position = next_i
   133                                           
   134       317        105.2      0.3      0.1              path.insert(best_position, to_insert)
   135       317         92.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.4      2.4      0.0          self.tour = path
   138         1        187.7    187.7      0.3          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1019340782422353

[('lin318', 1.1019340782422353)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0756682 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2994.5   2994.5      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.1      1.1      0.0          in_path = {0}
   117         1         28.4     28.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        317.9    317.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         87.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         66.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         66.1      0.2      0.1              best_increase = np.inf
   126       317         44.4      0.1      0.1              best_position = None
   127     50720       8263.6      0.2     10.9              for i in range(len(path)):
   128     50403      12549.3      0.2     16.6                  next_i = (i + 1) % len(path)
   129     50403      39279.5      0.8     51.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9875.0      0.2     13.1                  if increase < best_increase:
   131      5817        843.0      0.1      1.1                      best_increase = increase
   132      5817        902.7      0.2      1.2                      best_position = next_i
   133                                           
   134       317         96.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         85.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        164.5    164.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.103677898833388

[('lin318', 1.103677898833388)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0843162 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       3795.0   3795.0      4.5          distances = np.array(self.adj)
   115         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.4      1.4      0.0          in_path = {0}
   117         1         31.2     31.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        323.8    323.8      0.4          random.shuffle(notInPath)
   119                                           
   120       318        101.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         83.6      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         80.0      0.3      0.1              best_increase = np.inf
   126       317         46.5      0.1      0.1              best_position = None
   127     50720       8834.9      0.2     10.5              for i in range(len(path)):
   128     50403      13472.0      0.3     16.0                  next_i = (i + 1) % len(path)
   129     50403      44888.7      0.9     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10763.7      0.2     12.8                  if increase < best_increase:
   131      4326        691.5      0.2      0.8                      best_increase = increase
   132      4326        717.8      0.2      0.9                      best_position = next_i
   133                                           
   134       317        157.7      0.5      0.2              path.insert(best_position, to_insert)
   135       317        122.0      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.7      2.7      0.0          self.tour = path
   138         1        200.6    200.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1096877278546562

[('lin318', 1.1096877278546562)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0741714 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.5      1.5      0.0          n = self.numCity
   114         1       3736.2   3736.2      5.0          distances = np.array(self.adj)
   115         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.0      1.0      0.0          in_path = {0}
   117         1         28.9     28.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        402.2    402.2      0.5          random.shuffle(notInPath)
   119                                           
   120       318         83.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         64.7      0.2      0.1              best_increase = np.inf
   126       317         39.4      0.1      0.1              best_position = None
   127     50720       8163.2      0.2     11.0              for i in range(len(path)):
   128     50403      11990.7      0.2     16.2                  next_i = (i + 1) % len(path)
   129     50403      38586.8      0.8     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9365.5      0.2     12.6                  if increase < best_increase:
   131      4268        612.8      0.1      0.8                      best_increase = increase
   132      4268        637.7      0.1      0.9                      best_position = next_i
   133                                           
   134       317         98.4      0.3      0.1              path.insert(best_position, to_insert)
   135       317        105.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        188.5    188.5      0.3          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.109052745397625

[('lin318', 1.109052745397625)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0804362 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       3474.9   3474.9      4.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         25.7     25.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        361.2    361.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318        102.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         77.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         81.9      0.3      0.1              best_increase = np.inf
   126       317         43.0      0.1      0.1              best_position = None
   127     50720       7839.0      0.2      9.7              for i in range(len(path)):
   128     50403      13422.5      0.3     16.7                  next_i = (i + 1) % len(path)
   129     50403      42644.2      0.8     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10316.0      0.2     12.8                  if increase < best_increase:
   131      5165        778.0      0.2      1.0                      best_increase = increase
   132      5165        836.5      0.2      1.0                      best_position = next_i
   133                                           
   134       317        123.4      0.4      0.2              path.insert(best_position, to_insert)
   135       317        114.5      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.4      2.4      0.0          self.tour = path
   138         1        191.4    191.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0992771231831766

[('lin318', 1.0992771231831766)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0843982 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       3432.8   3432.8      4.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         28.9     28.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        316.3    316.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         98.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         81.2      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         75.7      0.2      0.1              best_increase = np.inf
   126       317         42.4      0.1      0.1              best_position = None
   127     50720       9116.2      0.2     10.8              for i in range(len(path)):
   128     50403      13051.5      0.3     15.5                  next_i = (i + 1) % len(path)
   129     50403      45693.2      0.9     54.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10562.5      0.2     12.5                  if increase < best_increase:
   131      4675        695.1      0.1      0.8                      best_increase = increase
   132      4675        729.7      0.2      0.9                      best_position = next_i
   133                                           
   134       317        160.6      0.5      0.2              path.insert(best_position, to_insert)
   135       317        130.1      0.4      0.2              in_path.add(to_insert)
   136                                           
   137         1          3.0      3.0      0.0          self.tour = path
   138         1        177.9    177.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1107803448677505

[('lin318', 1.1107803448677505)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0785337 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.2      1.2      0.0          n = self.numCity
   114         1       3404.4   3404.4      4.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         30.1     30.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        342.9    342.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         91.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         72.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         70.2      0.2      0.1              best_increase = np.inf
   126       317         45.2      0.1      0.1              best_position = None
   127     50720       8343.4      0.2     10.6              for i in range(len(path)):
   128     50403      11596.5      0.2     14.8                  next_i = (i + 1) % len(path)
   129     50403      41797.3      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10249.4      0.2     13.1                  if increase < best_increase:
   131      6630        950.9      0.1      1.2                      best_increase = increase
   132      6630       1083.3      0.2      1.4                      best_position = next_i
   133                                           
   134       317        153.4      0.5      0.2              path.insert(best_position, to_insert)
   135       317        113.0      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          3.0      3.0      0.0          self.tour = path
   138         1        183.6    183.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.130800931971233

[('lin318', 1.130800931971233)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.07848 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3890.3   3890.3      5.0          distances = np.array(self.adj)
   115         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.0      1.0      0.0          in_path = {0}
   117         1         28.7     28.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        343.6    343.6      0.4          random.shuffle(notInPath)
   119                                           
   120       318         92.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         72.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         66.8      0.2      0.1              best_increase = np.inf
   126       317         38.4      0.1      0.0              best_position = None
   127     50720       8063.0      0.2     10.3              for i in range(len(path)):
   128     50403      12381.3      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      41683.0      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9483.7      0.2     12.1                  if increase < best_increase:
   131      6559        967.3      0.1      1.2                      best_increase = increase
   132      6559        945.7      0.1      1.2                      best_position = next_i
   133                                           
   134       317        113.9      0.4      0.1              path.insert(best_position, to_insert)
   135       317        114.3      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.8      2.8      0.0          self.tour = path
   138         1        189.7    189.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.103544356934089

[('lin318', 1.103544356934089)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0770653 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       3381.9   3381.9      4.4          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         25.8     25.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        328.3    328.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         95.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         73.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         69.4      0.2      0.1              best_increase = np.inf
   126       317         39.2      0.1      0.1              best_position = None
   127     50720       8347.6      0.2     10.8              for i in range(len(path)):
   128     50403      12144.5      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      41426.8      0.8     53.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9379.3      0.2     12.2                  if increase < best_increase:
   131      4527        645.2      0.1      0.8                      best_increase = increase
   132      4527        661.0      0.1      0.9                      best_position = next_i
   133                                           
   134       317        140.3      0.4      0.2              path.insert(best_position, to_insert)
   135       317        113.7      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        188.5    188.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1138546735830868

[('lin318', 1.1138546735830868)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0791893 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3380.1   3380.1      4.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         29.5     29.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        332.4    332.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         96.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         69.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         74.3      0.2      0.1              best_increase = np.inf
   126       317         43.4      0.1      0.1              best_position = None
   127     50720       7918.8      0.2     10.0              for i in range(len(path)):
   128     50403      12380.6      0.2     15.6                  next_i = (i + 1) % len(path)
   129     50403      42333.3      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10106.2      0.2     12.8                  if increase < best_increase:
   131      6385        962.0      0.2      1.2                      best_increase = increase
   132      6385       1020.7      0.2      1.3                      best_position = next_i
   133                                           
   134       317        133.3      0.4      0.2              path.insert(best_position, to_insert)
   135       317        120.6      0.4      0.2              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        184.3    184.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.103755705097795

[('lin318', 1.103755705097795)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0696642 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2768.7   2768.7      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         23.0     23.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        362.6    362.6      0.5          random.shuffle(notInPath)
   119                                           
   120       318         82.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.4      0.2      0.1              best_increase = np.inf
   126       317         38.7      0.1      0.1              best_position = None
   127     50720       7371.8      0.1     10.6              for i in range(len(path)):
   128     50403      10983.2      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      36741.3      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9422.0      0.2     13.5                  if increase < best_increase:
   131      5041        705.3      0.1      1.0                      best_increase = increase
   132      5041        736.2      0.1      1.1                      best_position = next_i
   133                                           
   134       317         91.5      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        131.5    131.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0937416101463855

[('lin318', 1.0937416101463855)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.078454 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3216.3   3216.3      4.1          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         40.2     40.2      0.1          notInPath = [x for x in range(1, n)]
   118         1        349.4    349.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         88.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         66.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         62.5      0.2      0.1              best_increase = np.inf
   126       317         42.1      0.1      0.1              best_position = None
   127     50720       8454.0      0.2     10.8              for i in range(len(path)):
   128     50403      12753.8      0.3     16.3                  next_i = (i + 1) % len(path)
   129     50403      41143.2      0.8     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9984.9      0.2     12.7                  if increase < best_increase:
   131      6264        909.3      0.1      1.2                      best_increase = increase
   132      6264        976.5      0.2      1.2                      best_position = next_i
   133                                           
   134       317         98.9      0.3      0.1              path.insert(best_position, to_insert)
   135       317         88.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        175.7    175.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1177792465498309

[('lin318', 1.1177792465498309)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0814452 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       3320.8   3320.8      4.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         25.3     25.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        330.3    330.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         99.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         75.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         80.8      0.3      0.1              best_increase = np.inf
   126       317         57.8      0.2      0.1              best_position = None
   127     50720       8441.3      0.2     10.4              for i in range(len(path)):
   128     50403      12788.7      0.3     15.7                  next_i = (i + 1) % len(path)
   129     50403      43256.8      0.9     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10455.7      0.2     12.8                  if increase < best_increase:
   131      6502       1002.6      0.2      1.2                      best_increase = increase
   132      6502       1061.7      0.2      1.3                      best_position = next_i
   133                                           
   134       317        142.0      0.4      0.2              path.insert(best_position, to_insert)
   135       317        122.4      0.4      0.2              in_path.add(to_insert)
   136                                           
   137         1          2.5      2.5      0.0          self.tour = path
   138         1        180.1    180.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0964277770231794

[('lin318', 1.0964277770231794)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0791475 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       3547.8   3547.8      4.5          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         31.9     31.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        356.6    356.6      0.5          random.shuffle(notInPath)
   119                                           
   120       318         95.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         86.6      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         74.0      0.2      0.1              best_increase = np.inf
   126       317         43.3      0.1      0.1              best_position = None
   127     50720       8383.6      0.2     10.6              for i in range(len(path)):
   128     50403      12632.3      0.3     16.0                  next_i = (i + 1) % len(path)
   129     50403      41723.9      0.8     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10164.3      0.2     12.8                  if increase < best_increase:
   131      5107        738.6      0.1      0.9                      best_increase = increase
   132      5107        828.7      0.2      1.0                      best_position = next_i
   133                                           
   134       317        127.4      0.4      0.2              path.insert(best_position, to_insert)
   135       317        116.3      0.4      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        192.2    192.2      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0779062259383831

[('lin318', 1.0779062259383831)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0783542 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       3342.4   3342.4      4.3          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         29.2     29.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        334.5    334.5      0.4          random.shuffle(notInPath)
   119                                           
   120       318         93.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         76.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         75.3      0.2      0.1              best_increase = np.inf
   126       317         44.3      0.1      0.1              best_position = None
   127     50720       8198.0      0.2     10.5              for i in range(len(path)):
   128     50403      12035.6      0.2     15.4                  next_i = (i + 1) % len(path)
   129     50403      41637.0      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10619.5      0.2     13.6                  if increase < best_increase:
   131      4814        689.1      0.1      0.9                      best_increase = increase
   132      4814        745.5      0.2      1.0                      best_position = next_i
   133                                           
   134       317        124.6      0.4      0.2              path.insert(best_position, to_insert)
   135       317        119.2      0.4      0.2              in_path.add(to_insert)
   136                                           
   137         1          2.9      2.9      0.0          self.tour = path
   138         1        184.6    184.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1200339204954624

[('lin318', 1.1200339204954624)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0690104 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2909.7   2909.7      4.2          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.2      1.2      0.0          in_path = {0}
   117         1         27.1     27.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        305.9    305.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         83.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         63.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.1      0.2      0.1              best_increase = np.inf
   126       317         36.6      0.1      0.1              best_position = None
   127     50720       7642.3      0.2     11.1              for i in range(len(path)):
   128     50403      11278.6      0.2     16.3                  next_i = (i + 1) % len(path)
   129     50403      36423.4      0.7     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8734.7      0.2     12.7                  if increase < best_increase:
   131      4235        567.5      0.1      0.8                      best_increase = increase
   132      4235        571.1      0.1      0.8                      best_position = next_i
   133                                           
   134       317         93.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        128.0    128.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1246941066441651

[('lin318', 1.1246941066441651)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.076304 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       3175.1   3175.1      4.2          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         27.7     27.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        307.0    307.0      0.4          random.shuffle(notInPath)
   119                                           
   120       318         88.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         69.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         77.9      0.2      0.1              best_increase = np.inf
   126       317         38.8      0.1      0.1              best_position = None
   127     50720       8385.2      0.2     11.0              for i in range(len(path)):
   128     50403      12451.8      0.2     16.3                  next_i = (i + 1) % len(path)
   129     50403      39834.7      0.8     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9403.3      0.2     12.3                  if increase < best_increase:
   131      7040       1021.3      0.1      1.3                      best_increase = increase
   132      7040       1027.2      0.1      1.3                      best_position = next_i
   133                                           
   134       317        110.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317        100.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        180.4    180.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.102776344364807

[('lin318', 1.102776344364807)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0788645 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.4      1.4      0.0          n = self.numCity
   114         1       3687.3   3687.3      4.7          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.0      1.0      0.0          in_path = {0}
   117         1         35.1     35.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        328.9    328.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         93.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         74.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         78.3      0.2      0.1              best_increase = np.inf
   126       317         45.7      0.1      0.1              best_position = None
   127     50720       8194.1      0.2     10.4              for i in range(len(path)):
   128     50403      12531.8      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      41530.6      0.8     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9968.4      0.2     12.6                  if increase < best_increase:
   131      6124        885.9      0.1      1.1                      best_increase = increase
   132      6124        962.9      0.2      1.2                      best_position = next_i
   133                                           
   134       317        135.7      0.4      0.2              path.insert(best_position, to_insert)
   135       317        130.7      0.4      0.2              in_path.add(to_insert)
   136                                           
   137         1          2.2      2.2      0.0          self.tour = path
   138         1        176.1    176.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0934219480542826

[('lin318', 1.0934219480542826)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0765179 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       3407.7   3407.7      4.5          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         32.1     32.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        329.2    329.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         91.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         74.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         68.7      0.2      0.1              best_increase = np.inf
   126       317         41.6      0.1      0.1              best_position = None
   127     50720       7710.5      0.2     10.1              for i in range(len(path)):
   128     50403      12098.5      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      40550.1      0.8     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9913.3      0.2     13.0                  if increase < best_increase:
   131      6295        828.5      0.1      1.1                      best_increase = increase
   132      6295        968.8      0.2      1.3                      best_position = next_i
   133                                           
   134       317        112.3      0.4      0.1              path.insert(best_position, to_insert)
   135       317        106.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        180.5    180.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.111345456719339

[('lin318', 1.111345456719339)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0747019 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2746.2   2746.2      3.7          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         26.3     26.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        287.0    287.0      0.4          random.shuffle(notInPath)
   119                                           
   120       318         81.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         65.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.8      0.2      0.1              best_increase = np.inf
   126       317         42.5      0.1      0.1              best_position = None
   127     50720       7623.3      0.2     10.2              for i in range(len(path)):
   128     50403      11656.1      0.2     15.6                  next_i = (i + 1) % len(path)
   129     50403      39682.5      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10291.6      0.2     13.8                  if increase < best_increase:
   131      6216        879.5      0.1      1.2                      best_increase = increase
   132      6216        921.9      0.1      1.2                      best_position = next_i
   133                                           
   134       317         93.5      0.3      0.1              path.insert(best_position, to_insert)
   135       317         89.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.4      1.4      0.0          self.tour = path
   138         1        153.8    153.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1016955834184718

[('lin318', 1.1016955834184718)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0711803 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2752.5   2752.5      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         26.6     26.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        307.5    307.5      0.4          random.shuffle(notInPath)
   119                                           
   120       318         83.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.9      0.2      0.1              best_increase = np.inf
   126       317         37.5      0.1      0.1              best_position = None
   127     50720       7961.5      0.2     11.2              for i in range(len(path)):
   128     50403      11659.2      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      37414.3      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8999.8      0.2     12.6                  if increase < best_increase:
   131      5421        771.1      0.1      1.1                      best_increase = increase
   132      5421        739.4      0.1      1.0                      best_position = next_i
   133                                           
   134       317         95.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        127.3    127.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1026108105362746

[('lin318', 1.1026108105362746)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0703759 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2868.9   2868.9      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         22.4     22.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        318.7    318.7      0.5          random.shuffle(notInPath)
   119                                           
   120       318         83.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         59.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.4      0.2      0.1              best_increase = np.inf
   126       317         40.4      0.1      0.1              best_position = None
   127     50720       7136.2      0.1     10.1              for i in range(len(path)):
   128     50403      11226.9      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      37362.5      0.7     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9201.8      0.2     13.1                  if increase < best_increase:
   131      5833        801.5      0.1      1.1                      best_increase = increase
   132      5833        885.8      0.2      1.3                      best_position = next_i
   133                                           
   134       317         98.4      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        124.5    124.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.099203254882393

[('lin318', 1.099203254882393)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0738914 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2816.9   2816.9      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         25.5     25.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        305.0    305.0      0.4          random.shuffle(notInPath)
   119                                           
   120       318         83.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         63.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         62.4      0.2      0.1              best_increase = np.inf
   126       317         39.4      0.1      0.1              best_position = None
   127     50720       7631.8      0.2     10.3              for i in range(len(path)):
   128     50403      11899.9      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      39480.2      0.8     53.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9754.2      0.2     13.2                  if increase < best_increase:
   131      4678        645.0      0.1      0.9                      best_increase = increase
   132      4678        698.5      0.1      0.9                      best_position = next_i
   133                                           
   134       317        107.8      0.3      0.1              path.insert(best_position, to_insert)
   135       317         96.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          3.3      3.3      0.0          self.tour = path
   138         1        176.3    176.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1244467915415632

[('lin318', 1.1244467915415632)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0770034 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       3231.8   3231.8      4.2          distances = np.array(self.adj)
   115         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.0      1.0      0.0          in_path = {0}
   117         1         32.5     32.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        328.4    328.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         89.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         99.7      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         68.2      0.2      0.1              best_increase = np.inf
   126       317         45.0      0.1      0.1              best_position = None
   127     50720       8311.3      0.2     10.8              for i in range(len(path)):
   128     50403      11993.1      0.2     15.6                  next_i = (i + 1) % len(path)
   129     50403      40035.6      0.8     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10736.1      0.2     13.9                  if increase < best_increase:
   131      5375        762.2      0.1      1.0                      best_increase = increase
   132      5375        859.3      0.2      1.1                      best_position = next_i
   133                                           
   134       317        118.3      0.4      0.2              path.insert(best_position, to_insert)
   135       317        109.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        178.4    178.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0909719392378887

[('lin318', 1.0909719392378887)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0707655 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2877.1   2877.1      4.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         23.9     23.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        331.1    331.1      0.5          random.shuffle(notInPath)
   119                                           
   120       318         83.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         61.4      0.2      0.1              best_increase = np.inf
   126       317         40.6      0.1      0.1              best_position = None
   127     50720       7386.9      0.1     10.4              for i in range(len(path)):
   128     50403      11673.4      0.2     16.5                  next_i = (i + 1) % len(path)
   129     50403      37297.1      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9385.6      0.2     13.3                  if increase < best_increase:
   131      4251        583.9      0.1      0.8                      best_increase = increase
   132      4251        629.9      0.1      0.9                      best_position = next_i
   133                                           
   134       317        108.5      0.3      0.2              path.insert(best_position, to_insert)
   135       317         84.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        133.6    133.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.086774708409456

[('lin318', 1.086774708409456)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0711941 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       2770.4   2770.4      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         28.8     28.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        311.2    311.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         81.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.2      0.2      0.1              best_increase = np.inf
   126       317         40.5      0.1      0.1              best_position = None
   127     50720       7922.4      0.2     11.1              for i in range(len(path)):
   128     50403      11174.1      0.2     15.7                  next_i = (i + 1) % len(path)
   129     50403      36903.6      0.7     51.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9524.4      0.2     13.4                  if increase < best_increase:
   131      6948        960.2      0.1      1.3                      best_increase = increase
   132      6948       1051.3      0.2      1.5                      best_position = next_i
   133                                           
   134       317        102.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        121.4    121.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.110757694253274

[('lin318', 1.110757694253274)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0742629 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2787.7   2787.7      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         22.4     22.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        286.0    286.0      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         59.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.7      0.2      0.1              best_increase = np.inf
   126       317         39.1      0.1      0.1              best_position = None
   127     50720       8004.3      0.2     10.8              for i in range(len(path)):
   128     50403      11744.6      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      39186.1      0.8     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9703.8      0.2     13.1                  if increase < best_increase:
   131      6670        945.5      0.1      1.3                      best_increase = increase
   132      6670       1027.8      0.2      1.4                      best_position = next_i
   133                                           
   134       317        103.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        124.8    124.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1091520760481093

[('lin318', 1.1091520760481093)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0709642 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2813.7   2813.7      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.4     26.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        319.2    319.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.6      0.2      0.1              best_increase = np.inf
   126       317         40.6      0.1      0.1              best_position = None
   127     50720       7211.9      0.1     10.2              for i in range(len(path)):
   128     50403      11424.9      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      37312.9      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9400.8      0.2     13.2                  if increase < best_increase:
   131      6805        928.1      0.1      1.3                      best_increase = increase
   132      6805        983.9      0.1      1.4                      best_position = next_i
   133                                           
   134       317         91.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         79.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        123.9    123.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1203270013375946

[('lin318', 1.1203270013375946)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0698273 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2856.3   2856.3      4.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         22.9     22.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        316.2    316.2      0.5          random.shuffle(notInPath)
   119                                           
   120       318         81.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         65.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         56.6      0.2      0.1              best_increase = np.inf
   126       317         36.5      0.1      0.1              best_position = None
   127     50720       7624.1      0.2     10.9              for i in range(len(path)):
   128     50403      11157.5      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      36922.5      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8960.1      0.2     12.8                  if increase < best_increase:
   131      5354        685.2      0.1      1.0                      best_increase = increase
   132      5354        724.6      0.1      1.0                      best_position = next_i
   133                                           
   134       317         89.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        142.7    142.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.10748700745332

[('lin318', 1.10748700745332)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0708595 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2866.9   2866.9      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         26.1     26.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        316.5    316.5      0.4          random.shuffle(notInPath)
   119                                           
   120       318         86.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.6      0.2      0.1              best_increase = np.inf
   126       317         36.6      0.1      0.1              best_position = None
   127     50720       8028.7      0.2     11.3              for i in range(len(path)):
   128     50403      11471.3      0.2     16.2                  next_i = (i + 1) % len(path)
   129     50403      37516.0      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8873.4      0.2     12.5                  if increase < best_increase:
   131      4393        603.2      0.1      0.9                      best_increase = increase
   132      4393        593.6      0.1      0.8                      best_position = next_i
   133                                           
   134       317        108.3      0.3      0.2              path.insert(best_position, to_insert)
   135       317         82.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        126.4    126.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.154237163667139

[('lin318', 1.154237163667139)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0721107 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       3102.6   3102.6      4.3          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         28.2     28.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        322.9    322.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         91.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         80.7      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.3      0.2      0.1              best_increase = np.inf
   126       317         41.6      0.1      0.1              best_position = None
   127     50720       7738.2      0.2     10.7              for i in range(len(path)):
   128     50403      11383.9      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      37202.3      0.7     51.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10218.7      0.2     14.2                  if increase < best_increase:
   131      5183        713.9      0.1      1.0                      best_increase = increase
   132      5183        774.4      0.1      1.1                      best_position = next_i
   133                                           
   134       317        102.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         84.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        160.8    160.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1118451193057675

[('lin318', 1.1118451193057675)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0706608 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2817.3   2817.3      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         27.4     27.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        314.9    314.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         98.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         55.8      0.2      0.1              best_increase = np.inf
   126       317         39.4      0.1      0.1              best_position = None
   127     50720       7903.1      0.2     11.2              for i in range(len(path)):
   128     50403      11203.3      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      36882.9      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9454.6      0.2     13.4                  if increase < best_increase:
   131      5323        711.3      0.1      1.0                      best_increase = increase
   132      5323        791.0      0.1      1.1                      best_position = next_i
   133                                           
   134       317         90.8      0.3      0.1              path.insert(best_position, to_insert)
   135       317         84.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        121.8    121.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0875768698046364

[('lin318', 1.0875768698046364)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.072471 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2766.7   2766.7      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         22.9     22.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        317.9    317.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         67.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.2      0.2      0.1              best_increase = np.inf
   126       317         36.1      0.1      0.0              best_position = None
   127     50720       7793.0      0.2     10.8              for i in range(len(path)):
   128     50403      11497.3      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      39151.3      0.8     54.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9191.0      0.2     12.7                  if increase < best_increase:
   131      4396        571.3      0.1      0.8                      best_increase = increase
   132      4396        602.5      0.1      0.8                      best_position = next_i
   133                                           
   134       317         95.5      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        132.0    132.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1194537387213017

[('lin318', 1.1194537387213017)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.071153 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2810.1   2810.1      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         24.4     24.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        299.2    299.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         85.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         60.8      0.2      0.1              best_increase = np.inf
   126       317         41.2      0.1      0.1              best_position = None
   127     50720       7944.9      0.2     11.2              for i in range(len(path)):
   128     50403      11266.6      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      37213.6      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9227.6      0.2     13.0                  if increase < best_increase:
   131      6367        885.5      0.1      1.2                      best_increase = increase
   132      6367        916.5      0.1      1.3                      best_position = next_i
   133                                           
   134       317         94.4      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        134.8    134.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1142971718699408

[('lin318', 1.1142971718699408)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0716927 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       2848.0   2848.0      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         23.2     23.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        323.3    323.3      0.5          random.shuffle(notInPath)
   119                                           
   120       318         86.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.7      0.2      0.1              best_increase = np.inf
   126       317         41.9      0.1      0.1              best_position = None
   127     50720       7994.9      0.2     11.2              for i in range(len(path)):
   128     50403      12023.7      0.2     16.8                  next_i = (i + 1) % len(path)
   129     50403      37141.1      0.7     51.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9463.5      0.2     13.2                  if increase < best_increase:
   131      4558        636.5      0.1      0.9                      best_increase = increase
   132      4558        669.7      0.1      0.9                      best_position = next_i
   133                                           
   134       317         93.9      0.3      0.1              path.insert(best_position, to_insert)
   135       317         96.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        127.0    127.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.107178813335872

[('lin318', 1.107178813335872)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0716851 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2849.3   2849.3      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         23.2     23.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        337.4    337.4      0.5          random.shuffle(notInPath)
   119                                           
   120       318         83.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.7      0.2      0.1              best_increase = np.inf
   126       317         42.6      0.1      0.1              best_position = None
   127     50720       7492.4      0.1     10.5              for i in range(len(path)):
   128     50403      11634.1      0.2     16.2                  next_i = (i + 1) % len(path)
   129     50403      38046.4      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9300.7      0.2     13.0                  if increase < best_increase:
   131      4992        683.9      0.1      1.0                      best_increase = increase
   132      4992        757.9      0.2      1.1                      best_position = next_i
   133                                           
   134       317         98.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317         85.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        128.3    128.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0871463300091546

[('lin318', 1.0871463300091546)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0697538 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2843.0   2843.0      4.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         23.1     23.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        336.7    336.7      0.5          random.shuffle(notInPath)
   119                                           
   120       318         82.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.3      0.2      0.1              best_increase = np.inf
   126       317         42.9      0.1      0.1              best_position = None
   127     50720       7562.8      0.1     10.8              for i in range(len(path)):
   128     50403      10993.0      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      36565.5      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9478.4      0.2     13.6                  if increase < best_increase:
   131      4723        675.6      0.1      1.0                      best_increase = increase
   132      4723        713.2      0.2      1.0                      best_position = next_i
   133                                           
   134       317         91.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         79.0      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        139.9    139.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1269869886254018

[('lin318', 1.1269869886254018)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0724452 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2874.0   2874.0      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         23.3     23.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        338.1    338.1      0.5          random.shuffle(notInPath)
   119                                           
   120       318         81.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         62.9      0.2      0.1              best_increase = np.inf
   126       317         40.2      0.1      0.1              best_position = None
   127     50720       8781.4      0.2     12.1              for i in range(len(path)):
   128     50403      11712.0      0.2     16.2                  next_i = (i + 1) % len(path)
   129     50403      37287.5      0.7     51.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9507.9      0.2     13.1                  if increase < best_increase:
   131      4719        642.6      0.1      0.9                      best_increase = increase
   132      4719        718.0      0.2      1.0                      best_position = next_i
   133                                           
   134       317         93.9      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        133.8    133.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1297778264807006

[('lin318', 1.1297778264807006)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.070999 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2785.9   2785.9      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.7     26.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        304.5    304.5      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         65.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.2      0.2      0.1              best_increase = np.inf
   126       317         40.4      0.1      0.1              best_position = None
   127     50720       7348.7      0.1     10.4              for i in range(len(path)):
   128     50403      11650.2      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      37736.5      0.7     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9272.0      0.2     13.1                  if increase < best_increase:
   131      4807        629.6      0.1      0.9                      best_increase = increase
   132      4807        698.0      0.1      1.0                      best_position = next_i
   133                                           
   134       317         92.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        126.0    126.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1082251007610016

[('lin318', 1.1082251007610016)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0722795 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2836.7   2836.7      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         24.0     24.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        318.9    318.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318        101.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         61.2      0.2      0.1              best_increase = np.inf
   126       317         41.7      0.1      0.1              best_position = None
   127     50720       7547.8      0.1     10.4              for i in range(len(path)):
   128     50403      11200.1      0.2     15.5                  next_i = (i + 1) % len(path)
   129     50403      38342.1      0.8     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10086.6      0.2     14.0                  if increase < best_increase:
   131      4698        623.9      0.1      0.9                      best_increase = increase
   132      4698        704.3      0.1      1.0                      best_position = next_i
   133                                           
   134       317        109.6      0.3      0.2              path.insert(best_position, to_insert)
   135       317         83.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        131.2    131.2      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.111243368606956

[('lin318', 1.111243368606956)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0699445 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2763.5   2763.5      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.8     26.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        300.4    300.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         55.8      0.2      0.1              best_increase = np.inf
   126       317         36.3      0.1      0.1              best_position = None
   127     50720       7722.9      0.2     11.0              for i in range(len(path)):
   128     50403      11284.5      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      36599.6      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8986.7      0.2     12.8                  if increase < best_increase:
   131      6313        845.8      0.1      1.2                      best_increase = increase
   132      6313        868.1      0.1      1.2                      best_position = next_i
   133                                           
   134       317         92.4      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        129.5    129.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0799062510614834

[('lin318', 1.0799062510614834)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0699331 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2787.6   2787.6      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         25.3     25.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        312.4    312.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         79.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         59.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.8      0.2      0.1              best_increase = np.inf
   126       317         40.9      0.1      0.1              best_position = None
   127     50720       7853.9      0.2     11.2              for i in range(len(path)):
   128     50403      11092.0      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      36602.4      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9345.0      0.2     13.4                  if increase < best_increase:
   131      4812        623.5      0.1      0.9                      best_increase = increase
   132      4812        734.3      0.2      1.0                      best_position = next_i
   133                                           
   134       317         90.5      0.3      0.1              path.insert(best_position, to_insert)
   135       317        100.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        125.0    125.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0751846969051702

[('lin318', 1.0751846969051702)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0706018 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2771.1   2771.1      3.9          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.3      0.3      0.0          in_path = {0}
   117         1         25.5     25.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        312.9    312.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318         85.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         54.8      0.2      0.1              best_increase = np.inf
   126       317         40.6      0.1      0.1              best_position = None
   127     50720       7724.6      0.2     10.9              for i in range(len(path)):
   128     50403      11362.5      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      36828.2      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9265.0      0.2     13.1                  if increase < best_increase:
   131      6070        850.2      0.1      1.2                      best_increase = increase
   132      6070        912.8      0.2      1.3                      best_position = next_i
   133                                           
   134       317         92.9      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        130.4    130.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1093007145192273

[('lin318', 1.1093007145192273)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0723341 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2719.9   2719.9      3.8          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.3     26.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        316.8    316.8      0.4          random.shuffle(notInPath)
   119                                           
   120       318         84.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         63.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.6      0.2      0.1              best_increase = np.inf
   126       317         39.3      0.1      0.1              best_position = None
   127     50720       7962.9      0.2     11.0              for i in range(len(path)):
   128     50403      11475.9      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      37922.6      0.8     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9806.4      0.2     13.6                  if increase < best_increase:
   131      5467        719.5      0.1      1.0                      best_increase = increase
   132      5467        801.3      0.1      1.1                      best_position = next_i
   133                                           
   134       317         94.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        154.9    154.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0947208216521616

[('lin318', 1.0947208216521616)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0707119 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2759.3   2759.3      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         22.2     22.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        312.8    312.8      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         72.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.6      0.2      0.1              best_increase = np.inf
   126       317         39.4      0.1      0.1              best_position = None
   127     50720       7627.0      0.2     10.8              for i in range(len(path)):
   128     50403      11259.9      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      36822.5      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9623.8      0.2     13.6                  if increase < best_increase:
   131      6020        844.8      0.1      1.2                      best_increase = increase
   132      6020        877.2      0.1      1.2                      best_position = next_i
   133                                           
   134       317         96.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        128.6    128.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0940827422807622

[('lin318', 1.0940827422807622)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0699186 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2761.1   2761.1      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         26.8     26.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        310.3    310.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         61.8      0.2      0.1              best_increase = np.inf
   126       317         39.7      0.1      0.1              best_position = None
   127     50720       7019.9      0.1     10.0              for i in range(len(path)):
   128     50403      11511.7      0.2     16.5                  next_i = (i + 1) % len(path)
   129     50403      36982.2      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9296.1      0.2     13.3                  if increase < best_increase:
   131      5155        691.9      0.1      1.0                      best_increase = increase
   132      5155        763.5      0.1      1.1                      best_position = next_i
   133                                           
   134       317        100.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        125.1    125.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1009512647523267

[('lin318', 1.1009512647523267)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0705805 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2733.1   2733.1      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         22.4     22.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        317.0    317.0      0.4          random.shuffle(notInPath)
   119                                           
   120       318         83.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         71.4      0.2      0.1              best_increase = np.inf
   126       317         37.4      0.1      0.1              best_position = None
   127     50720       7818.4      0.2     11.1              for i in range(len(path)):
   128     50403      11354.6      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      37249.6      0.7     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8824.6      0.2     12.5                  if increase < best_increase:
   131      6196        830.8      0.1      1.2                      best_increase = increase
   132      6196        832.0      0.1      1.2                      best_position = next_i
   133                                           
   134       317         91.9      0.3      0.1              path.insert(best_position, to_insert)
   135       317         91.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        157.0    157.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1088859307470227

[('lin318', 1.1088859307470227)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0706894 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2778.2   2778.2      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.1      1.1      0.0          in_path = {0}
   117         1         22.9     22.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        328.1    328.1      0.5          random.shuffle(notInPath)
   119                                           
   120       318         83.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         58.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         72.0      0.2      0.1              best_increase = np.inf
   126       317         39.4      0.1      0.1              best_position = None
   127     50720       7497.2      0.1     10.6              for i in range(len(path)):
   128     50403      11101.7      0.2     15.7                  next_i = (i + 1) % len(path)
   129     50403      36800.2      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9690.4      0.2     13.7                  if increase < best_increase:
   131      6762        890.2      0.1      1.3                      best_increase = increase
   132      6762       1020.8      0.2      1.4                      best_position = next_i
   133                                           
   134       317         95.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        127.3    127.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0952007306303604

[('lin318', 1.0952007306303604)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0714611 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2798.0   2798.0      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         27.8     27.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        305.2    305.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         81.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         72.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.1      0.2      0.1              best_increase = np.inf
   126       317         39.7      0.1      0.1              best_position = None
   127     50720       8149.1      0.2     11.4              for i in range(len(path)):
   128     50403      11738.9      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      37216.8      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9362.2      0.2     13.1                  if increase < best_increase:
   131      4536        615.4      0.1      0.9                      best_increase = increase
   132      4536        679.8      0.1      1.0                      best_position = next_i
   133                                           
   134       317        103.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.7      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        127.8    127.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1134887817094083

[('lin318', 1.1134887817094083)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0704775 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2813.8   2813.8      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.5     26.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        325.9    325.9      0.5          random.shuffle(notInPath)
   119                                           
   120       318         96.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.9      0.2      0.1              best_increase = np.inf
   126       317         41.2      0.1      0.1              best_position = None
   127     50720       7870.3      0.2     11.2              for i in range(len(path)):
   128     50403      11539.1      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      36696.9      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9234.7      0.2     13.1                  if increase < best_increase:
   131      4930        653.5      0.1      0.9                      best_increase = increase
   132      4930        745.4      0.2      1.1                      best_position = next_i
   133                                           
   134       317         98.3      0.3      0.1              path.insert(best_position, to_insert)
   135       317         85.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        126.1    126.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.140621901815944

[('lin318', 1.140621901815944)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0704827 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2754.7   2754.7      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         22.3     22.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        302.4    302.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         79.2      0.2      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         59.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         51.9      0.2      0.1              best_increase = np.inf
   126       317         51.2      0.2      0.1              best_position = None
   127     50720       7531.4      0.1     10.7              for i in range(len(path)):
   128     50403      11070.8      0.2     15.7                  next_i = (i + 1) % len(path)
   129     50403      36997.6      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9286.0      0.2     13.2                  if increase < best_increase:
   131      6849        962.0      0.1      1.4                      best_increase = increase
   132      6849        998.6      0.1      1.4                      best_position = next_i
   133                                           
   134       317        104.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        126.7    126.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.108433777545254

[('lin318', 1.108433777545254)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0725262 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2732.1   2732.1      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         25.2     25.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        303.1    303.1      0.4          random.shuffle(notInPath)
   119                                           
   120       318         81.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.6      0.2      0.1              best_increase = np.inf
   126       317         36.2      0.1      0.0              best_position = None
   127     50720       7784.0      0.2     10.7              for i in range(len(path)):
   128     50403      11517.7      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      38847.4      0.8     53.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9202.8      0.2     12.7                  if increase < best_increase:
   131      5579        750.6      0.1      1.0                      best_increase = increase
   132      5579        798.8      0.1      1.1                      best_position = next_i
   133                                           
   134       317        112.8      0.4      0.2              path.insert(best_position, to_insert)
   135       317         81.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        130.9    130.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1187253394309447

[('lin318', 1.1187253394309447)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.072015 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.3      1.3      0.0          n = self.numCity
   114         1       2748.8   2748.8      3.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.1      1.1      0.0          in_path = {0}
   117         1         27.5     27.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        381.6    381.6      0.5          random.shuffle(notInPath)
   119                                           
   120       318         81.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         56.9      0.2      0.1              best_increase = np.inf
   126       317         39.9      0.1      0.1              best_position = None
   127     50720       8721.3      0.2     12.1              for i in range(len(path)):
   128     50403      11203.5      0.2     15.6                  next_i = (i + 1) % len(path)
   129     50403      37252.7      0.7     51.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9233.0      0.2     12.8                  if increase < best_increase:
   131      6587        910.2      0.1      1.3                      best_increase = increase
   132      6587        986.4      0.1      1.4                      best_position = next_i
   133                                           
   134       317         93.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        133.0    133.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.090334263551855

[('lin318', 1.090334263551855)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0708859 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2744.3   2744.3      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         25.9     25.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        348.4    348.4      0.5          random.shuffle(notInPath)
   119                                           
   120       318         96.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.4      0.2      0.1              best_increase = np.inf
   126       317         38.0      0.1      0.1              best_position = None
   127     50720       7637.4      0.2     10.8              for i in range(len(path)):
   128     50403      11505.3      0.2     16.2                  next_i = (i + 1) % len(path)
   129     50403      37144.5      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9327.8      0.2     13.2                  if increase < best_increase:
   131      5669        752.5      0.1      1.1                      best_increase = increase
   132      5669        839.8      0.1      1.2                      best_position = next_i
   133                                           
   134       317         95.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        128.7    128.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1072791352377875

[('lin318', 1.1072791352377875)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0710087 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2747.7   2747.7      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.1     26.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        310.1    310.1      0.4          random.shuffle(notInPath)
   119                                           
   120       318         84.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         56.9      0.2      0.1              best_increase = np.inf
   126       317         40.0      0.1      0.1              best_position = None
   127     50720       7378.4      0.1     10.4              for i in range(len(path)):
   128     50403      11735.6      0.2     16.5                  next_i = (i + 1) % len(path)
   129     50403      37366.6      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9415.1      0.2     13.3                  if increase < best_increase:
   131      5255        707.0      0.1      1.0                      best_increase = increase
   132      5255        772.6      0.1      1.1                      best_position = next_i
   133                                           
   134       317         94.2      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        128.0    128.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1128499713488396

[('lin318', 1.1128499713488396)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0702675 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2756.2   2756.2      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         25.5     25.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        324.6    324.6      0.5          random.shuffle(notInPath)
   119                                           
   120       318         81.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         71.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.3      0.2      0.1              best_increase = np.inf
   126       317         40.2      0.1      0.1              best_position = None
   127     50720       7668.4      0.2     10.9              for i in range(len(path)):
   128     50403      11185.5      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      37000.8      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9503.4      0.2     13.5                  if increase < best_increase:
   131      4437        627.8      0.1      0.9                      best_increase = increase
   132      4437        620.1      0.1      0.9                      best_position = next_i
   133                                           
   134       317         93.3      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        125.3    125.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1114421846548639

[('lin318', 1.1114421846548639)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0706043 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2792.9   2792.9      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         22.3     22.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        316.3    316.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         83.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         59.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         55.5      0.2      0.1              best_increase = np.inf
   126       317         35.6      0.1      0.1              best_position = None
   127     50720       7650.7      0.2     10.8              for i in range(len(path)):
   128     50403      11682.6      0.2     16.5                  next_i = (i + 1) % len(path)
   129     50403      37425.9      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8924.7      0.2     12.6                  if increase < best_increase:
   131      4545        623.7      0.1      0.9                      best_increase = increase
   132      4545        628.2      0.1      0.9                      best_position = next_i
   133                                           
   134       317         92.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        125.5    125.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1205580773361676

[('lin318', 1.1205580773361676)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.07339 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2753.0   2753.0      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         26.8     26.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        311.9    311.9      0.4          random.shuffle(notInPath)
   119                                           
   120       318        115.7      0.4      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         79.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         63.8      0.2      0.1              best_increase = np.inf
   126       317         42.9      0.1      0.1              best_position = None
   127     50720       7859.2      0.2     10.7              for i in range(len(path)):
   128     50403      11605.4      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      38745.1      0.8     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9752.1      0.2     13.3                  if increase < best_increase:
   131      5647        798.2      0.1      1.1                      best_increase = increase
   132      5647        861.8      0.2      1.2                      best_position = next_i
   133                                           
   134       317        103.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         90.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        177.7    177.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1097564610192632

[('lin318', 1.1097564610192632)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0704022 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2774.9   2774.9      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.0     26.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        310.7    310.7      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         63.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.5      0.2      0.1              best_increase = np.inf
   126       317         38.7      0.1      0.1              best_position = None
   127     50720       7665.6      0.2     10.9              for i in range(len(path)):
   128     50403      11134.9      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      37279.2      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9221.6      0.2     13.1                  if increase < best_increase:
   131      5056        720.5      0.1      1.0                      best_increase = increase
   132      5056        731.0      0.1      1.0                      best_position = next_i
   133                                           
   134       317         91.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        121.0    121.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1116199604439374

[('lin318', 1.1116199604439374)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0732079 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2846.2   2846.2      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         25.4     25.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        321.1    321.1      0.4          random.shuffle(notInPath)
   119                                           
   120       318         83.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         65.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.6      0.2      0.1              best_increase = np.inf
   126       317         42.5      0.1      0.1              best_position = None
   127     50720       7217.7      0.1      9.9              for i in range(len(path)):
   128     50403      11678.3      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      38696.7      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10168.3      0.2     13.9                  if increase < best_increase:
   131      5671        820.2      0.1      1.1                      best_increase = increase
   132      5671        883.4      0.2      1.2                      best_position = next_i
   133                                           
   134       317         92.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        123.6    123.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0981152292361647

[('lin318', 1.0981152292361647)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0703196 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2902.2   2902.2      4.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         25.5     25.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        310.8    310.8      0.4          random.shuffle(notInPath)
   119                                           
   120       318         81.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         59.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         61.1      0.2      0.1              best_increase = np.inf
   126       317         36.7      0.1      0.1              best_position = None
   127     50720       7824.1      0.2     11.1              for i in range(len(path)):
   128     50403      11563.9      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      36684.1      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8869.6      0.2     12.6                  if increase < best_increase:
   131      6135        771.3      0.1      1.1                      best_increase = increase
   132      6135        837.9      0.1      1.2                      best_position = next_i
   133                                           
   134       317         89.9      0.3      0.1              path.insert(best_position, to_insert)
   135       317         79.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        119.4    119.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1023816394587849

[('lin318', 1.1023816394587849)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0746053 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2775.7   2775.7      3.7          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         25.6     25.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        311.5    311.5      0.4          random.shuffle(notInPath)
   119                                           
   120       318         85.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.8      0.2      0.1              best_increase = np.inf
   126       317         42.5      0.1      0.1              best_position = None
   127     50720       7757.5      0.2     10.4              for i in range(len(path)):
   128     50403      12030.4      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      39773.7      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9797.8      0.2     13.1                  if increase < best_increase:
   131      5244        729.4      0.1      1.0                      best_increase = increase
   132      5244        843.4      0.2      1.1                      best_position = next_i
   133                                           
   134       317         97.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         86.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        126.5    126.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0877108428662046

[('lin318', 1.0877108428662046)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0736141 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2776.0   2776.0      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         22.3     22.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        311.2    311.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         85.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         63.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         76.8      0.2      0.1              best_increase = np.inf
   126       317         42.5      0.1      0.1              best_position = None
   127     50720       8287.2      0.2     11.3              for i in range(len(path)):
   128     50403      12171.2      0.2     16.5                  next_i = (i + 1) % len(path)
   129     50403      37593.5      0.7     51.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      10301.8      0.2     14.0                  if increase < best_increase:
   131      5331        735.0      0.1      1.0                      best_increase = increase
   132      5331        825.0      0.2      1.1                      best_position = next_i
   133                                           
   134       317         94.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317        100.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        124.8    124.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1296286665159534

[('lin318', 1.1296286665159534)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0695233 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2810.5   2810.5      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         27.0     27.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        311.7    311.7      0.4          random.shuffle(notInPath)
   119                                           
   120       318         80.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.2      0.2      0.1              best_increase = np.inf
   126       317         40.2      0.1      0.1              best_position = None
   127     50720       7538.2      0.1     10.8              for i in range(len(path)):
   128     50403      10675.3      0.2     15.4                  next_i = (i + 1) % len(path)
   129     50403      36350.8      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9679.8      0.2     13.9                  if increase < best_increase:
   131      5728        735.9      0.1      1.1                      best_increase = increase
   132      5728        848.8      0.1      1.2                      best_position = next_i
   133                                           
   134       317         94.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        125.9    125.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1301546074709472

[('lin318', 1.1301546074709472)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0700826 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2892.8   2892.8      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         23.1     23.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        310.3    310.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         80.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         58.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.4      0.2      0.1              best_increase = np.inf
   126       317         39.1      0.1      0.1              best_position = None
   127     50720       7869.1      0.2     11.2              for i in range(len(path)):
   128     50403      11203.1      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      36689.8      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9182.1      0.2     13.1                  if increase < best_increase:
   131      4919        680.9      0.1      1.0                      best_increase = increase
   132      4919        689.3      0.1      1.0                      best_position = next_i
   133                                           
   134       317         90.8      0.3      0.1              path.insert(best_position, to_insert)
   135       317         84.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        128.2    128.2      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1064743777516497

[('lin318', 1.1064743777516497)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0740985 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2807.3   2807.3      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         22.6     22.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        308.1    308.1      0.4          random.shuffle(notInPath)
   119                                           
   120       318         83.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         64.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.2      0.2      0.1              best_increase = np.inf
   126       317         40.3      0.1      0.1              best_position = None
   127     50720       7674.0      0.2     10.4              for i in range(len(path)):
   128     50403      11712.0      0.2     15.8                  next_i = (i + 1) % len(path)
   129     50403      39659.9      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9971.7      0.2     13.5                  if increase < best_increase:
   131      4785        667.4      0.1      0.9                      best_increase = increase
   132      4785        710.5      0.1      1.0                      best_position = next_i
   133                                           
   134       317         95.3      0.3      0.1              path.insert(best_position, to_insert)
   135       317         86.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        134.3    134.3      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1071071666005183

[('lin318', 1.1071071666005183)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0708563 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2903.1   2903.1      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         25.6     25.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        318.2    318.2      0.4          random.shuffle(notInPath)
   119                                           
   120       318         80.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         76.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         55.8      0.2      0.1              best_increase = np.inf
   126       317         40.9      0.1      0.1              best_position = None
   127     50720       6894.7      0.1      9.7              for i in range(len(path)):
   128     50403      11320.7      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      37624.7      0.7     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9578.0      0.2     13.5                  if increase < best_increase:
   131      5669        777.0      0.1      1.1                      best_increase = increase
   132      5669        852.7      0.2      1.2                      best_position = next_i
   133                                           
   134       317         92.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        131.4    131.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0931886642135633

[('lin318', 1.0931886642135633)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0725024 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2821.9   2821.9      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         23.4     23.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        320.4    320.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.0      0.2      0.1              best_increase = np.inf
   126       317         41.8      0.1      0.1              best_position = None
   127     50720       8446.5      0.2     11.7              for i in range(len(path)):
   128     50403      11776.1      0.2     16.2                  next_i = (i + 1) % len(path)
   129     50403      37333.8      0.7     51.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9596.4      0.2     13.2                  if increase < best_increase:
   131      5310        740.5      0.1      1.0                      best_increase = increase
   132      5310        870.2      0.2      1.2                      best_position = next_i
   133                                           
   134       317         94.5      0.3      0.1              path.insert(best_position, to_insert)
   135       317         82.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        150.7    150.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0947849306201622

[('lin318', 1.0947849306201622)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0694018 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       3050.8   3050.8      4.4          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         26.3     26.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        316.8    316.8      0.5          random.shuffle(notInPath)
   119                                           
   120       318         81.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         84.4      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.5      0.2      0.1              best_increase = np.inf
   126       317         39.2      0.1      0.1              best_position = None
   127     50720       6947.8      0.1     10.0              for i in range(len(path)):
   128     50403      11066.6      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      36863.9      0.7     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9222.5      0.2     13.3                  if increase < best_increase:
   131      4819        632.8      0.1      0.9                      best_increase = increase
   132      4819        705.3      0.1      1.0                      best_position = next_i
   133                                           
   134       317         91.0      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        127.6    127.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1178802782454287

[('lin318', 1.1178802782454287)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0708852 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2782.9   2782.9      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         27.4     27.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        324.5    324.5      0.5          random.shuffle(notInPath)
   119                                           
   120       318         81.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.3      0.2      0.1              best_increase = np.inf
   126       317         40.3      0.1      0.1              best_position = None
   127     50720       7586.9      0.1     10.7              for i in range(len(path)):
   128     50403      10848.2      0.2     15.3                  next_i = (i + 1) % len(path)
   129     50403      37316.5      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9504.1      0.2     13.4                  if increase < best_increase:
   131      6449        912.6      0.1      1.3                      best_increase = increase
   132      6449       1034.0      0.2      1.5                      best_position = next_i
   133                                           
   134       317         91.2      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        132.5    132.5      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0831951515736702

[('lin318', 1.0831951515736702)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0713871 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       2879.8   2879.8      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         27.8     27.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        325.9    325.9      0.5          random.shuffle(notInPath)
   119                                           
   120       318         97.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         60.1      0.2      0.1              best_increase = np.inf
   126       317         40.7      0.1      0.1              best_position = None
   127     50720       8129.5      0.2     11.4              for i in range(len(path)):
   128     50403      11211.2      0.2     15.7                  next_i = (i + 1) % len(path)
   129     50403      36980.4      0.7     51.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9217.2      0.2     12.9                  if increase < best_increase:
   131      7172        991.6      0.1      1.4                      best_increase = increase
   132      7172       1049.7      0.1      1.5                      best_position = next_i
   133                                           
   134       317        100.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        128.6    128.6      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0831089508469993

[('lin318', 1.0831089508469993)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0704877 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2859.2   2859.2      4.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         28.0     28.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        334.9    334.9      0.5          random.shuffle(notInPath)
   119                                           
   120       318         82.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.5      0.2      0.1              best_increase = np.inf
   126       317         41.6      0.1      0.1              best_position = None
   127     50720       7806.5      0.2     11.1              for i in range(len(path)):
   128     50403      11486.2      0.2     16.3                  next_i = (i + 1) % len(path)
   129     50403      36389.2      0.7     51.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9265.7      0.2     13.1                  if increase < best_increase:
   131      6414        827.4      0.1      1.2                      best_increase = increase
   132      6414        931.9      0.1      1.3                      best_position = next_i
   133                                           
   134       317        106.4      0.3      0.2              path.insert(best_position, to_insert)
   135       317         82.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.4      1.4      0.0          self.tour = path
   138         1        122.8    122.8      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1174657265105181

[('lin318', 1.1174657265105181)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0700199 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2864.8   2864.8      4.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         26.8     26.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        310.7    310.7      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         61.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         55.3      0.2      0.1              best_increase = np.inf
   126       317         39.9      0.1      0.1              best_position = None
   127     50720       7397.6      0.1     10.6              for i in range(len(path)):
   128     50403      11389.4      0.2     16.3                  next_i = (i + 1) % len(path)
   129     50403      36563.7      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9528.2      0.2     13.6                  if increase < best_increase:
   131      4943        663.9      0.1      0.9                      best_increase = increase
   132      4943        737.4      0.1      1.1                      best_position = next_i
   133                                           
   134       317         90.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        123.1    123.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1352625207984004

[('lin318', 1.1352625207984004)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.071967 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2896.4   2896.4      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         24.0     24.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        318.7    318.7      0.4          random.shuffle(notInPath)
   119                                           
   120       318         81.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         62.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         56.0      0.2      0.1              best_increase = np.inf
   126       317         37.3      0.1      0.1              best_position = None
   127     50720       7993.1      0.2     11.1              for i in range(len(path)):
   128     50403      11551.7      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      38371.6      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9116.9      0.2     12.7                  if increase < best_increase:
   131      4216        562.5      0.1      0.8                      best_increase = increase
   132      4216        592.8      0.1      0.8                      best_position = next_i
   133                                           
   134       317         94.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317         81.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        123.7    123.7      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1002634647985798

[('lin318', 1.1002634647985798)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0719533 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2847.7   2847.7      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         27.2     27.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        354.9    354.9      0.5          random.shuffle(notInPath)
   119                                           
   120       318         85.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         67.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         59.0      0.2      0.1              best_increase = np.inf
   126       317         41.8      0.1      0.1              best_position = None
   127     50720       7741.8      0.2     10.8              for i in range(len(path)):
   128     50403      11822.5      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      37260.7      0.7     51.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9575.9      0.2     13.3                  if increase < best_increase:
   131      6030        838.3      0.1      1.2                      best_increase = increase
   132      6030        911.5      0.2      1.3                      best_position = next_i
   133                                           
   134       317        101.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317         88.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        127.0    127.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.086482806022781

[('lin318', 1.086482806022781)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0701211 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2745.5   2745.5      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         25.2     25.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        311.0    311.0      0.4          random.shuffle(notInPath)
   119                                           
   120       318         84.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         58.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         57.7      0.2      0.1              best_increase = np.inf
   126       317         41.5      0.1      0.1              best_position = None
   127     50720       7839.4      0.2     11.2              for i in range(len(path)):
   128     50403      10897.2      0.2     15.5                  next_i = (i + 1) % len(path)
   129     50403      36545.5      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9314.1      0.2     13.3                  if increase < best_increase:
   131      6625        910.8      0.1      1.3                      best_increase = increase
   132      6625       1000.2      0.2      1.4                      best_position = next_i
   133                                           
   134       317         89.1      0.3      0.1              path.insert(best_position, to_insert)
   135       317         77.0      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        121.0    121.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1296128081892596

[('lin318', 1.1296128081892596)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.071423 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2758.5   2758.5      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         22.7     22.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        314.4    314.4      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         59.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.6      0.2      0.1              best_increase = np.inf
   126       317         40.8      0.1      0.1              best_position = None
   127     50720       7303.6      0.1     10.2              for i in range(len(path)):
   128     50403      11725.5      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      37729.9      0.7     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9733.2      0.2     13.6                  if increase < best_increase:
   131      4468        610.2      0.1      0.9                      best_increase = increase
   132      4468        670.2      0.1      0.9                      best_position = next_i
   133                                           
   134       317         98.9      0.3      0.1              path.insert(best_position, to_insert)
   135       317         83.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.0      1.0      0.0          self.tour = path
   138         1        128.9    128.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1401469950114838

[('lin318', 1.1401469950114838)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0708513 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2706.8   2706.8      3.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         36.4     36.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        334.3    334.3      0.5          random.shuffle(notInPath)
   119                                           
   120       318         83.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         55.8      0.2      0.1              best_increase = np.inf
   126       317         40.8      0.1      0.1              best_position = None
   127     50720       7618.2      0.2     10.8              for i in range(len(path)):
   128     50403      11392.0      0.2     16.1                  next_i = (i + 1) % len(path)
   129     50403      37164.3      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9185.8      0.2     13.0                  if increase < best_increase:
   131      6566        904.3      0.1      1.3                      best_increase = increase
   132      6566        960.7      0.1      1.4                      best_position = next_i
   133                                           
   134       317         87.7      0.3      0.1              path.insert(best_position, to_insert)
   135       317         80.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        138.0    138.0      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1121913734165816

[('lin318', 1.1121913734165816)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0705184 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2761.8   2761.8      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         22.4     22.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        304.3    304.3      0.4          random.shuffle(notInPath)
   119                                           
   120       318         84.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         58.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.8      0.2      0.1              best_increase = np.inf
   126       317         36.1      0.1      0.1              best_position = None
   127     50720       7720.1      0.2     10.9              for i in range(len(path)):
   128     50403      11555.5      0.2     16.4                  next_i = (i + 1) % len(path)
   129     50403      37394.8      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       8808.9      0.2     12.5                  if increase < best_increase:
   131      5308        712.0      0.1      1.0                      best_increase = increase
   132      5308        702.5      0.1      1.0                      best_position = next_i
   133                                           
   134       317         96.2      0.3      0.1              path.insert(best_position, to_insert)
   135       317         78.2      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.1      1.1      0.0          self.tour = path
   138         1        120.9    120.9      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1281584025538638

[('lin318', 1.1281584025538638)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0704563 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2749.1   2749.1      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.3      0.3      0.0          in_path = {0}
   117         1         26.6     26.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        331.4    331.4      0.5          random.shuffle(notInPath)
   119                                           
   120       318         81.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         72.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         55.8      0.2      0.1              best_increase = np.inf
   126       317         38.6      0.1      0.1              best_position = None
   127     50720       7656.3      0.2     10.9              for i in range(len(path)):
   128     50403      11258.1      0.2     16.0                  next_i = (i + 1) % len(path)
   129     50403      37277.7      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9199.0      0.2     13.1                  if increase < best_increase:
   131      4893        682.9      0.1      1.0                      best_increase = increase
   132      4893        693.0      0.1      1.0                      best_position = next_i
   133                                           
   134       317         91.5      0.3      0.1              path.insert(best_position, to_insert)
   135       317         89.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        149.4    149.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1137437965086063

[('lin318', 1.1137437965086063)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0796014 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       3477.3   3477.3      4.4          distances = np.array(self.adj)
   115         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.1      1.1      0.0          in_path = {0}
   117         1         31.5     31.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        361.7    361.7      0.5          random.shuffle(notInPath)
   119                                           
   120       318         91.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         74.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         70.0      0.2      0.1              best_increase = np.inf
   126       317         50.3      0.2      0.1              best_position = None
   127     50720       8838.7      0.2     11.1              for i in range(len(path)):
   128     50403      12203.2      0.2     15.3                  next_i = (i + 1) % len(path)
   129     50403      41118.8      0.8     51.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403      11173.3      0.2     14.0                  if increase < best_increase:
   131      5095        820.2      0.2      1.0                      best_increase = increase
   132      5095        888.4      0.2      1.1                      best_position = next_i
   133                                           
   134       317        110.2      0.3      0.1              path.insert(best_position, to_insert)
   135       317        103.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        183.4    183.4      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.1113738162918685

[('lin318', 1.1113738162918685)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.073336 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       2909.1   2909.1      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         28.1     28.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        328.1    328.1      0.4          random.shuffle(notInPath)
   119                                           
   120       318         82.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         69.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         61.8      0.2      0.1              best_increase = np.inf
   126       317         42.5      0.1      0.1              best_position = None
   127     50720       8277.5      0.2     11.3              for i in range(len(path)):
   128     50403      11666.8      0.2     15.9                  next_i = (i + 1) % len(path)
   129     50403      38186.2      0.8     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9781.6      0.2     13.3                  if increase < best_increase:
   131      5393        740.6      0.1      1.0                      best_increase = increase
   132      5393        819.3      0.2      1.1                      best_position = next_i
   133                                           
   134       317         96.8      0.3      0.1              path.insert(best_position, to_insert)
   135       317         88.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        153.1    153.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.123589810192639

[('lin318', 1.123589810192639)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0710195 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       2878.6   2878.6      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         26.7     26.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        331.9    331.9      0.5          random.shuffle(notInPath)
   119                                           
   120       318         82.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         60.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         74.9      0.2      0.1              best_increase = np.inf
   126       317         42.1      0.1      0.1              best_position = None
   127     50720       7424.6      0.1     10.5              for i in range(len(path)):
   128     50403      11837.8      0.2     16.7                  next_i = (i + 1) % len(path)
   129     50403      36952.6      0.7     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9620.1      0.2     13.5                  if increase < best_increase:
   131      4753        637.7      0.1      0.9                      best_increase = increase
   132      4753        725.3      0.2      1.0                      best_position = next_i
   133                                           
   134       317         96.6      0.3      0.1              path.insert(best_position, to_insert)
   135       317         85.7      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        139.1    139.1      0.2          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0990867228742134

[('lin318', 1.0990867228742134)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.0705388 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       2804.0   2804.0      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         23.1     23.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        337.8    337.8      0.5          random.shuffle(notInPath)
   119                                           
   120       318         82.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       317         63.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       317         58.3      0.2      0.1              best_increase = np.inf
   126       317         40.1      0.1      0.1              best_position = None
   127     50720       7650.7      0.2     10.8              for i in range(len(path)):
   128     50403      10899.4      0.2     15.5                  next_i = (i + 1) % len(path)
   129     50403      37020.9      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     50403       9535.5      0.2     13.5                  if increase < best_increase:
   131      5881        807.9      0.1      1.1                      best_increase = increase
   132      5881        896.0      0.2      1.3                      best_position = next_i
   133                                           
   134       317        107.0      0.3      0.2              path.insert(best_position, to_insert)
   135       317         82.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.2      1.2      0.0          self.tour = path
   138         1        127.2    127.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1283676507235605

[('fl417', 1.1283676507235605)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121878 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4881.7   4881.7      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.2      1.2      0.0          in_path = {0}
   117         1         35.7     35.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        386.7    386.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        126.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         76.4      0.2      0.1              best_increase = np.inf
   126       416         51.1      0.1      0.0              best_position = None
   127     87152      12951.4      0.1     10.6              for i in range(len(path)):
   128     86736      20487.3      0.2     16.8                  next_i = (i + 1) % len(path)
   129     86736      63866.9      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16290.4      0.2     13.4                  if increase < best_increase:
   131      7561       1045.4      0.1      0.9                      best_increase = increase
   132      7561       1160.0      0.2      1.0                      best_position = next_i
   133                                           
   134       416        128.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        108.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        196.5    196.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1072308546803684

[('fl417', 1.1072308546803684)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122851 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       4814.3   4814.3      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         35.0     35.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.7    407.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        108.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         83.1      0.2      0.1              best_increase = np.inf
   126       416         54.7      0.1      0.0              best_position = None
   127     87152      14095.6      0.2     11.5              for i in range(len(path)):
   128     86736      20501.4      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      64135.5      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16203.0      0.2     13.2                  if increase < best_increase:
   131      6478        858.2      0.1      0.7                      best_increase = increase
   132      6478       1000.0      0.2      0.8                      best_position = next_i
   133                                           
   134       416        134.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.4      2.4      0.0          self.tour = path
   138         1        227.1    227.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0884715354898644

[('fl417', 1.0884715354898644)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12144 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4806.5   4806.5      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         36.7     36.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        413.2    413.2      0.3          random.shuffle(notInPath)
   119                                           
   120       417        105.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.2      0.2      0.1              best_increase = np.inf
   126       416         55.8      0.1      0.0              best_position = None
   127     87152      12547.2      0.1     10.3              for i in range(len(path)):
   128     86736      21022.1      0.2     17.3                  next_i = (i + 1) % len(path)
   129     86736      63534.4      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16374.3      0.2     13.5                  if increase < best_increase:
   131      6672        905.4      0.1      0.7                      best_increase = increase
   132      6672       1012.6      0.2      0.8                      best_position = next_i
   133                                           
   134       416        161.4      0.4      0.1              path.insert(best_position, to_insert)
   135       416        110.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        190.8    190.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0881764686434798

[('fl417', 1.0881764686434798)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12924 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.6      1.6      0.0          n = self.numCity
   114         1       4739.6   4739.6      3.7          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         36.6     36.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        409.9    409.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        117.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         86.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         94.1      0.2      0.1              best_increase = np.inf
   126       416         57.5      0.1      0.0              best_position = None
   127     87152      14062.9      0.2     10.9              for i in range(len(path)):
   128     86736      22153.0      0.3     17.1                  next_i = (i + 1) % len(path)
   129     86736      67153.8      0.8     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17408.5      0.2     13.5                  if increase < best_increase:
   131      8192       1189.8      0.1      0.9                      best_increase = increase
   132      8192       1303.4      0.2      1.0                      best_position = next_i
   133                                           
   134       416        137.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        102.8      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.3      1.3      0.0          self.tour = path
   138         1        183.2    183.2      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0489345270879775

[('fl417', 1.0489345270879775)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.128913 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       5025.0   5025.0      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         34.9     34.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        399.3    399.3      0.3          random.shuffle(notInPath)
   119                                           
   120       417        119.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         91.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         90.1      0.2      0.1              best_increase = np.inf
   126       416         69.7      0.2      0.1              best_position = None
   127     87152      14412.7      0.2     11.2              for i in range(len(path)):
   128     86736      20902.9      0.2     16.2                  next_i = (i + 1) % len(path)
   129     86736      68534.0      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16449.9      0.2     12.8                  if increase < best_increase:
   131      7709       1064.8      0.1      0.8                      best_increase = increase
   132      7709       1212.1      0.2      0.9                      best_position = next_i
   133                                           
   134       416        149.6      0.4      0.1              path.insert(best_position, to_insert)
   135       416        128.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.6      2.6      0.0          self.tour = path
   138         1        224.1    224.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.055289052753818

[('fl417', 1.055289052753818)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.127384 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4790.8   4790.8      3.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         30.8     30.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        402.3    402.3      0.3          random.shuffle(notInPath)
   119                                           
   120       417        116.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         85.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.9      0.2      0.1              best_increase = np.inf
   126       416         54.8      0.1      0.0              best_position = None
   127     87152      13559.5      0.2     10.6              for i in range(len(path)):
   128     86736      20017.1      0.2     15.7                  next_i = (i + 1) % len(path)
   129     86736      69491.4      0.8     54.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16339.1      0.2     12.8                  if increase < best_increase:
   131      6747        935.0      0.1      0.7                      best_increase = increase
   132      6747       1033.9      0.2      0.8                      best_position = next_i
   133                                           
   134       416        125.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.9      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        217.1    217.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0865170736588923

[('fl417', 1.0865170736588923)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124443 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       5051.1   5051.1      4.1          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.7     35.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        383.5    383.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        113.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         82.7      0.2      0.1              best_increase = np.inf
   126       416         54.4      0.1      0.0              best_position = None
   127     87152      13922.7      0.2     11.2              for i in range(len(path)):
   128     86736      21283.5      0.2     17.1                  next_i = (i + 1) % len(path)
   129     86736      64908.3      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15924.1      0.2     12.8                  if increase < best_increase:
   131      7252       1017.7      0.1      0.8                      best_increase = increase
   132      7252       1134.4      0.2      0.9                      best_position = next_i
   133                                           
   134       416        130.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        206.2    206.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0446316426402393

[('fl417', 1.0446316426402393)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121383 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       5005.8   5005.8      4.1          distances = np.array(self.adj)
   115         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         34.9     34.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        404.0    404.0      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.7      0.2      0.1              best_increase = np.inf
   126       416         50.7      0.1      0.0              best_position = None
   127     87152      13468.4      0.2     11.1              for i in range(len(path)):
   128     86736      19486.0      0.2     16.1                  next_i = (i + 1) % len(path)
   129     86736      64207.6      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15934.8      0.2     13.1                  if increase < best_increase:
   131      7271        984.0      0.1      0.8                      best_increase = increase
   132      7271       1114.6      0.2      0.9                      best_position = next_i
   133                                           
   134       416        130.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        100.3      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        188.1    188.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.083381972676359

[('fl417', 1.083381972676359)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.130032 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4740.4   4740.4      3.6          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.4     31.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        403.8    403.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.2      0.2      0.1              best_increase = np.inf
   126       416         57.3      0.1      0.0              best_position = None
   127     87152      14183.9      0.2     10.9              for i in range(len(path)):
   128     86736      20564.0      0.2     15.8                  next_i = (i + 1) % len(path)
   129     86736      69632.6      0.8     53.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17316.6      0.2     13.3                  if increase < best_increase:
   131      7915       1129.5      0.1      0.9                      best_increase = increase
   132      7915       1212.8      0.2      0.9                      best_position = next_i
   133                                           
   134       416        132.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        120.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.5      2.5      0.0          self.tour = path
   138         1        226.5    226.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0413094843339044

[('fl417', 1.0413094843339044)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.128665 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4922.7   4922.7      3.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.0     31.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        474.3    474.3      0.4          random.shuffle(notInPath)
   119                                           
   120       417        108.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         92.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         89.2      0.2      0.1              best_increase = np.inf
   126       416         59.2      0.1      0.0              best_position = None
   127     87152      14660.9      0.2     11.4              for i in range(len(path)):
   128     86736      20354.8      0.2     15.8                  next_i = (i + 1) % len(path)
   129     86736      66783.4      0.8     51.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      18163.8      0.2     14.1                  if increase < best_increase:
   131      7567       1158.3      0.2      0.9                      best_increase = increase
   132      7567       1317.5      0.2      1.0                      best_position = next_i
   133                                           
   134       416        132.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.7      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        204.5    204.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.045474539874341

[('fl417', 1.045474539874341)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.127424 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4826.8   4826.8      3.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.2      1.2      0.0          in_path = {0}
   117         1         35.1     35.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        412.8    412.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        301.4      0.7      0.2          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416        274.1      0.7      0.2              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.9      0.2      0.1              best_increase = np.inf
   126       416         55.0      0.1      0.0              best_position = None
   127     87152      14794.0      0.2     11.6              for i in range(len(path)):
   128     86736      20579.3      0.2     16.2                  next_i = (i + 1) % len(path)
   129     86736      65981.4      0.8     51.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17029.0      0.2     13.4                  if increase < best_increase:
   131      8886       1253.7      0.1      1.0                      best_increase = increase
   132      8886       1372.0      0.2      1.1                      best_position = next_i
   133                                           
   134       416        126.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        109.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        189.0    189.0      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0790068236117463

[('fl417', 1.0790068236117463)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121869 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       4772.9   4772.9      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.2     31.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        415.7    415.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        108.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         97.6      0.2      0.1              best_increase = np.inf
   126       416         53.2      0.1      0.0              best_position = None
   127     87152      13491.7      0.2     11.1              for i in range(len(path)):
   128     86736      19483.1      0.2     16.0                  next_i = (i + 1) % len(path)
   129     86736      64324.3      0.7     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16256.3      0.2     13.3                  if increase < best_increase:
   131      7625       1081.6      0.1      0.9                      best_increase = increase
   132      7625       1167.8      0.2      1.0                      best_position = next_i
   133                                           
   134       416        168.1      0.4      0.1              path.insert(best_position, to_insert)
   135       416        119.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        214.3    214.3      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.044265789348854

[('fl417', 1.044265789348854)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.125287 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4745.2   4745.2      3.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         30.8     30.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        392.3    392.3      0.3          random.shuffle(notInPath)
   119                                           
   120       417        108.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416        100.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.7      0.2      0.1              best_increase = np.inf
   126       416         56.4      0.1      0.0              best_position = None
   127     87152      14245.1      0.2     11.4              for i in range(len(path)):
   128     86736      19218.6      0.2     15.3                  next_i = (i + 1) % len(path)
   129     86736      66833.6      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16846.7      0.2     13.4                  if increase < best_increase:
   131      7504       1002.1      0.1      0.8                      best_increase = increase
   132      7504       1187.6      0.2      0.9                      best_position = next_i
   133                                           
   134       416        127.9      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        201.5    201.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0827367027317427

[('fl417', 1.0827367027317427)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124617 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.3      1.3      0.0          n = self.numCity
   114         1       4880.3   4880.3      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         32.3     32.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.6    407.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.1      0.2      0.1              best_increase = np.inf
   126       416         53.7      0.1      0.0              best_position = None
   127     87152      13976.0      0.2     11.2              for i in range(len(path)):
   128     86736      20835.6      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      65624.6      0.8     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15828.8      0.2     12.7                  if increase < best_increase:
   131      7937       1045.7      0.1      0.8                      best_increase = increase
   132      7937       1220.7      0.2      1.0                      best_position = next_i
   133                                           
   134       416        129.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.7      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        204.5    204.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0360141421230409

[('fl417', 1.0360141421230409)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.120214 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4955.8   4955.8      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         35.3     35.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        399.9    399.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.0      0.2      0.1              best_increase = np.inf
   126       416         47.7      0.1      0.0              best_position = None
   127     87152      13546.9      0.2     11.3              for i in range(len(path)):
   128     86736      20327.7      0.2     16.9                  next_i = (i + 1) % len(path)
   129     86736      62993.5      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      14972.2      0.2     12.5                  if increase < best_increase:
   131      8286       1082.4      0.1      0.9                      best_increase = increase
   132      8286       1133.5      0.1      0.9                      best_position = next_i
   133                                           
   134       416        128.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        109.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        210.1    210.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0686958959873072

[('fl417', 1.0686958959873072)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123096 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4728.5   4728.5      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         30.8     30.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        412.6    412.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        118.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.6      0.2      0.1              best_increase = np.inf
   126       416         54.2      0.1      0.0              best_position = None
   127     87152      12872.7      0.1     10.5              for i in range(len(path)):
   128     86736      21981.0      0.3     17.9                  next_i = (i + 1) % len(path)
   129     86736      63693.8      0.7     51.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16163.2      0.2     13.1                  if increase < best_increase:
   131      8311       1155.1      0.1      0.9                      best_increase = increase
   132      8311       1294.4      0.2      1.1                      best_position = next_i
   133                                           
   134       416        125.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        198.9    198.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.060806392438918

[('fl417', 1.060806392438918)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124074 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4797.0   4797.0      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         34.5     34.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        418.1    418.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.7      0.2      0.1              best_increase = np.inf
   126       416         54.0      0.1      0.0              best_position = None
   127     87152      13185.9      0.2     10.6              for i in range(len(path)):
   128     86736      20224.0      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      65340.4      0.8     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16647.4      0.2     13.4                  if increase < best_increase:
   131      8945       1240.7      0.1      1.0                      best_increase = increase
   132      8945       1402.3      0.2      1.1                      best_position = next_i
   133                                           
   134       416        128.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        216.7    216.7      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0638829166297248

[('fl417', 1.0638829166297248)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.128015 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       4927.2   4927.2      3.8          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         35.8     35.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        398.6    398.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         76.7      0.2      0.1              best_increase = np.inf
   126       416         53.3      0.1      0.0              best_position = None
   127     87152      14054.8      0.2     11.0              for i in range(len(path)):
   128     86736      20170.5      0.2     15.8                  next_i = (i + 1) % len(path)
   129     86736      68781.5      0.8     53.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16339.9      0.2     12.8                  if increase < best_increase:
   131      8649       1219.6      0.1      1.0                      best_increase = increase
   132      8649       1328.1      0.2      1.0                      best_position = next_i
   133                                           
   134       416        134.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        191.2    191.2      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.081128247501496

[('fl417', 1.081128247501496)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121512 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5205.6   5205.6      4.3          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.8     35.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        419.0    419.0      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         77.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         73.6      0.2      0.1              best_increase = np.inf
   126       416         48.0      0.1      0.0              best_position = None
   127     87152      13382.0      0.2     11.0              for i in range(len(path)):
   128     86736      19577.0      0.2     16.1                  next_i = (i + 1) % len(path)
   129     86736      64322.9      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15683.9      0.2     12.9                  if increase < best_increase:
   131      7752       1042.9      0.1      0.9                      best_increase = increase
   132      7752       1077.5      0.1      0.9                      best_position = next_i
   133                                           
   134       416        133.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        214.8    214.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0425887656132533

[('fl417', 1.0425887656132533)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.120585 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4823.6   4823.6      4.0          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         34.0     34.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        377.4    377.4      0.3          random.shuffle(notInPath)
   119                                           
   120       417        106.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.8      0.2      0.1              best_increase = np.inf
   126       416         51.5      0.1      0.0              best_position = None
   127     87152      11996.8      0.1      9.9              for i in range(len(path)):
   128     86736      20558.6      0.2     17.0                  next_i = (i + 1) % len(path)
   129     86736      63730.3      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16173.4      0.2     13.4                  if increase < best_increase:
   131      7502        968.1      0.1      0.8                      best_increase = increase
   132      7502       1146.1      0.2      1.0                      best_position = next_i
   133                                           
   134       416        138.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        208.3    208.3      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0658533294314423

[('fl417', 1.0658533294314423)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12917 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.2      1.2      0.0          n = self.numCity
   114         1       4957.9   4957.9      3.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         36.6     36.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        402.1    402.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.5      0.2      0.1              best_increase = np.inf
   126       416         50.0      0.1      0.0              best_position = None
   127     87152      14525.4      0.2     11.2              for i in range(len(path)):
   128     86736      21052.1      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      68940.9      0.8     53.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15948.1      0.2     12.3                  if increase < best_increase:
   131      8734       1272.1      0.1      1.0                      best_increase = increase
   132      8734       1235.5      0.1      1.0                      best_position = next_i
   133                                           
   134       416        148.8      0.4      0.1              path.insert(best_position, to_insert)
   135       416        110.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        213.1    213.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0534598369697485

[('fl417', 1.0534598369697485)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.128971 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.4      1.4      0.0          n = self.numCity
   114         1       4722.8   4722.8      3.7          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         30.9     30.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        395.8    395.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         77.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.9      0.2      0.1              best_increase = np.inf
   126       416         55.5      0.1      0.0              best_position = None
   127     87152      14175.8      0.2     11.0              for i in range(len(path)):
   128     86736      20084.3      0.2     15.6                  next_i = (i + 1) % len(path)
   129     86736      69713.5      0.8     54.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16790.4      0.2     13.0                  if increase < best_increase:
   131      8016       1045.8      0.1      0.8                      best_increase = increase
   132      8016       1225.7      0.2      1.0                      best_position = next_i
   133                                           
   134       416        143.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        207.1    207.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0590111035406446

[('fl417', 1.0590111035406446)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.127937 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       9628.3   9628.3      7.5          distances = np.array(self.adj)
   115         1          1.6      1.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.3      1.3      0.0          in_path = {0}
   117         1         70.4     70.4      0.1          notInPath = [x for x in range(1, n)]
   118         1        785.2    785.2      0.6          random.shuffle(notInPath)
   119                                           
   120       417        111.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         82.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         86.9      0.2      0.1              best_increase = np.inf
   126       416         57.5      0.1      0.0              best_position = None
   127     87152      13673.9      0.2     10.7              for i in range(len(path)):
   128     86736      19264.5      0.2     15.1                  next_i = (i + 1) % len(path)
   129     86736      64712.4      0.7     50.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16364.8      0.2     12.8                  if increase < best_increase:
   131      8806       1234.5      0.1      1.0                      best_increase = increase
   132      8806       1378.7      0.2      1.1                      best_position = next_i
   133                                           
   134       416        135.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        237.8    237.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.057558887054702

[('fl417', 1.057558887054702)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122693 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       4721.0   4721.0      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         30.9     30.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        401.6    401.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        109.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.3      0.2      0.1              best_increase = np.inf
   126       416         51.9      0.1      0.0              best_position = None
   127     87152      14220.8      0.2     11.6              for i in range(len(path)):
   128     86736      19911.0      0.2     16.2                  next_i = (i + 1) % len(path)
   129     86736      64456.3      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15838.6      0.2     12.9                  if increase < best_increase:
   131      8312       1112.0      0.1      0.9                      best_increase = increase
   132      8312       1239.5      0.1      1.0                      best_position = next_i
   133                                           
   134       416        127.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        202.8    202.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.067422733455872

[('fl417', 1.067422733455872)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121436 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4861.6   4861.6      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         30.7     30.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        401.8    401.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         73.6      0.2      0.1              best_increase = np.inf
   126       416         52.6      0.1      0.0              best_position = None
   127     87152      13117.9      0.2     10.8              for i in range(len(path)):
   128     86736      19843.9      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      63869.2      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15862.8      0.2     13.1                  if increase < best_increase:
   131      9197       1297.1      0.1      1.1                      best_increase = increase
   132      9197       1376.8      0.1      1.1                      best_position = next_i
   133                                           
   134       416        124.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        120.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        206.1    206.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.046453418947572

[('fl417', 1.046453418947572)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12605 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4906.7   4906.7      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.9     31.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        389.6    389.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        113.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.6      0.2      0.1              best_increase = np.inf
   126       416         54.1      0.1      0.0              best_position = None
   127     87152      13334.9      0.2     10.6              for i in range(len(path)):
   128     86736      21007.8      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      65736.2      0.8     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17547.6      0.2     13.9                  if increase < best_increase:
   131      7968       1072.9      0.1      0.9                      best_increase = increase
   132      7968       1217.5      0.2      1.0                      best_position = next_i
   133                                           
   134       416        147.0      0.4      0.1              path.insert(best_position, to_insert)
   135       416        123.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.5      2.5      0.0          self.tour = path
   138         1        201.9    201.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0723710697450823

[('fl417', 1.0723710697450823)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122481 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       4789.9   4789.9      3.9          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         30.9     30.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.3    414.3      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.8      0.2      0.1              best_increase = np.inf
   126       416         53.3      0.1      0.0              best_position = None
   127     87152      13928.4      0.2     11.4              for i in range(len(path)):
   128     86736      20067.5      0.2     16.4                  next_i = (i + 1) % len(path)
   129     86736      64366.0      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16128.6      0.2     13.2                  if increase < best_increase:
   131      7005        959.6      0.1      0.8                      best_increase = increase
   132      7005       1048.2      0.1      0.9                      best_position = next_i
   133                                           
   134       416        130.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.6      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        187.1    187.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1014886358164437

[('fl417', 1.1014886358164437)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121175 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4868.7   4868.7      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         36.7     36.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        403.2    403.2      0.3          random.shuffle(notInPath)
   119                                           
   120       417        105.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         97.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.5      0.2      0.1              best_increase = np.inf
   126       416         55.7      0.1      0.0              best_position = None
   127     87152      12109.1      0.1     10.0              for i in range(len(path)):
   128     86736      19773.6      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      64510.9      0.7     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16558.5      0.2     13.7                  if increase < best_increase:
   131      7313       1025.7      0.1      0.8                      best_increase = increase
   132      7313       1123.7      0.2      0.9                      best_position = next_i
   133                                           
   134       416        127.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        192.6    192.6      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0548816370568495

[('fl417', 1.0548816370568495)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.120358 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4888.2   4888.2      4.1          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.4     31.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        430.2    430.2      0.4          random.shuffle(notInPath)
   119                                           
   120       417        120.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.0      0.2      0.1              best_increase = np.inf
   126       416         50.3      0.1      0.0              best_position = None
   127     87152      12248.3      0.1     10.2              for i in range(len(path)):
   128     86736      20498.7      0.2     17.0                  next_i = (i + 1) % len(path)
   129     86736      63229.8      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16013.0      0.2     13.3                  if increase < best_increase:
   131      7665       1033.8      0.1      0.9                      best_increase = increase
   132      7665       1166.7      0.2      1.0                      best_position = next_i
   133                                           
   134       416        153.4      0.4      0.1              path.insert(best_position, to_insert)
   135       416        107.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        221.8    221.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0501957540618205

[('fl417', 1.0501957540618205)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.126494 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4874.4   4874.4      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         30.9     30.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        409.9    409.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        108.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.4      0.2      0.1              best_increase = np.inf
   126       416         56.5      0.1      0.0              best_position = None
   127     87152      13839.7      0.2     10.9              for i in range(len(path)):
   128     86736      21043.5      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      66288.9      0.8     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16715.6      0.2     13.2                  if increase < best_increase:
   131      8457       1159.1      0.1      0.9                      best_increase = increase
   132      8457       1373.3      0.2      1.1                      best_position = next_i
   133                                           
   134       416        126.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        196.8    196.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0506408203878854

[('fl417', 1.0506408203878854)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124456 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4916.8   4916.8      4.0          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.5     31.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        391.0    391.0      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.9      0.2      0.1              best_increase = np.inf
   126       416         53.8      0.1      0.0              best_position = None
   127     87152      13950.1      0.2     11.2              for i in range(len(path)):
   128     86736      20749.6      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      65152.4      0.8     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16142.2      0.2     13.0                  if increase < best_increase:
   131      8070       1124.0      0.1      0.9                      best_increase = increase
   132      8070       1221.2      0.2      1.0                      best_position = next_i
   133                                           
   134       416        128.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        216.0    216.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.090587984501027

[('fl417', 1.090587984501027)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121979 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4818.9   4818.9      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         36.1     36.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        419.7    419.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        125.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         76.8      0.2      0.1              best_increase = np.inf
   126       416         52.1      0.1      0.0              best_position = None
   127     87152      12883.6      0.1     10.6              for i in range(len(path)):
   128     86736      19753.3      0.2     16.2                  next_i = (i + 1) % len(path)
   129     86736      64671.7      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16413.2      0.2     13.5                  if increase < best_increase:
   131      7189        944.8      0.1      0.8                      best_increase = increase
   132      7189       1255.3      0.2      1.0                      best_position = next_i
   133                                           
   134       416        129.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        109.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        207.6    207.6      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0646979984258682

[('fl417', 1.0646979984258682)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121802 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       4802.0   4802.0      3.9          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         32.4     32.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        425.2    425.2      0.3          random.shuffle(notInPath)
   119                                           
   120       417        124.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         73.9      0.2      0.1              best_increase = np.inf
   126       416         53.2      0.1      0.0              best_position = None
   127     87152      13547.4      0.2     11.1              for i in range(len(path)):
   128     86736      20155.0      0.2     16.5                  next_i = (i + 1) % len(path)
   129     86736      63809.0      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16156.3      0.2     13.3                  if increase < best_increase:
   131      7307        985.4      0.1      0.8                      best_increase = increase
   132      7307       1125.3      0.2      0.9                      best_position = next_i
   133                                           
   134       416        127.9      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.2      2.2      0.0          self.tour = path
   138         1        192.9    192.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0983681962610996

[('fl417', 1.0983681962610996)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122278 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4877.6   4877.6      4.0          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         30.7     30.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        405.0    405.0      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.5      0.2      0.1              best_increase = np.inf
   126       416         48.4      0.1      0.0              best_position = None
   127     87152      14020.6      0.2     11.5              for i in range(len(path)):
   128     86736      20266.3      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      64503.0      0.7     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15232.8      0.2     12.5                  if increase < best_increase:
   131      8210       1070.2      0.1      0.9                      best_increase = increase
   132      8210       1128.3      0.1      0.9                      best_position = next_i
   133                                           
   134       416        137.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.7      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        184.3    184.3      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1051667642918352

[('fl417', 1.1051667642918352)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.125306 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       5158.3   5158.3      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         36.3     36.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.5    414.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         88.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.1      0.2      0.1              best_increase = np.inf
   126       416         57.7      0.1      0.0              best_position = None
   127     87152      13479.0      0.2     10.8              for i in range(len(path)):
   128     86736      19681.1      0.2     15.7                  next_i = (i + 1) % len(path)
   129     86736      65357.4      0.8     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17959.8      0.2     14.3                  if increase < best_increase:
   131      7654       1113.2      0.1      0.9                      best_increase = increase
   132      7654       1301.2      0.2      1.0                      best_position = next_i
   133                                           
   134       416        135.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        115.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        213.0    213.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1234302765150703

[('fl417', 1.1234302765150703)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124114 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5071.2   5071.2      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.7     35.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        401.4    401.4      0.3          random.shuffle(notInPath)
   119                                           
   120       417        126.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.4      0.2      0.1              best_increase = np.inf
   126       416         53.4      0.1      0.0              best_position = None
   127     87152      12941.9      0.1     10.4              for i in range(len(path)):
   128     86736      20608.3      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      65608.0      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16583.6      0.2     13.4                  if increase < best_increase:
   131      7402       1014.4      0.1      0.8                      best_increase = increase
   132      7402       1075.6      0.1      0.9                      best_position = next_i
   133                                           
   134       416        133.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416         99.1      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        197.9    197.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0566853205846818

[('fl417', 1.0566853205846818)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.119666 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       4735.8   4735.8      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.4     31.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        419.2    419.2      0.4          random.shuffle(notInPath)
   119                                           
   120       417        112.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         74.1      0.2      0.1              best_increase = np.inf
   126       416         48.3      0.1      0.0              best_position = None
   127     87152      13530.7      0.2     11.3              for i in range(len(path)):
   128     86736      19771.4      0.2     16.5                  next_i = (i + 1) % len(path)
   129     86736      63371.8      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15201.1      0.2     12.7                  if increase < best_increase:
   131      7006        909.6      0.1      0.8                      best_increase = increase
   132      7006        951.3      0.1      0.8                      best_position = next_i
   133                                           
   134       416        126.0      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        194.2    194.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0884086328398783

[('fl417', 1.0884086328398783)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.126023 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       4929.1   4929.1      3.9          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         35.5     35.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        398.5    398.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.5      0.2      0.1              best_increase = np.inf
   126       416         52.4      0.1      0.0              best_position = None
   127     87152      13651.8      0.2     10.8              for i in range(len(path)):
   128     86736      19696.7      0.2     15.6                  next_i = (i + 1) % len(path)
   129     86736      67463.0      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16670.4      0.2     13.2                  if increase < best_increase:
   131      8395       1124.4      0.1      0.9                      best_increase = increase
   132      8395       1267.3      0.2      1.0                      best_position = next_i
   133                                           
   134       416        132.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        217.9    217.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0918464638253782

[('fl417', 1.0918464638253782)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121752 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.2      1.2      0.0          n = self.numCity
   114         1       4812.8   4812.8      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         32.4     32.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        379.9    379.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        106.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         92.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.4      0.2      0.1              best_increase = np.inf
   126       416         53.5      0.1      0.0              best_position = None
   127     87152      13693.1      0.2     11.2              for i in range(len(path)):
   128     86736      19489.0      0.2     16.0                  next_i = (i + 1) % len(path)
   129     86736      64274.0      0.7     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16293.5      0.2     13.4                  if increase < best_increase:
   131      7307        928.5      0.1      0.8                      best_increase = increase
   132      7307       1095.9      0.1      0.9                      best_position = next_i
   133                                           
   134       416        123.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        102.6      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.4      1.4      0.0          self.tour = path
   138         1        192.3    192.3      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0488469677238157

[('fl417', 1.0488469677238157)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122628 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4704.6   4704.6      3.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         35.9     35.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        409.3    409.3      0.3          random.shuffle(notInPath)
   119                                           
   120       417        104.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         72.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         74.4      0.2      0.1              best_increase = np.inf
   126       416         52.6      0.1      0.0              best_position = None
   127     87152      13073.7      0.2     10.7              for i in range(len(path)):
   128     86736      20300.5      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      64761.7      0.7     52.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16283.3      0.2     13.3                  if increase < best_increase:
   131      8091       1119.4      0.1      0.9                      best_increase = increase
   132      8091       1202.5      0.1      1.0                      best_position = next_i
   133                                           
   134       416        141.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        182.8    182.8      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.155921697328612

[('fl417', 1.155921697328612)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123363 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4760.0   4760.0      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         30.9     30.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        374.1    374.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.5      0.2      0.1              best_increase = np.inf
   126       416         52.4      0.1      0.0              best_position = None
   127     87152      13359.1      0.2     10.8              for i in range(len(path)):
   128     86736      20091.9      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      65430.9      0.8     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16649.9      0.2     13.5                  if increase < best_increase:
   131      6374        879.6      0.1      0.7                      best_increase = increase
   132      6374        965.1      0.2      0.8                      best_position = next_i
   133                                           
   134       416        144.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        127.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        222.1    222.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0364621434909058

[('fl417', 1.0364621434909058)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122112 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.0      1.0      0.0          n = self.numCity
   114         1       4744.1   4744.1      3.9          distances = np.array(self.adj)
   115         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.1     35.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        434.0    434.0      0.4          random.shuffle(notInPath)
   119                                           
   120       417        108.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         93.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         76.2      0.2      0.1              best_increase = np.inf
   126       416         52.4      0.1      0.0              best_position = None
   127     87152      12466.8      0.1     10.2              for i in range(len(path)):
   128     86736      20128.3      0.2     16.5                  next_i = (i + 1) % len(path)
   129     86736      64950.2      0.7     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16055.6      0.2     13.1                  if increase < best_increase:
   131      8996       1199.1      0.1      1.0                      best_increase = increase
   132      8996       1344.1      0.1      1.1                      best_position = next_i
   133                                           
   134       416        123.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.5      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        193.2    193.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0413880288303428

[('fl417', 1.0413880288303428)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.120409 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       4822.4   4822.4      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         46.2     46.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        438.4    438.4      0.4          random.shuffle(notInPath)
   119                                           
   120       417        120.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.7      0.2      0.1              best_increase = np.inf
   126       416         51.5      0.1      0.0              best_position = None
   127     87152      13215.9      0.2     11.0              for i in range(len(path)):
   128     86736      18951.0      0.2     15.7                  next_i = (i + 1) % len(path)
   129     86736      63851.0      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16087.5      0.2     13.4                  if increase < best_increase:
   131      7884       1056.3      0.1      0.9                      best_increase = increase
   132      7884       1169.3      0.1      1.0                      best_position = next_i
   133                                           
   134       416        127.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        204.5    204.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0431103561464325

[('fl417', 1.0431103561464325)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124593 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4896.9   4896.9      3.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.4      1.4      0.0          in_path = {0}
   117         1         31.4     31.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        403.9    403.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        113.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         84.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.5      0.2      0.1              best_increase = np.inf
   126       416         58.0      0.1      0.0              best_position = None
   127     87152      14050.5      0.2     11.3              for i in range(len(path)):
   128     86736      19583.6      0.2     15.7                  next_i = (i + 1) % len(path)
   129     86736      64958.8      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17680.8      0.2     14.2                  if increase < best_increase:
   131      7327        990.3      0.1      0.8                      best_increase = increase
   132      7327       1191.0      0.2      1.0                      best_position = next_i
   133                                           
   134       416        139.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        114.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        209.8    209.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0846766039979303

[('fl417', 1.0846766039979303)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12287 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4884.3   4884.3      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         33.6     33.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        441.4    441.4      0.4          random.shuffle(notInPath)
   119                                           
   120       417        110.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         82.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.4      0.2      0.1              best_increase = np.inf
   126       416         56.3      0.1      0.0              best_position = None
   127     87152      13591.2      0.2     11.1              for i in range(len(path)):
   128     86736      20209.4      0.2     16.4                  next_i = (i + 1) % len(path)
   129     86736      63944.0      0.7     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16596.3      0.2     13.5                  if increase < best_increase:
   131      8084       1160.5      0.1      0.9                      best_increase = increase
   132      8084       1224.2      0.2      1.0                      best_position = next_i
   133                                           
   134       416        136.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        207.6    207.6      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0374233272881042

[('fl417', 1.0374233272881042)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.125297 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5066.5   5066.5      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         35.6     35.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        393.9    393.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         86.4      0.2      0.1              best_increase = np.inf
   126       416         54.9      0.1      0.0              best_position = None
   127     87152      12959.3      0.1     10.3              for i in range(len(path)):
   128     86736      19883.6      0.2     15.9                  next_i = (i + 1) % len(path)
   129     86736      66675.3      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17128.3      0.2     13.7                  if increase < best_increase:
   131      8175       1144.0      0.1      0.9                      best_increase = increase
   132      8175       1238.9      0.2      1.0                      best_position = next_i
   133                                           
   134       416        139.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.8      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        190.1    190.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1468888291918982

[('fl417', 1.1468888291918982)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12307 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4792.6   4792.6      3.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         34.8     34.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        427.8    427.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.3      0.2      0.1              best_increase = np.inf
   126       416         54.7      0.1      0.0              best_position = None
   127     87152      14066.5      0.2     11.4              for i in range(len(path)):
   128     86736      20647.3      0.2     16.8                  next_i = (i + 1) % len(path)
   129     86736      64376.7      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15947.6      0.2     13.0                  if increase < best_increase:
   131      7086        969.6      0.1      0.8                      best_increase = increase
   132      7086       1061.6      0.1      0.9                      best_position = next_i
   133                                           
   134       416        126.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        100.8      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        190.0    190.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.072261439865218

[('fl417', 1.072261439865218)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123381 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4772.0   4772.0      3.9          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         34.7     34.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.4    407.4      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.5      0.2      0.1              best_increase = np.inf
   126       416         53.0      0.1      0.0              best_position = None
   127     87152      12236.6      0.1      9.9              for i in range(len(path)):
   128     86736      21362.2      0.2     17.3                  next_i = (i + 1) % len(path)
   129     86736      64825.0      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16848.6      0.2     13.7                  if increase < best_increase:
   131      7167        965.3      0.1      0.8                      best_increase = increase
   132      7167       1160.6      0.2      0.9                      best_position = next_i
   133                                           
   134       416        128.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        206.2    206.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0604606408101234

[('fl417', 1.0604606408101234)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123616 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4875.9   4875.9      3.9          distances = np.array(self.adj)
   115         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1         15.6     15.6      0.0          in_path = {0}
   117         1         48.8     48.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        419.6    419.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        105.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         85.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         83.1      0.2      0.1              best_increase = np.inf
   126       416         53.6      0.1      0.0              best_position = None
   127     87152      13133.8      0.2     10.6              for i in range(len(path)):
   128     86736      19924.1      0.2     16.1                  next_i = (i + 1) % len(path)
   129     86736      65677.2      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16384.8      0.2     13.3                  if increase < best_increase:
   131      7974       1081.5      0.1      0.9                      best_increase = increase
   132      7974       1245.6      0.2      1.0                      best_position = next_i
   133                                           
   134       416        147.7      0.4      0.1              path.insert(best_position, to_insert)
   135       416        107.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.4      1.4      0.0          self.tour = path
   138         1        223.9    223.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0713573378685537

[('fl417', 1.0713573378685537)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122338 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5113.3   5113.3      4.2          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         34.7     34.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        389.9    389.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.0      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         82.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.2      0.2      0.1              best_increase = np.inf
   126       416         50.8      0.1      0.0              best_position = None
   127     87152      13626.1      0.2     11.1              for i in range(len(path)):
   128     86736      20150.5      0.2     16.5                  next_i = (i + 1) % len(path)
   129     86736      64460.8      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16142.2      0.2     13.2                  if increase < best_increase:
   131      5865        795.7      0.1      0.7                      best_increase = increase
   132      5865        854.6      0.1      0.7                      best_position = next_i
   133                                           
   134       416        136.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        122.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        188.9    188.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0481497817244396

[('fl417', 1.0481497817244396)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.126435 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4776.6   4776.6      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.6     35.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        410.7    410.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        112.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         84.2      0.2      0.1              best_increase = np.inf
   126       416         53.6      0.1      0.0              best_position = None
   127     87152      13336.7      0.2     10.5              for i in range(len(path)):
   128     86736      20262.1      0.2     16.0                  next_i = (i + 1) % len(path)
   129     86736      68227.2      0.8     54.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16236.5      0.2     12.8                  if increase < best_increase:
   131      8336       1108.4      0.1      0.9                      best_increase = increase
   132      8336       1272.8      0.2      1.0                      best_position = next_i
   133                                           
   134       416        130.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        102.1      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        201.8    201.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0714617728108444

[('fl417', 1.0714617728108444)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122143 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4719.9   4719.9      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         34.7     34.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.3    407.3      0.3          random.shuffle(notInPath)
   119                                           
   120       417        102.9      0.2      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         77.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         74.3      0.2      0.1              best_increase = np.inf
   126       416         48.1      0.1      0.0              best_position = None
   127     87152      13492.4      0.2     11.0              for i in range(len(path)):
   128     86736      20338.2      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      64994.7      0.7     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15452.4      0.2     12.7                  if increase < best_increase:
   131      7439        957.5      0.1      0.8                      best_increase = increase
   132      7439       1015.7      0.1      0.8                      best_position = next_i
   133                                           
   134       416        125.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.4      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        194.9    194.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0728796146932442

[('fl417', 1.0728796146932442)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.120117 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4750.1   4750.1      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         30.5     30.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.2    414.2      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.2      0.2      0.1              best_increase = np.inf
   126       416         52.9      0.1      0.0              best_position = None
   127     87152      12331.3      0.1     10.3              for i in range(len(path)):
   128     86736      20546.3      0.2     17.1                  next_i = (i + 1) % len(path)
   129     86736      63627.2      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15684.1      0.2     13.1                  if increase < best_increase:
   131      7024        907.9      0.1      0.8                      best_increase = increase
   132      7024       1061.3      0.2      0.9                      best_position = next_i
   133                                           
   134       416        125.9      0.3      0.1              path.insert(best_position, to_insert)
   135       416        117.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        194.1    194.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1061121446038198

[('fl417', 1.1061121446038198)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124609 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4792.3   4792.3      3.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         31.0     31.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        400.3    400.3      0.3          random.shuffle(notInPath)
   119                                           
   120       417        114.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         98.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.6      0.2      0.1              best_increase = np.inf
   126       416         54.2      0.1      0.0              best_position = None
   127     87152      13935.3      0.2     11.2              for i in range(len(path)):
   128     86736      21268.3      0.2     17.1                  next_i = (i + 1) % len(path)
   129     86736      65359.5      0.8     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15996.2      0.2     12.8                  if increase < best_increase:
   131      6921        942.5      0.1      0.8                      best_increase = increase
   132      6921       1076.8      0.2      0.9                      best_position = next_i
   133                                           
   134       416        131.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        114.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        209.4    209.4      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1069745435676916

[('fl417', 1.1069745435676916)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124065 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4823.7   4823.7      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         35.9     35.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        396.4    396.4      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         76.6      0.2      0.1              best_increase = np.inf
   126       416         54.0      0.1      0.0              best_position = None
   127     87152      13124.5      0.2     10.6              for i in range(len(path)):
   128     86736      20442.5      0.2     16.5                  next_i = (i + 1) % len(path)
   129     86736      66248.7      0.8     53.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15959.9      0.2     12.9                  if increase < best_increase:
   131      8071       1052.8      0.1      0.8                      best_increase = increase
   132      8071       1201.2      0.1      1.0                      best_position = next_i
   133                                           
   134       416        124.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        114.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        220.5    220.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1185195609896716

[('fl417', 1.1185195609896716)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123483 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       4747.7   4747.7      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         30.4     30.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.2    414.2      0.3          random.shuffle(notInPath)
   119                                           
   120       417        121.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         87.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         75.5      0.2      0.1              best_increase = np.inf
   126       416         48.2      0.1      0.0              best_position = None
   127     87152      12876.4      0.1     10.4              for i in range(len(path)):
   128     86736      19935.0      0.2     16.1                  next_i = (i + 1) % len(path)
   129     86736      67297.6      0.8     54.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15420.2      0.2     12.5                  if increase < best_increase:
   131      7259        990.6      0.1      0.8                      best_increase = increase
   132      7259       1007.0      0.1      0.8                      best_position = next_i
   133                                           
   134       416        133.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        187.8    187.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0505345075098809

[('fl417', 1.0505345075098809)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122547 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5066.3   5066.3      4.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.4     31.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        416.6    416.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         74.4      0.2      0.1              best_increase = np.inf
   126       416         47.0      0.1      0.0              best_position = None
   127     87152      13483.6      0.2     11.0              for i in range(len(path)):
   128     86736      19855.6      0.2     16.2                  next_i = (i + 1) % len(path)
   129     86736      65836.8      0.8     53.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15125.7      0.2     12.3                  if increase < best_increase:
   131      7568        977.7      0.1      0.8                      best_increase = increase
   132      7568       1016.7      0.1      0.8                      best_position = next_i
   133                                           
   134       416        122.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        100.0      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        199.7    199.7      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.102632587517662

[('fl417', 1.102632587517662)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122237 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4739.5   4739.5      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         30.7     30.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        398.6    398.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         76.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         88.7      0.2      0.1              best_increase = np.inf
   126       416         69.7      0.2      0.1              best_position = None
   127     87152      13542.7      0.2     11.1              for i in range(len(path)):
   128     86736      20325.3      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      64090.2      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16424.4      0.2     13.4                  if increase < best_increase:
   131      6446        898.4      0.1      0.7                      best_increase = increase
   132      6446       1012.5      0.2      0.8                      best_position = next_i
   133                                           
   134       416        120.9      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        199.9    199.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0579277710537678

[('fl417', 1.0579277710537678)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122062 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       4777.0   4777.0      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         38.5     38.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        447.3    447.3      0.4          random.shuffle(notInPath)
   119                                           
   120       417        107.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         75.3      0.2      0.1              best_increase = np.inf
   126       416         54.9      0.1      0.0              best_position = None
   127     87152      13145.2      0.2     10.8              for i in range(len(path)):
   128     86736      19946.5      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      64561.3      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16516.6      0.2     13.5                  if increase < best_increase:
   131      6339        869.6      0.1      0.7                      best_increase = increase
   132      6339       1032.0      0.2      0.8                      best_position = next_i
   133                                           
   134       416        123.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        175.3    175.3      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.05257995100168

[('fl417', 1.05257995100168)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123941 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4856.9   4856.9      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.2     31.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        404.6    404.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        104.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         73.6      0.2      0.1              best_increase = np.inf
   126       416         55.2      0.1      0.0              best_position = None
   127     87152      13551.9      0.2     10.9              for i in range(len(path)):
   128     86736      20762.2      0.2     16.8                  next_i = (i + 1) % len(path)
   129     86736      65569.9      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16088.8      0.2     13.0                  if increase < best_increase:
   131      6774        907.0      0.1      0.7                      best_increase = increase
   132      6774        997.6      0.1      0.8                      best_position = next_i
   133                                           
   134       416        151.2      0.4      0.1              path.insert(best_position, to_insert)
   135       416        106.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        196.5    196.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0612183372249524

[('fl417', 1.0612183372249524)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122676 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4879.7   4879.7      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         33.0     33.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        431.1    431.1      0.4          random.shuffle(notInPath)
   119                                           
   120       417        110.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.5      0.2      0.1              best_increase = np.inf
   126       416         54.4      0.1      0.0              best_position = None
   127     87152      13715.2      0.2     11.2              for i in range(len(path)):
   128     86736      19624.8      0.2     16.0                  next_i = (i + 1) % len(path)
   129     86736      64187.8      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16213.9      0.2     13.2                  if increase < best_increase:
   131      9691       1330.8      0.1      1.1                      best_increase = increase
   132      9691       1477.1      0.2      1.2                      best_position = next_i
   133                                           
   134       416        134.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        109.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        214.0    214.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0433081096226353

[('fl417', 1.0433081096226353)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122197 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4944.7   4944.7      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.2      1.2      0.0          in_path = {0}
   117         1         38.1     38.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.1    407.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        120.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         90.7      0.2      0.1              best_increase = np.inf
   126       416         48.5      0.1      0.0              best_position = None
   127     87152      13399.4      0.2     11.0              for i in range(len(path)):
   128     86736      20068.1      0.2     16.4                  next_i = (i + 1) % len(path)
   129     86736      64650.7      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15582.7      0.2     12.8                  if increase < best_increase:
   131      8393       1173.2      0.1      1.0                      best_increase = increase
   132      8393       1177.0      0.1      1.0                      best_position = next_i
   133                                           
   134       416        124.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.5      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        183.5    183.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0988917715387134

[('fl417', 1.0988917715387134)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122545 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.1      1.1      0.0          n = self.numCity
   114         1       4717.7   4717.7      3.8          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.7     31.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        419.1    419.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         91.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         83.5      0.2      0.1              best_increase = np.inf
   126       416         53.6      0.1      0.0              best_position = None
   127     87152      13241.9      0.2     10.8              for i in range(len(path)):
   128     86736      19069.6      0.2     15.6                  next_i = (i + 1) % len(path)
   129     86736      65229.4      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16872.2      0.2     13.8                  if increase < best_increase:
   131      7410       1011.7      0.1      0.8                      best_increase = increase
   132      7410       1177.3      0.2      1.0                      best_position = next_i
   133                                           
   134       416        138.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        188.8    188.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0787196028562231

[('fl417', 1.0787196028562231)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122637 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4841.5   4841.5      3.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.2     31.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.6    414.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        115.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416        104.2      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.3      0.2      0.1              best_increase = np.inf
   126       416         49.1      0.1      0.0              best_position = None
   127     87152      13454.7      0.2     11.0              for i in range(len(path)):
   128     86736      19924.8      0.2     16.2                  next_i = (i + 1) % len(path)
   129     86736      65779.7      0.8     53.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15295.3      0.2     12.5                  if increase < best_increase:
   131      7101       1043.6      0.1      0.9                      best_increase = increase
   132      7101       1038.6      0.1      0.8                      best_position = next_i
   133                                           
   134       416        135.9      0.3      0.1              path.insert(best_position, to_insert)
   135       416        113.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        211.6    211.6      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0648527487648618

[('fl417', 1.0648527487648618)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122616 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4749.0   4749.0      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         38.5     38.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        523.8    523.8      0.4          random.shuffle(notInPath)
   119                                           
   120       417        114.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         84.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.2      0.2      0.1              best_increase = np.inf
   126       416         51.5      0.1      0.0              best_position = None
   127     87152      12372.3      0.1     10.1              for i in range(len(path)):
   128     86736      21062.7      0.2     17.2                  next_i = (i + 1) % len(path)
   129     86736      64443.9      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16269.7      0.2     13.3                  if increase < best_increase:
   131      8254       1151.4      0.1      0.9                      best_increase = increase
   132      8254       1220.3      0.1      1.0                      best_position = next_i
   133                                           
   134       416        124.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        102.0      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.5      2.5      0.0          self.tour = path
   138         1        225.5    225.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0544561632409473

[('fl417', 1.0544561632409473)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121382 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4931.8   4931.8      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         36.6     36.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.4    414.4      0.3          random.shuffle(notInPath)
   119                                           
   120       417        144.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416        104.9      0.3      0.1              best_increase = np.inf
   126       416         51.5      0.1      0.0              best_position = None
   127     87152      13143.1      0.2     10.8              for i in range(len(path)):
   128     86736      19940.7      0.2     16.4                  next_i = (i + 1) % len(path)
   129     86736      63967.5      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15916.8      0.2     13.1                  if increase < best_increase:
   131      7818       1065.2      0.1      0.9                      best_increase = increase
   132      7818       1162.8      0.1      1.0                      best_position = next_i
   133                                           
   134       416        125.0      0.3      0.1              path.insert(best_position, to_insert)
   135       416        108.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        186.3    186.3      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.102478599421615

[('fl417', 1.102478599421615)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122921 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4912.9   4912.9      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         35.9     35.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        381.8    381.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        108.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         76.0      0.2      0.1              best_increase = np.inf
   126       416         53.4      0.1      0.0              best_position = None
   127     87152      13508.1      0.2     11.0              for i in range(len(path)):
   128     86736      20311.0      0.2     16.5                  next_i = (i + 1) % len(path)
   129     86736      63917.0      0.7     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16790.4      0.2     13.7                  if increase < best_increase:
   131      7705       1069.9      0.1      0.9                      best_increase = increase
   132      7705       1182.3      0.2      1.0                      best_position = next_i
   133                                           
   134       416        145.9      0.4      0.1              path.insert(best_position, to_insert)
   135       416        105.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        238.4    238.4      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0863720165659458

[('fl417', 1.0863720165659458)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121371 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4847.3   4847.3      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         35.4     35.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        409.4    409.4      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         87.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         75.9      0.2      0.1              best_increase = np.inf
   126       416         52.9      0.1      0.0              best_position = None
   127     87152      13648.2      0.2     11.2              for i in range(len(path)):
   128     86736      19966.0      0.2     16.5                  next_i = (i + 1) % len(path)
   129     86736      63537.3      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16121.5      0.2     13.3                  if increase < best_increase:
   131      7153        951.2      0.1      0.8                      best_increase = increase
   132      7153       1053.4      0.1      0.9                      best_position = next_i
   133                                           
   134       416        132.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.7      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        232.7    232.7      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0800668193799796

[('fl417', 1.0800668193799796)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12277 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       4921.1   4921.1      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.1     31.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.1    414.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        109.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         74.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.4      0.2      0.1              best_increase = np.inf
   126       416         54.4      0.1      0.0              best_position = None
   127     87152      14101.4      0.2     11.5              for i in range(len(path)):
   128     86736      20880.1      0.2     17.0                  next_i = (i + 1) % len(path)
   129     86736      63378.5      0.7     51.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16398.5      0.2     13.4                  if increase < best_increase:
   131      6508        875.8      0.1      0.7                      best_increase = increase
   132      6508       1024.1      0.2      0.8                      best_position = next_i
   133                                           
   134       416        128.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        191.0    191.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0619757528539067

[('fl417', 1.0619757528539067)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121501 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4939.3   4939.3      4.1          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         35.5     35.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        395.9    395.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        114.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         82.5      0.2      0.1              best_increase = np.inf
   126       416         56.8      0.1      0.0              best_position = None
   127     87152      13241.4      0.2     10.9              for i in range(len(path)):
   128     86736      19960.6      0.2     16.4                  next_i = (i + 1) % len(path)
   129     86736      63252.0      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16603.6      0.2     13.7                  if increase < best_increase:
   131      7818       1100.1      0.1      0.9                      best_increase = increase
   132      7818       1204.3      0.2      1.0                      best_position = next_i
   133                                           
   134       416        132.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        191.0    191.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0997993329662108

[('fl417', 1.0997993329662108)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12474 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4812.7   4812.7      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.0     31.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        398.9    398.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        106.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         76.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.9      0.2      0.1              best_increase = np.inf
   126       416         52.7      0.1      0.0              best_position = None
   127     87152      13383.0      0.2     10.7              for i in range(len(path)):
   128     86736      20486.2      0.2     16.4                  next_i = (i + 1) % len(path)
   129     86736      65999.1      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16642.3      0.2     13.3                  if increase < best_increase:
   131      7777       1100.4      0.1      0.9                      best_increase = increase
   132      7777       1119.8      0.1      0.9                      best_position = next_i
   133                                           
   134       416        143.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.8      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        202.0    202.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.066467019600307

[('fl417', 1.066467019600307)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121867 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4732.3   4732.3      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         30.9     30.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        450.3    450.3      0.4          random.shuffle(notInPath)
   119                                           
   120       417        109.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         78.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.8      0.2      0.1              best_increase = np.inf
   126       416         54.5      0.1      0.0              best_position = None
   127     87152      12846.5      0.1     10.5              for i in range(len(path)):
   128     86736      20568.4      0.2     16.9                  next_i = (i + 1) % len(path)
   129     86736      64137.3      0.7     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16169.7      0.2     13.3                  if increase < best_increase:
   131      7625       1032.2      0.1      0.8                      best_increase = increase
   132      7625       1149.1      0.2      0.9                      best_position = next_i
   133                                           
   134       416        127.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        192.4    192.4      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0755177408671235

[('fl417', 1.0755177408671235)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123228 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4894.2   4894.2      4.0          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         37.6     37.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        416.7    416.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        117.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         88.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.6      0.2      0.1              best_increase = np.inf
   126       416         54.0      0.1      0.0              best_position = None
   127     87152      12250.4      0.1      9.9              for i in range(len(path)):
   128     86736      20501.6      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      65222.2      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16789.2      0.2     13.6                  if increase < best_increase:
   131      8266       1138.6      0.1      0.9                      best_increase = increase
   132      8266       1214.7      0.1      1.0                      best_position = next_i
   133                                           
   134       416        126.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        190.5    190.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0565729724303483

[('fl417', 1.0565729724303483)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122812 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.2      1.2      0.0          n = self.numCity
   114         1       4787.9   4787.9      3.9          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.3     31.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        471.5    471.5      0.4          random.shuffle(notInPath)
   119                                           
   120       417        116.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416        100.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         79.0      0.2      0.1              best_increase = np.inf
   126       416         48.8      0.1      0.0              best_position = None
   127     87152      13941.8      0.2     11.4              for i in range(len(path)):
   128     86736      20360.8      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      64679.5      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15566.4      0.2     12.7                  if increase < best_increase:
   131      7448        971.8      0.1      0.8                      best_increase = increase
   132      7448       1117.0      0.1      0.9                      best_position = next_i
   133                                           
   134       416        160.9      0.4      0.1              path.insert(best_position, to_insert)
   135       416        130.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.4      2.4      0.0          self.tour = path
   138         1        242.9    242.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1028264729468724

[('fl417', 1.1028264729468724)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121022 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4751.8   4751.8      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         35.1     35.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        420.6    420.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        119.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         82.1      0.2      0.1              best_increase = np.inf
   126       416         54.0      0.1      0.0              best_position = None
   127     87152      13053.8      0.1     10.8              for i in range(len(path)):
   128     86736      20037.3      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      63583.6      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16450.2      0.2     13.6                  if increase < best_increase:
   131      6844        891.9      0.1      0.7                      best_increase = increase
   132      6844       1048.8      0.2      0.9                      best_position = next_i
   133                                           
   134       416        122.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        102.3      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        186.1    186.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.048068274676818

[('fl417', 1.048068274676818)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124858 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       4800.0   4800.0      3.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         30.8     30.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        411.8    411.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        110.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         94.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.5      0.2      0.1              best_increase = np.inf
   126       416         53.4      0.1      0.0              best_position = None
   127     87152      14111.0      0.2     11.3              for i in range(len(path)):
   128     86736      21242.1      0.2     17.0                  next_i = (i + 1) % len(path)
   129     86736      65616.8      0.8     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15720.9      0.2     12.6                  if increase < best_increase:
   131      7529       1025.3      0.1      0.8                      best_increase = increase
   132      7529       1135.5      0.2      0.9                      best_position = next_i
   133                                           
   134       416        132.0      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        180.9    180.9      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0706228843751757

[('fl417', 1.0706228843751757)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12132 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4919.5   4919.5      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.9      0.9      0.0          in_path = {0}
   117         1         35.2     35.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        396.8    396.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.7      0.2      0.1              best_increase = np.inf
   126       416         52.9      0.1      0.0              best_position = None
   127     87152      13130.4      0.2     10.8              for i in range(len(path)):
   128     86736      19930.3      0.2     16.4                  next_i = (i + 1) % len(path)
   129     86736      63669.0      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16319.4      0.2     13.5                  if increase < best_increase:
   131      7492        995.2      0.1      0.8                      best_increase = increase
   132      7492       1114.5      0.1      0.9                      best_position = next_i
   133                                           
   134       416        137.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        125.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.2      2.2      0.0          self.tour = path
   138         1        225.8    225.8      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0745644665616831

[('fl417', 1.0745644665616831)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123884 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4780.7   4780.7      3.9          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.1     31.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        430.1    430.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         82.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         75.5      0.2      0.1              best_increase = np.inf
   126       416         52.0      0.1      0.0              best_position = None
   127     87152      13669.8      0.2     11.0              for i in range(len(path)):
   128     86736      20517.8      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      65228.8      0.8     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16091.4      0.2     13.0                  if increase < best_increase:
   131      8339       1128.2      0.1      0.9                      best_increase = increase
   132      8339       1251.3      0.2      1.0                      best_position = next_i
   133                                           
   134       416        143.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        184.1    184.1      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0870896296155201

[('fl417', 1.0870896296155201)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12127 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4884.7   4884.7      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         30.8     30.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        394.7    394.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        109.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         84.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         81.2      0.2      0.1              best_increase = np.inf
   126       416         53.9      0.1      0.0              best_position = None
   127     87152      13718.6      0.2     11.3              for i in range(len(path)):
   128     86736      19570.6      0.2     16.1                  next_i = (i + 1) % len(path)
   129     86736      63191.1      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16272.5      0.2     13.4                  if increase < best_increase:
   131      8475       1117.4      0.1      0.9                      best_increase = increase
   132      8475       1308.8      0.2      1.1                      best_position = next_i
   133                                           
   134       416        130.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        209.2    209.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0735461457194202

[('fl417', 1.0735461457194202)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122161 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4958.7   4958.7      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         36.8     36.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        413.8    413.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        113.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.1      0.2      0.1              best_increase = np.inf
   126       416         49.0      0.1      0.0              best_position = None
   127     87152      13282.5      0.2     10.9              for i in range(len(path)):
   128     86736      19802.9      0.2     16.2                  next_i = (i + 1) % len(path)
   129     86736      65073.6      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15611.6      0.2     12.8                  if increase < best_increase:
   131      7851       1093.5      0.1      0.9                      best_increase = increase
   132      7851       1114.9      0.1      0.9                      best_position = next_i
   133                                           
   134       416        125.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        216.0    216.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0343987171951416

[('fl417', 1.0343987171951416)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123705 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       4778.1   4778.1      3.9          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         36.7     36.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        403.5    403.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         77.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         73.5      0.2      0.1              best_increase = np.inf
   126       416         56.9      0.1      0.0              best_position = None
   127     87152      14039.5      0.2     11.3              for i in range(len(path)):
   128     86736      21010.3      0.2     17.0                  next_i = (i + 1) % len(path)
   129     86736      63434.4      0.7     51.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17008.8      0.2     13.7                  if increase < best_increase:
   131      7493       1003.5      0.1      0.8                      best_increase = increase
   132      7493       1215.6      0.2      1.0                      best_position = next_i
   133                                           
   134       416        142.0      0.3      0.1              path.insert(best_position, to_insert)
   135       416        102.1      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        206.6    206.6      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.065041048488989

[('fl417', 1.065041048488989)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.12525 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4982.2   4982.2      4.0          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.8     35.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        416.1    416.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        112.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         83.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.8      0.2      0.1              best_increase = np.inf
   126       416         54.9      0.1      0.0              best_position = None
   127     87152      13417.5      0.2     10.7              for i in range(len(path)):
   128     86736      20930.5      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      65244.1      0.8     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16805.6      0.2     13.4                  if increase < best_increase:
   131      8539       1250.5      0.1      1.0                      best_increase = increase
   132      8539       1398.8      0.2      1.1                      best_position = next_i
   133                                           
   134       416        133.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        195.3    195.3      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1027258703300697

[('fl417', 1.1027258703300697)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122513 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4994.7   4994.7      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.4     31.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        421.1    421.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        109.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         96.0      0.2      0.1              best_increase = np.inf
   126       416         51.5      0.1      0.0              best_position = None
   127     87152      12662.4      0.1     10.3              for i in range(len(path)):
   128     86736      21030.3      0.2     17.2                  next_i = (i + 1) % len(path)
   129     86736      63862.3      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16191.6      0.2     13.2                  if increase < best_increase:
   131      8635       1158.9      0.1      0.9                      best_increase = increase
   132      8635       1377.6      0.2      1.1                      best_position = next_i
   133                                           
   134       416        132.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416         99.4      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        208.9    208.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0836366291650605

[('fl417', 1.0836366291650605)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.125072 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4750.7   4750.7      3.8          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         35.5     35.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        405.9    405.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.3      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416        112.3      0.3      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.7      0.2      0.1              best_increase = np.inf
   126       416         52.0      0.1      0.0              best_position = None
   127     87152      13081.1      0.2     10.5              for i in range(len(path)):
   128     86736      20877.8      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      65383.4      0.8     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17338.5      0.2     13.9                  if increase < best_increase:
   131      8051       1155.2      0.1      0.9                      best_increase = increase
   132      8051       1229.6      0.2      1.0                      best_position = next_i
   133                                           
   134       416        136.0      0.3      0.1              path.insert(best_position, to_insert)
   135       416        111.7      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        213.7    213.7      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1692257933794399

[('fl417', 1.1692257933794399)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124301 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4820.7   4820.7      3.9          distances = np.array(self.adj)
   115         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         60.2     60.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        418.6    418.6      0.3          random.shuffle(notInPath)
   119                                           
   120       417        120.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         80.6      0.2      0.1              best_increase = np.inf
   126       416         55.8      0.1      0.0              best_position = None
   127     87152      13871.8      0.2     11.2              for i in range(len(path)):
   128     86736      20071.0      0.2     16.1                  next_i = (i + 1) % len(path)
   129     86736      64922.9      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17059.7      0.2     13.7                  if increase < best_increase:
   131      7637       1070.0      0.1      0.9                      best_increase = increase
   132      7637       1233.2      0.2      1.0                      best_position = next_i
   133                                           
   134       416        130.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        110.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        191.9    191.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1052922596953023

[('fl417', 1.1052922596953023)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.123276 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4890.1   4890.1      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         35.4     35.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        406.8    406.8      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.0      0.2      0.1              best_increase = np.inf
   126       416         49.3      0.1      0.0              best_position = None
   127     87152      14187.1      0.2     11.5              for i in range(len(path)):
   128     86736      20536.6      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      64522.9      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15514.8      0.2     12.6                  if increase < best_increase:
   131      8589       1200.3      0.1      1.0                      best_increase = increase
   132      8589       1188.1      0.1      1.0                      best_position = next_i
   133                                           
   134       416        136.8      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        231.5    231.5      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0668250203895098

[('fl417', 1.0668250203895098)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.127183 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4833.5   4833.5      3.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.4      0.4      0.0          in_path = {0}
   117         1         36.1     36.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        414.9    414.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        115.4      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.5      0.2      0.1              best_increase = np.inf
   126       416         56.9      0.1      0.0              best_position = None
   127     87152      12962.4      0.1     10.2              for i in range(len(path)):
   128     86736      19798.2      0.2     15.6                  next_i = (i + 1) % len(path)
   129     86736      69012.5      0.8     54.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17127.8      0.2     13.5                  if increase < best_increase:
   131      7514       1010.2      0.1      0.8                      best_increase = increase
   132      7514       1187.4      0.2      0.9                      best_position = next_i
   133                                           
   134       416        141.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        106.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.5      2.5      0.0          self.tour = path
   138         1        217.4    217.4      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0806189706713456

[('fl417', 1.0806189706713456)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122226 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4800.7   4800.7      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         36.5     36.5      0.0          notInPath = [x for x in range(1, n)]
   118         1        408.5    408.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        125.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.3      0.2      0.1              best_increase = np.inf
   126       416         71.6      0.2      0.1              best_position = None
   127     87152      13582.1      0.2     11.1              for i in range(len(path)):
   128     86736      20378.5      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      63504.6      0.7     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16474.1      0.2     13.5                  if increase < best_increase:
   131      7842       1019.8      0.1      0.8                      best_increase = increase
   132      7842       1242.3      0.2      1.0                      best_position = next_i
   133                                           
   134       416        126.2      0.3      0.1              path.insert(best_position, to_insert)
   135       416        107.8      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        186.0    186.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0854531528228428

[('fl417', 1.0854531528228428)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.1284 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.9      0.9      0.0          n = self.numCity
   114         1       5032.8   5032.8      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         36.4     36.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        419.5    419.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        123.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         84.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         99.4      0.2      0.1              best_increase = np.inf
   126       416         56.1      0.1      0.0              best_position = None
   127     87152      13882.5      0.2     10.8              for i in range(len(path)):
   128     86736      20932.3      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      65668.8      0.8     51.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      18976.3      0.2     14.8                  if increase < best_increase:
   131      8000       1150.4      0.1      0.9                      best_increase = increase
   132      8000       1455.2      0.2      1.1                      best_position = next_i
   133                                           
   134       416        138.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        116.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.4      2.4      0.0          self.tour = path
   138         1        222.9    222.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1413718014582395

[('fl417', 1.1413718014582395)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122488 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4856.1   4856.1      4.0          distances = np.array(self.adj)
   115         1         15.8     15.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         45.8     45.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        429.4    429.4      0.4          random.shuffle(notInPath)
   119                                           
   120       417        108.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         82.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         78.0      0.2      0.1              best_increase = np.inf
   126       416         60.8      0.1      0.0              best_position = None
   127     87152      14054.0      0.2     11.5              for i in range(len(path)):
   128     86736      20326.2      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      64363.9      0.7     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15374.1      0.2     12.6                  if increase < best_increase:
   131      8134       1116.1      0.1      0.9                      best_increase = increase
   132      8134       1138.4      0.1      0.9                      best_position = next_i
   133                                           
   134       416        127.1      0.3      0.1              path.insert(best_position, to_insert)
   135       416        103.3      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        204.2    204.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0888966040231909

[('fl417', 1.0888966040231909)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124598 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4886.5   4886.5      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         31.6     31.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        416.5    416.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         82.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.5      0.2      0.1              best_increase = np.inf
   126       416         51.9      0.1      0.0              best_position = None
   127     87152      13161.5      0.2     10.6              for i in range(len(path)):
   128     86736      19522.5      0.2     15.7                  next_i = (i + 1) % len(path)
   129     86736      66683.2      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      17026.1      0.2     13.7                  if increase < best_increase:
   131      7350       1019.8      0.1      0.8                      best_increase = increase
   132      7350       1081.5      0.1      0.9                      best_position = next_i
   133                                           
   134       416        133.4      0.3      0.1              path.insert(best_position, to_insert)
   135       416        108.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.1      2.1      0.0          self.tour = path
   138         1        200.0    200.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0544985561326083

[('fl417', 1.0544985561326083)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121959 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4699.2   4699.2      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.1     31.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        416.9    416.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        108.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         99.5      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         73.6      0.2      0.1              best_increase = np.inf
   126       416         48.5      0.1      0.0              best_position = None
   127     87152      13516.1      0.2     11.1              for i in range(len(path)):
   128     86736      20594.7      0.2     16.9                  next_i = (i + 1) % len(path)
   129     86736      64636.7      0.7     53.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15082.1      0.2     12.4                  if increase < best_increase:
   131      8083       1097.8      0.1      0.9                      best_increase = increase
   132      8083       1103.9      0.1      0.9                      best_position = next_i
   133                                           
   134       416        125.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.0      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        217.2    217.2      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0532518869747536

[('fl417', 1.0532518869747536)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.1227 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4769.1   4769.1      3.9          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.3     35.3      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.9    407.9      0.3          random.shuffle(notInPath)
   119                                           
   120       417        108.8      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         79.7      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         82.4      0.2      0.1              best_increase = np.inf
   126       416         52.1      0.1      0.0              best_position = None
   127     87152      12506.7      0.1     10.2              for i in range(len(path)):
   128     86736      20419.7      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      65550.8      0.8     53.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16032.4      0.2     13.1                  if increase < best_increase:
   131      7744       1039.7      0.1      0.8                      best_increase = increase
   132      7744       1162.8      0.2      0.9                      best_position = next_i
   133                                           
   134       416        139.3      0.3      0.1              path.insert(best_position, to_insert)
   135       416        108.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        201.3    201.3      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0801220748181286

[('fl417', 1.0801220748181286)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121531 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.5      0.5      0.0          n = self.numCity
   114         1       4810.6   4810.6      4.0          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         34.1     34.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.7    407.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        105.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.1      0.2      0.1              best_increase = np.inf
   126       416         56.1      0.1      0.0              best_position = None
   127     87152      13816.2      0.2     11.4              for i in range(len(path)):
   128     86736      20351.4      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      62808.5      0.7     51.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16486.2      0.2     13.6                  if increase < best_increase:
   131      6967        932.8      0.1      0.8                      best_increase = increase
   132      6967       1127.1      0.2      0.9                      best_position = next_i
   133                                           
   134       416        123.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        114.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        195.0    195.0      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0905090169864677

[('fl417', 1.0905090169864677)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.121152 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          1.3      1.3      0.0          n = self.numCity
   114         1       5163.5   5163.5      4.3          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.7     35.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        401.1    401.1      0.3          random.shuffle(notInPath)
   119                                           
   120       417        109.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         77.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416        100.6      0.2      0.1              best_increase = np.inf
   126       416         51.9      0.1      0.0              best_position = None
   127     87152      12028.9      0.1      9.9              for i in range(len(path)):
   128     86736      19688.4      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      64677.0      0.7     53.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16367.8      0.2     13.5                  if increase < best_increase:
   131      7470        927.9      0.1      0.8                      best_increase = increase
   132      7470       1102.2      0.1      0.9                      best_position = next_i
   133                                           
   134       416        128.6      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.4      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        181.6    181.6      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.136961089972282

[('fl417', 1.136961089972282)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122477 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4915.4   4915.4      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.4     31.4      0.0          notInPath = [x for x in range(1, n)]
   118         1        442.5    442.5      0.4          random.shuffle(notInPath)
   119                                           
   120       417        106.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         87.6      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         76.9      0.2      0.1              best_increase = np.inf
   126       416         55.5      0.1      0.0              best_position = None
   127     87152      13277.3      0.2     10.8              for i in range(len(path)):
   128     86736      20448.2      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      64602.3      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16019.7      0.2     13.1                  if increase < best_increase:
   131      7114        875.2      0.1      0.7                      best_increase = increase
   132      7114       1092.5      0.2      0.9                      best_position = next_i
   133                                           
   134       416        129.7      0.3      0.1              path.insert(best_position, to_insert)
   135       416        105.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.3      2.3      0.0          self.tour = path
   138         1        206.9    206.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0555323010261513

[('fl417', 1.0555323010261513)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.126924 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       4878.4   4878.4      3.8          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         35.9     35.9      0.0          notInPath = [x for x in range(1, n)]
   118         1        442.7    442.7      0.3          random.shuffle(notInPath)
   119                                           
   120       417        109.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         75.2      0.2      0.1              best_increase = np.inf
   126       416         52.9      0.1      0.0              best_position = None
   127     87152      12285.9      0.1      9.7              for i in range(len(path)):
   128     86736      20163.4      0.2     15.9                  next_i = (i + 1) % len(path)
   129     86736      69446.1      0.8     54.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16386.8      0.2     12.9                  if increase < best_increase:
   131      8570       1212.0      0.1      1.0                      best_increase = increase
   132      8570       1310.6      0.2      1.0                      best_position = next_i
   133                                           
   134       416        129.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        101.7      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.9      1.9      0.0          self.tour = path
   138         1        210.1    210.1      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0789545455396734

[('fl417', 1.0789545455396734)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122562 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4972.5   4972.5      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         30.7     30.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        406.0    406.0      0.3          random.shuffle(notInPath)
   119                                           
   120       417        107.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         77.6      0.2      0.1              best_increase = np.inf
   126       416         50.7      0.1      0.0              best_position = None
   127     87152      14230.2      0.2     11.6              for i in range(len(path)):
   128     86736      20472.3      0.2     16.7                  next_i = (i + 1) % len(path)
   129     86736      64552.9      0.7     52.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      15134.4      0.2     12.3                  if increase < best_increase:
   131      7239        979.7      0.1      0.8                      best_increase = increase
   132      7239       1011.0      0.1      0.8                      best_position = next_i
   133                                           
   134       416        123.9      0.3      0.1              path.insert(best_position, to_insert)
   135       416        129.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.5      1.5      0.0          self.tour = path
   138         1        198.9    198.9      0.2          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1035372089480842

[('fl417', 1.1035372089480842)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.124507 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       4717.2   4717.2      3.8          distances = np.array(self.adj)
   115         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         36.7     36.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        420.5    420.5      0.3          random.shuffle(notInPath)
   119                                           
   120       417        111.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         81.9      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         84.4      0.2      0.1              best_increase = np.inf
   126       416         52.9      0.1      0.0              best_position = None
   127     87152      13469.9      0.2     10.8              for i in range(len(path)):
   128     86736      20654.3      0.2     16.6                  next_i = (i + 1) % len(path)
   129     86736      65475.9      0.8     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16625.9      0.2     13.4                  if increase < best_increase:
   131      7993       1138.1      0.1      0.9                      best_increase = increase
   132      7993       1198.3      0.1      1.0                      best_position = next_i
   133                                           
   134       416        136.0      0.3      0.1              path.insert(best_position, to_insert)
   135       416        114.3      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.6      1.6      0.0          self.tour = path
   138         1        186.1    186.1      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1034766920007122

[('fl417', 1.1034766920007122)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.122574 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       4781.6   4781.6      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.7      0.7      0.0          in_path = {0}
   117         1         35.0     35.0      0.0          notInPath = [x for x in range(1, n)]
   118         1        455.8    455.8      0.4          random.shuffle(notInPath)
   119                                           
   120       417        111.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       416         80.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       416         90.2      0.2      0.1              best_increase = np.inf
   126       416         55.5      0.1      0.0              best_position = None
   127     87152      14173.7      0.2     11.6              for i in range(len(path)):
   128     86736      19927.2      0.2     16.3                  next_i = (i + 1) % len(path)
   129     86736      64155.5      0.7     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     86736      16335.8      0.2     13.3                  if increase < best_increase:
   131      6690        898.8      0.1      0.7                      best_increase = increase
   132      6690       1014.2      0.2      0.8                      best_position = next_i
   133                                           
   134       416        137.5      0.3      0.1              path.insert(best_position, to_insert)
   135       416        104.6      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        213.2    213.2      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1458973386498135

[('pcb442', 1.1458973386498135)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.138179 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5728.1   5728.1      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         31.7     31.7      0.0          notInPath = [x for x in range(1, n)]
   118         1        438.7    438.7      0.3          random.shuffle(notInPath)
   119                                           
   120       442        117.9      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         89.0      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         82.1      0.2      0.1              best_increase = np.inf
   126       441         58.7      0.1      0.0              best_position = None
   127     97902      14475.6      0.1     10.5              for i in range(len(path)):
   128     97461      22091.0      0.2     16.0                  next_i = (i + 1) % len(path)
   129     97461      73146.6      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      18880.8      0.2     13.7                  if increase < best_increase:
   131      8741       1216.7      0.1      0.9                      best_increase = increase
   132      8741       1351.3      0.2      1.0                      best_position = next_i
   133                                           
   134       441        142.1      0.3      0.1              path.insert(best_position, to_insert)
   135       441        114.2      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.2      2.2      0.0          self.tour = path
   138         1        210.4    210.4      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.153392371626557

[('pcb442', 1.153392371626557)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.13554 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5421.5   5421.5      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         35.6     35.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        435.8    435.8      0.3          random.shuffle(notInPath)
   119                                           
   120       442        114.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         89.8      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         79.2      0.2      0.1              best_increase = np.inf
   126       441         56.8      0.1      0.0              best_position = None
   127     97902      14568.9      0.1     10.7              for i in range(len(path)):
   128     97461      22187.2      0.2     16.4                  next_i = (i + 1) % len(path)
   129     97461      71038.6      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      18508.7      0.2     13.7                  if increase < best_increase:
   131      9075       1219.3      0.1      0.9                      best_increase = increase
   132      9075       1312.7      0.1      1.0                      best_position = next_i
   133                                           
   134       441        135.6      0.3      0.1              path.insert(best_position, to_insert)
   135       441        113.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        218.6    218.6      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1569986716164025

[('pcb442', 1.1569986716164025)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.140149 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       5718.5   5718.5      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         40.2     40.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        444.1    444.1      0.3          random.shuffle(notInPath)
   119                                           
   120       442        114.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         88.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         82.0      0.2      0.1              best_increase = np.inf
   126       441         58.6      0.1      0.0              best_position = None
   127     97902      15751.7      0.2     11.2              for i in range(len(path)):
   128     97461      22791.8      0.2     16.3                  next_i = (i + 1) % len(path)
   129     97461      73645.9      0.8     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      18376.9      0.2     13.1                  if increase < best_increase:
   131      8995       1222.6      0.1      0.9                      best_increase = increase
   132      8995       1336.5      0.1      1.0                      best_position = next_i
   133                                           
   134       441        138.3      0.3      0.1              path.insert(best_position, to_insert)
   135       441        116.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.4      2.4      0.0          self.tour = path
   138         1        218.9    218.9      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1413192323383454

[('pcb442', 1.1413192323383454)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.140333 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       5365.1   5365.1      3.8          distances = np.array(self.adj)
   115         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.6      0.6      0.0          in_path = {0}
   117         1         31.2     31.2      0.0          notInPath = [x for x in range(1, n)]
   118         1        459.9    459.9      0.3          random.shuffle(notInPath)
   119                                           
   120       442        120.2      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         85.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         86.1      0.2      0.1              best_increase = np.inf
   126       441         58.8      0.1      0.0              best_position = None
   127     97902      15557.5      0.2     11.1              for i in range(len(path)):
   128     97461      24231.5      0.2     17.3                  next_i = (i + 1) % len(path)
   129     97461      72293.7      0.7     51.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      18931.3      0.2     13.5                  if increase < best_increase:
   131      8805       1221.8      0.1      0.9                      best_increase = increase
   132      8805       1411.5      0.2      1.0                      best_position = next_i
   133                                           
   134       441        136.6      0.3      0.1              path.insert(best_position, to_insert)
   135       441        114.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        223.2    223.2      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.138859926137181

[('pcb442', 1.138859926137181)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.137551 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5413.4   5413.4      3.9          distances = np.array(self.adj)
   115         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.2      1.2      0.0          in_path = {0}
   117         1         31.1     31.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        407.5    407.5      0.3          random.shuffle(notInPath)
   119                                           
   120       442        118.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         84.2      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         86.1      0.2      0.1              best_increase = np.inf
   126       441         55.7      0.1      0.0              best_position = None
   127     97902      15071.5      0.2     11.0              for i in range(len(path)):
   128     97461      22520.9      0.2     16.4                  next_i = (i + 1) % len(path)
   129     97461      72067.1      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      18122.5      0.2     13.2                  if increase < best_increase:
   131     10808       1510.0      0.1      1.1                      best_increase = increase
   132     10808       1579.5      0.1      1.1                      best_position = next_i
   133                                           
   134       441        150.6      0.3      0.1              path.insert(best_position, to_insert)
   135       441        108.0      0.2      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        220.7    220.7      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1501809277658155

[('pcb442', 1.1501809277658155)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.140675 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.8      0.8      0.0          n = self.numCity
   114         1       5595.5   5595.5      4.0          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          1.1      1.1      0.0          in_path = {0}
   117         1         31.6     31.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        425.5    425.5      0.3          random.shuffle(notInPath)
   119                                           
   120       442        120.7      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         82.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         79.5      0.2      0.1              best_increase = np.inf
   126       441         50.2      0.1      0.0              best_position = None
   127     97902      15120.3      0.2     10.7              for i in range(len(path)):
   128     97461      23014.7      0.2     16.4                  next_i = (i + 1) % len(path)
   129     97461      73145.8      0.8     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      19544.5      0.2     13.9                  if increase < best_increase:
   131     10964       1451.3      0.1      1.0                      best_increase = increase
   132     10964       1554.2      0.1      1.1                      best_position = next_i
   133                                           
   134       441        138.3      0.3      0.1              path.insert(best_position, to_insert)
   135       441        110.7      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        205.5    205.5      0.1          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1414899287631433

[('pcb442', 1.1414899287631433)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.13728 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5740.9   5740.9      4.2          distances = np.array(self.adj)
   115         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         31.8     31.8      0.0          notInPath = [x for x in range(1, n)]
   118         1        435.8    435.8      0.3          random.shuffle(notInPath)
   119                                           
   120       442        135.1      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         84.3      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         83.2      0.2      0.1              best_increase = np.inf
   126       441         58.0      0.1      0.0              best_position = None
   127     97902      15212.6      0.2     11.1              for i in range(len(path)):
   128     97461      21339.9      0.2     15.5                  next_i = (i + 1) % len(path)
   129     97461      72635.2      0.7     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      18515.0      0.2     13.5                  if increase < best_increase:
   131      8599       1173.4      0.1      0.9                      best_increase = increase
   132      8599       1322.0      0.2      1.0                      best_position = next_i
   133                                           
   134       441        142.9      0.3      0.1              path.insert(best_position, to_insert)
   135       441        142.5      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.8      1.8      0.0          self.tour = path
   138         1        223.7    223.7      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1426695538305915

[('pcb442', 1.1426695538305915)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.137254 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.7      0.7      0.0          n = self.numCity
   114         1       5531.3   5531.3      4.0          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.5      0.5      0.0          in_path = {0}
   117         1         31.1     31.1      0.0          notInPath = [x for x in range(1, n)]
   118         1        443.7    443.7      0.3          random.shuffle(notInPath)
   119                                           
   120       442        116.6      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         82.4      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         80.8      0.2      0.1              best_increase = np.inf
   126       441         50.1      0.1      0.0              best_position = None
   127     97902      14973.3      0.2     10.9              for i in range(len(path)):
   128     97461      22512.0      0.2     16.4                  next_i = (i + 1) % len(path)
   129     97461      73235.9      0.8     53.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      17072.7      0.2     12.4                  if increase < best_increase:
   131      9626       1292.0      0.1      0.9                      best_increase = increase
   132      9626       1367.1      0.1      1.0                      best_position = next_i
   133                                           
   134       441        138.2      0.3      0.1              path.insert(best_position, to_insert)
   135       441        112.1      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          2.0      2.0      0.0          self.tour = path
   138         1        211.0    211.0      0.2          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1331945332512297

[('pcb442', 1.1331945332512297)]
1
Wrote profile results to testRandom.py.lprof
Timer unit: 1e-06 s

Total time: 0.137137 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113         1          0.6      0.6      0.0          n = self.numCity
   114         1       5587.8   5587.8      4.1          distances = np.array(self.adj)
   115         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   116         1          0.8      0.8      0.0          in_path = {0}
   117         1         31.6     31.6      0.0          notInPath = [x for x in range(1, n)]
   118         1        413.9    413.9      0.3          random.shuffle(notInPath)
   119                                           
   120       442        114.5      0.3      0.1          while len(path) < n:
   121                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   122       441         87.1      0.2      0.1              to_insert = notInPath.pop()
   123                                           
   124                                                       # Trova la posizione ottimale per inserire la città trovata
   125       441         82.6      0.2      0.1              best_increase = np.inf
   126       441         57.3      0.1      0.0              best_position = None
   127     97902      15306.2      0.2     11.2              for i in range(len(path)):
   128     97461      22442.9      0.2     16.4                  next_i = (i + 1) % len(path)
   129     97461      71588.0      0.7     52.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   130     97461      17837.5      0.2     13.0                  if increase < best_increase:
   131     10977       1500.3      0.1      1.1                      best_increase = increase
   132     10977       1641.4      0.1      1.2                      best_position = next_i
   133                                           
   134       441        130.9      0.3      0.1              path.insert(best_position, to_insert)
   135       441        111.9      0.3      0.1              in_path.add(to_insert)
   136                                           
   137         1          1.7      1.7      0.0          self.tour = path
   138         1        199.5    199.5      0.1          self.calculateCost()

