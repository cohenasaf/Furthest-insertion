
Optimal 15780
_________________
d198
randomInsertion 1.0430734905725836
nearestInsertion 1.1360454545949497
cheapestInsertion 1.115192865965115
nearestNeighbor 1.2180456604337535
farthestInsertion 1.0302623546152974
furthestInsertion 1.0617900495472332

[('d198', 1.0430734905725836, 1.1360454545949497, 1.115192865965115, 1.2180456604337535, 1.0302623546152974, 1.0617900495472332)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.029511 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.9      0.9      0.0          n = self.numCity
   103         1       1810.3   1810.3      6.1          distances = np.array(self.adj)
   104         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.2      1.2      0.0          in_path = {0}
   106         1         18.7     18.7      0.1          notInPath = [x for x in range(1, n)]
   107         1        206.5    206.5      0.7          random.shuffle(notInPath)
   108                                           
   109       198         55.5      0.3      0.2          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111       197         41.1      0.2      0.1              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114       197         37.6      0.2      0.1              best_increase = np.inf
   115       197         26.0      0.1      0.1              best_position = None
   116     19700       3140.9      0.2     10.6              for i in range(len(path)):
   117     19503       4417.8      0.2     15.0                  next_i = (i + 1) % len(path)
   118     19503      14953.3      0.8     50.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119     19503       3737.9      0.2     12.7                  if increase < best_increase:
   120      3048        408.1      0.1      1.4                      best_increase = increase
   121      3048        469.0      0.2      1.6                      best_position = next_i
   122                                           
   123       197         59.4      0.3      0.2              path.insert(best_position, to_insert)
   124       197         49.8      0.3      0.2              in_path.add(to_insert)
   125                                           
   126         1          0.9      0.9      0.0          self.tour = path
   127         1         75.4     75.4      0.3          self.calculateCost()

Total time: 0.00969785 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          0.7      0.7      0.0          self.tour = [0]
   132         1          0.9      0.9      0.0          visited = set([0])
   133         1          5.6      5.6      0.1          notVisited = set(range(1, self.numCity))
   134       198         79.2      0.4      0.8          while len(self.tour) < self.numCity:
   135       197         34.8      0.2      0.4              cost = np.inf
   136       197         26.1      0.1      0.3              j = -1
   137     19700       3124.1      0.2     32.2              for j2 in notVisited:
   138     19503       5692.3      0.3     58.7                  if self.adj[self.tour[-1]][j2] < cost:
   139      1347        316.3      0.2      3.3                      cost = self.adj[self.tour[-1]][j2]
   140      1347        208.4      0.2      2.1                      j = j2
   141       197         48.9      0.2      0.5              self.tour.append(j)
   142       197         42.4      0.2      0.4              visited.add(j)
   143       197         43.7      0.2      0.5              notVisited.remove(j)
   144         1         74.3     74.3      0.8          self.calculateCost()

Total time: 0.0427447 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.4      0.4      0.0          n = self.numCity
   149         1       1068.0   1068.0      2.5          distances = np.array(self.adj)
   150         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          0.4      0.4      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156       198         28.3      0.1      0.1          for i in range(1, n):
   157       197        234.3      1.2      0.5              h.append((distances[0, i], i))
   158         1         14.8     14.8      0.0          heapq.heapify(h)
   159                                           
   160       198         55.0      0.3      0.1          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162       197        108.8      0.6      0.3              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165       197         38.0      0.2      0.1              best_increase = np.inf
   166       197         27.9      0.1      0.1              best_position = None
   167     19700       2886.8      0.1      6.8              for i in range(len(path)):
   168     19503       4214.8      0.2      9.9                  next_i = (i + 1) % len(path)
   169     19503      14631.9      0.8     34.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170     19503       3548.2      0.2      8.3                  if increase < best_increase:
   171      4358        577.8      0.1      1.4                      best_increase = increase
   172      4358        770.2      0.2      1.8                      best_position = i + 1
   173                                           
   174       197         59.9      0.3      0.1              path.insert(best_position, to_insert)
   175       197         46.6      0.2      0.1              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178     19503       3948.6      0.2      9.2              for i, (cost, node) in enumerate(h):
   179     19306       6559.7      0.3     15.3                  if node not in in_path and distances[to_insert, node] < cost:
   180      7925       2537.5      0.3      5.9                      h[i] = (distances[to_insert, node], node)
   181       197       1310.7      6.7      3.1              heapq.heapify(h)
   182                                           
   183         1          0.6      0.6      0.0          self.tour = path
   184         1         74.4     74.4      0.2          self.calculateCost()

Total time: 0.110038 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.4      0.4      0.0          n = self.numCity
   189         1        963.3    963.3      0.9          adj = np.array(self.adj)
   190         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          0.4      0.4      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195       198         28.4      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197       197        115.7      0.6      0.1              cost = adj[0][i] + adj[i][0]
   198       197         78.7      0.4      0.1              h.append((cost, i, 0, 0))
   199         1         13.6     13.6      0.0          heapq.heapify(h)
   200                                           
   201       198         61.4      0.3      0.1          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203       197        121.0      0.6      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206       197         41.8      0.2      0.0              best_increase = np.inf
   207       197         27.0      0.1      0.0              best_pos = None
   208     19700       2993.9      0.2      2.7              for i in range(len(path)):
   209     19503       4274.7      0.2      3.9                  next_i = (i + 1) % len(path)
   210     19503      14427.0      0.7     13.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211     19503       3600.1      0.2      3.3                  if increase < best_increase:
   212      5184        699.0      0.1      0.6                      best_increase = increase
   213      5184        787.2      0.2      0.7                      best_pos = next_i
   214                                           
   215       197         60.4      0.3      0.1              path.insert(best_pos, to_ins)
   216       197         48.5      0.2      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221     19503       4822.4      0.2      4.4              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223     19306       7036.4      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       177         33.0      0.2      0.0                      best_cost = np.inf
   225       177         26.7      0.2      0.0                      posL, posR = -1, -1
   226      1923        334.2      0.2      0.3                      for i2 in range(len(path)):
   227      1746        388.8      0.2      0.4                          next_i = (i2 + 1) % len(path)
   228      1746       1565.2      0.9      1.4                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229      1746        317.8      0.2      0.3                          if best_cost > insertion_cost:
   230       713        160.8      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       177         40.6      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234     19306      22932.3      1.2     20.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235      5845       6240.5      1.1      5.7                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236      5845       2098.0      0.4      1.9                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239      5845       1331.6      0.2      1.2                      best_pos = (best_pos + 1) % (len(path))
   240     19306      23367.2      1.2     21.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241      6460       6929.8      1.1      6.3                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242      6460       2654.8      0.4      2.4                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243       197       1339.0      6.8      1.2              heapq.heapify(h)
   244                                           
   245         1          0.7      0.7      0.0          self.tour = path
   246         1         75.6     75.6      0.1          self.calculateCost()

Total time: 0.0455682 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1       1041.0   1041.0      2.3          distances = np.array(self.adj)
   252         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          0.4      0.4      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.2      0.2      0.0          h = []
   257       198         29.0      0.1      0.1          for i in range(1, n):
   258       197         75.7      0.4      0.2              h.append((-distances[0, i], i))
   259         1         10.3     10.3      0.0          heapq.heapify(h)
   260                                           
   261       198         56.0      0.3      0.1          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263       197        111.8      0.6      0.2              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266       197         41.5      0.2      0.1              best_increase = np.inf
   267       197         26.4      0.1      0.1              best_position = None
   268     19700       3058.6      0.2      6.7              for i in range(len(path)):
   269     19503       4264.0      0.2      9.4                  next_i = (i + 1) % len(path)
   270     19503      14391.4      0.7     31.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271     19503       3745.1      0.2      8.2                  if increase < best_increase:
   272      4017        523.1      0.1      1.1                      best_increase = increase
   273      4017        744.2      0.2      1.6                      best_position = i + 1
   274                                           
   275       197         58.2      0.3      0.1              path.insert(best_position, to_insert)
   276       197         41.4      0.2      0.1              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279     19503       4272.6      0.2      9.4              for i, (cost, node) in enumerate(h):
   280     19306       4389.3      0.2      9.6                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282     19306       6976.9      0.4     15.3                  if node not in in_path and distances[to_insert, node] < cost:
   283       913        315.1      0.3      0.7                      h[i] = (-distances[to_insert, node], node)
   284       197       1304.1      6.6      2.9              heapq.heapify(h)
   285                                           
   286         1          0.6      0.6      0.0          self.tour = path
   287         1         90.5     90.5      0.2          self.calculateCost()

Total time: 0.100868 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.3      0.3      0.0          n = self.numCity
   292         1        958.9    958.9      1.0          adj = np.array(self.adj)
   293         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          0.3      0.3      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.1      0.1      0.0          h = []
   298       198         27.2      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300       197        116.3      0.6      0.1              cost = adj[0][i] + adj[i][0]
   301       197         54.0      0.3      0.1              h.append((-cost, i, 0, 0))
   302         1         10.4     10.4      0.0          heapq.heapify(h)
   303                                           
   304       198         63.0      0.3      0.1          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306       197        131.7      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309       197         42.9      0.2      0.0              best_increase = np.inf
   310       197         26.7      0.1      0.0              best_pos = None
   311     19700       2956.7      0.2      2.9              for i in range(len(path)):
   312     19503       4376.3      0.2      4.3                  next_i = (i + 1) % len(path)
   313     19503      14867.6      0.8     14.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314     19503       3645.8      0.2      3.6                  if increase < best_increase:
   315      2198        299.2      0.1      0.3                      best_increase = increase
   316      2198        358.0      0.2      0.4                      best_pos = next_i
   317                                           
   318       197         66.1      0.3      0.1              path.insert(best_pos, to_ins)
   319       197         48.8      0.2      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322     19503       4865.5      0.2      4.8              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323     19306       4430.5      0.2      4.4                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325     19306       7118.0      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       124         24.6      0.2      0.0                      best_cost = np.inf
   327       124         19.2      0.2      0.0                      posL, posR = -1, -1
   328      3744        569.3      0.2      0.6                      for i2 in range(len(path)):
   329      3620        854.6      0.2      0.8                          next_i = (i2 + 1) % len(path)
   330      3620       3312.3      0.9      3.3                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331      3620        654.1      0.2      0.6                          if best_cost > insertion_cost:
   332       542        124.3      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       124         34.0      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336     19306      23291.9      1.2     23.1                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337       324        351.7      1.1      0.3                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338       324        114.3      0.4      0.1                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341       324         75.9      0.2      0.1                      best_pos = (best_pos + 1) % (len(path))
   342     19306      24472.0      1.3     24.3                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343       705        772.3      1.1      0.8                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344       705        288.0      0.4      0.3                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345       197       1340.6      6.8      1.3              heapq.heapify(h)
   346                                           
   347         1          1.9      1.9      0.0          self.tour = path
   348         1        102.4    102.4      0.1          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.110143760793268
nearestInsertion 1.2443578764303436
cheapestInsertion 1.2418492656827038
nearestNeighbor 1.2856260385277645
farthestInsertion 1.0915020294829432
furthestInsertion 1.0998295205588327

[('lin318', 1.110143760793268, 1.2443578764303436, 1.2418492656827038, 1.2856260385277645, 1.0915020294829432, 1.0998295205588327)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.0705502 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.7      0.7      0.0          n = self.numCity
   103         1       2827.7   2827.7      4.0          distances = np.array(self.adj)
   104         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          0.4      0.4      0.0          in_path = {0}
   106         1         23.3     23.3      0.0          notInPath = [x for x in range(1, n)]
   107         1        301.8    301.8      0.4          random.shuffle(notInPath)
   108                                           
   109       318         83.8      0.3      0.1          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111       317         74.6      0.2      0.1              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114       317         62.4      0.2      0.1              best_increase = np.inf
   115       317         42.2      0.1      0.1              best_position = None
   116     50720       7778.3      0.2     11.0              for i in range(len(path)):
   117     50403      11516.2      0.2     16.3                  next_i = (i + 1) % len(path)
   118     50403      36732.1      0.7     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119     50403       9280.9      0.2     13.2                  if increase < best_increase:
   120      5310        728.3      0.1      1.0                      best_increase = increase
   121      5310        787.2      0.1      1.1                      best_position = next_i
   122                                           
   123       317         94.8      0.3      0.1              path.insert(best_position, to_insert)
   124       317         86.4      0.3      0.1              in_path.add(to_insert)
   125                                           
   126         1          1.0      1.0      0.0          self.tour = path
   127         1        127.7    127.7      0.2          self.calculateCost()

Total time: 0.0246123 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          1.5      1.5      0.0          self.tour = [0]
   132         1          1.2      1.2      0.0          visited = set([0])
   133         1          8.1      8.1      0.0          notVisited = set(range(1, self.numCity))
   134       318        105.0      0.3      0.4          while len(self.tour) < self.numCity:
   135       317         54.0      0.2      0.2              cost = np.inf
   136       317         41.4      0.1      0.2              j = -1
   137     50720       8153.4      0.2     33.1              for j2 in notVisited:
   138     50403      14956.8      0.3     60.8                  if self.adj[self.tour[-1]][j2] < cost:
   139      2415        573.8      0.2      2.3                      cost = self.adj[self.tour[-1]][j2]
   140      2415        347.2      0.1      1.4                      j = j2
   141       317         87.9      0.3      0.4              self.tour.append(j)
   142       317         73.6      0.2      0.3              visited.add(j)
   143       317         84.5      0.3      0.3              notVisited.remove(j)
   144         1        124.1    124.1      0.5          self.calculateCost()

Total time: 0.108441 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.9      0.9      0.0          n = self.numCity
   149         1       2742.8   2742.8      2.5          distances = np.array(self.adj)
   150         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          0.4      0.4      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156       318         44.1      0.1      0.0          for i in range(1, n):
   157       317        113.3      0.4      0.1              h.append((distances[0, i], i))
   158         1         22.5     22.5      0.0          heapq.heapify(h)
   159                                           
   160       318        111.0      0.3      0.1          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162       317        185.9      0.6      0.2              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165       317         82.8      0.3      0.1              best_increase = np.inf
   166       317         57.5      0.2      0.1              best_position = None
   167     50720       7624.7      0.2      7.0              for i in range(len(path)):
   168     50403      11132.0      0.2     10.3                  next_i = (i + 1) % len(path)
   169     50403      37531.8      0.7     34.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170     50403       9665.8      0.2      8.9                  if increase < best_increase:
   171      7768       1096.3      0.1      1.0                      best_increase = increase
   172      7768       1393.6      0.2      1.3                      best_position = i + 1
   173                                           
   174       317         99.3      0.3      0.1              path.insert(best_position, to_insert)
   175       317         90.3      0.3      0.1              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178     50403      10525.6      0.2      9.7              for i, (cost, node) in enumerate(h):
   179     50086      18082.4      0.4     16.7                  if node not in in_path and distances[to_insert, node] < cost:
   180     12624       4224.9      0.3      3.9                      h[i] = (distances[to_insert, node], node)
   181       317       3439.0     10.8      3.2              heapq.heapify(h)
   182                                           
   183         1          2.4      2.4      0.0          self.tour = path
   184         1        170.9    170.9      0.2          self.calculateCost()

Total time: 0.273109 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1       3058.6   3058.6      1.1          adj = np.array(self.adj)
   190         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.1      1.1      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.3      0.3      0.0          h = []
   195       318         45.5      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197       317        189.6      0.6      0.1              cost = adj[0][i] + adj[i][0]
   198       317        231.5      0.7      0.1              h.append((cost, i, 0, 0))
   199         1         21.5     21.5      0.0          heapq.heapify(h)
   200                                           
   201       318        109.0      0.3      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203       317        192.7      0.6      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206       317         69.8      0.2      0.0              best_increase = np.inf
   207       317         50.0      0.2      0.0              best_pos = None
   208     50720       7936.3      0.2      2.9              for i in range(len(path)):
   209     50403      11613.2      0.2      4.3                  next_i = (i + 1) % len(path)
   210     50403      37144.5      0.7     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211     50403      10004.8      0.2      3.7                  if increase < best_increase:
   212      7127       1008.3      0.1      0.4                      best_increase = increase
   213      7127       1155.4      0.2      0.4                      best_pos = next_i
   214                                           
   215       317        113.9      0.4      0.0              path.insert(best_pos, to_ins)
   216       317         89.6      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221     50403      11604.3      0.2      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223     50086      19269.7      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       370         70.8      0.2      0.0                      best_cost = np.inf
   225       370         54.9      0.1      0.0                      posL, posR = -1, -1
   226      7081       1165.5      0.2      0.4                      for i2 in range(len(path)):
   227      6711       1593.9      0.2      0.6                          next_i = (i2 + 1) % len(path)
   228      6711       6118.9      0.9      2.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229      6711       1292.9      0.2      0.5                          if best_cost > insertion_cost:
   230      1198        266.0      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       370         88.1      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234     50086      60655.8      1.2     22.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235      8597       9514.4      1.1      3.5                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236      8597       3263.7      0.4      1.2                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239      8597       2119.2      0.2      0.8                      best_pos = (best_pos + 1) % (len(path))
   240     50086      63506.4      1.3     23.3                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     10132      11345.0      1.1      4.2                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     10132       4538.5      0.4      1.7                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243       317       3448.3     10.9      1.3              heapq.heapify(h)
   244                                           
   245         1          1.6      1.6      0.0          self.tour = path
   246         1        154.5    154.5      0.1          self.calculateCost()

Total time: 0.116175 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.3      0.3      0.0          n = self.numCity
   251         1       2741.2   2741.2      2.4          distances = np.array(self.adj)
   252         1          0.3      0.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          0.6      0.6      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.2      0.2      0.0          h = []
   257       318         48.5      0.2      0.0          for i in range(1, n):
   258       317        127.2      0.4      0.1              h.append((-distances[0, i], i))
   259         1         16.6     16.6      0.0          heapq.heapify(h)
   260                                           
   261       318         98.4      0.3      0.1          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263       317        192.4      0.6      0.2              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266       317         67.2      0.2      0.1              best_increase = np.inf
   267       317         46.2      0.1      0.0              best_position = None
   268     50720       7882.2      0.2      6.8              for i in range(len(path)):
   269     50403      11567.1      0.2     10.0                  next_i = (i + 1) % len(path)
   270     50403      37925.5      0.8     32.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271     50403       9780.9      0.2      8.4                  if increase < best_increase:
   272      6008        833.9      0.1      0.7                      best_increase = increase
   273      6008       1154.7      0.2      1.0                      best_position = i + 1
   274                                           
   275       317        117.8      0.4      0.1              path.insert(best_position, to_insert)
   276       317         76.3      0.2      0.1              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279     50403      10483.1      0.2      9.0              for i, (cost, node) in enumerate(h):
   280     50086      10360.2      0.2      8.9                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282     50086      18541.5      0.4     16.0                  if node not in in_path and distances[to_insert, node] < cost:
   283      1256        494.3      0.4      0.4                      h[i] = (-distances[to_insert, node], node)
   284       317       3480.3     11.0      3.0              heapq.heapify(h)
   285                                           
   286         1          1.4      1.4      0.0          self.tour = path
   287         1        137.0    137.0      0.1          self.calculateCost()

Total time: 0.250024 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.4      0.4      0.0          n = self.numCity
   292         1       2608.6   2608.6      1.0          adj = np.array(self.adj)
   293         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          0.4      0.4      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.1      0.1      0.0          h = []
   298       318         45.0      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300       317        191.4      0.6      0.1              cost = adj[0][i] + adj[i][0]
   301       317         94.8      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         17.2     17.2      0.0          heapq.heapify(h)
   303                                           
   304       318        110.6      0.3      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306       317        205.0      0.6      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309       317         71.6      0.2      0.0              best_increase = np.inf
   310       317         45.0      0.1      0.0              best_pos = None
   311     50720       8041.8      0.2      3.2              for i in range(len(path)):
   312     50403      11739.7      0.2      4.7                  next_i = (i + 1) % len(path)
   313     50403      37161.6      0.7     14.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314     50403       9580.9      0.2      3.8                  if increase < best_increase:
   315      6045        908.8      0.2      0.4                      best_increase = increase
   316      6045        916.7      0.2      0.4                      best_pos = next_i
   317                                           
   318       317        113.4      0.4      0.0              path.insert(best_pos, to_ins)
   319       317         73.9      0.2      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322     50403      12034.1      0.2      4.8              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323     50086      10946.4      0.2      4.4                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325     50086      18466.8      0.4      7.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       177         33.2      0.2      0.0                      best_cost = np.inf
   327       177         27.2      0.2      0.0                      posL, posR = -1, -1
   328      6221        986.7      0.2      0.4                      for i2 in range(len(path)):
   329      6044       1386.4      0.2      0.6                          next_i = (i2 + 1) % len(path)
   330      6044       5364.9      0.9      2.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331      6044       1094.8      0.2      0.4                          if best_cost > insertion_cost:
   332       989        201.4      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       177         48.8      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336     50086      58677.0      1.2     23.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337       493        552.4      1.1      0.2                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338       493        193.6      0.4      0.1                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341       493        119.9      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342     50086      62932.1      1.3     25.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343       962       1107.9      1.2      0.4                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344       962        413.7      0.4      0.2                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345       317       3360.5     10.6      1.3              heapq.heapify(h)
   346                                           
   347         1          1.9      1.9      0.0          self.tour = path
   348         1        147.1    147.1      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.0877679073964512
nearestInsertion 1.2520395301379346
cheapestInsertion 1.2602859529310952
nearestNeighbor 1.2807590521365082
farthestInsertion 1.0812761498048593
furthestInsertion 1.088512900793671

[('fl417', 1.0877679073964512, 1.2520395301379346, 1.2602859529310952, 1.2807590521365082, 1.0812761498048593, 1.088512900793671)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.128746 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.7      0.7      0.0          n = self.numCity
   103         1       4747.8   4747.8      3.7          distances = np.array(self.adj)
   104         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          0.5      0.5      0.0          in_path = {0}
   106         1         34.1     34.1      0.0          notInPath = [x for x in range(1, n)]
   107         1        427.2    427.2      0.3          random.shuffle(notInPath)
   108                                           
   109       417        114.2      0.3      0.1          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111       416         85.0      0.2      0.1              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114       416         90.3      0.2      0.1              best_increase = np.inf
   115       416         55.0      0.1      0.0              best_position = None
   116     87152      13360.2      0.2     10.4              for i in range(len(path)):
   117     86736      21100.3      0.2     16.4                  next_i = (i + 1) % len(path)
   118     86736      68968.2      0.8     53.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119     86736      16862.2      0.2     13.1                  if increase < best_increase:
   120      8419       1139.2      0.1      0.9                      best_increase = increase
   121      8419       1266.3      0.2      1.0                      best_position = next_i
   122                                           
   123       416        145.9      0.4      0.1              path.insert(best_position, to_insert)
   124       416        120.1      0.3      0.1              in_path.add(to_insert)
   125                                           
   126         1          2.8      2.8      0.0          self.tour = path
   127         1        225.5    225.5      0.2          self.calculateCost()

Total time: 0.0420764 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          1.8      1.8      0.0          self.tour = [0]
   132         1          1.2      1.2      0.0          visited = set([0])
   133         1         11.6     11.6      0.0          notVisited = set(range(1, self.numCity))
   134       417        135.0      0.3      0.3          while len(self.tour) < self.numCity:
   135       416         76.6      0.2      0.2              cost = np.inf
   136       416         57.5      0.1      0.1              j = -1
   137     87152      13822.1      0.2     32.8              for j2 in notVisited:
   138     86736      26437.3      0.3     62.8                  if self.adj[self.tour[-1]][j2] < cost:
   139      2673        625.9      0.2      1.5                      cost = self.adj[self.tour[-1]][j2]
   140      2673        433.2      0.2      1.0                      j = j2
   141       416        116.8      0.3      0.3              self.tour.append(j)
   142       416         89.7      0.2      0.2              visited.add(j)
   143       416         93.0      0.2      0.2              notVisited.remove(j)
   144         1        174.6    174.6      0.4          self.calculateCost()

Total time: 0.185597 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.8      0.8      0.0          n = self.numCity
   149         1       5528.2   5528.2      3.0          distances = np.array(self.adj)
   150         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          0.7      0.7      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.4      0.4      0.0          h = []
   156       417         63.2      0.2      0.0          for i in range(1, n):
   157       416        577.0      1.4      0.3              h.append((distances[0, i], i))
   158         1         27.6     27.6      0.0          heapq.heapify(h)
   159                                           
   160       417        123.9      0.3      0.1          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162       416        242.4      0.6      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165       416         81.2      0.2      0.0              best_increase = np.inf
   166       416         53.4      0.1      0.0              best_position = None
   167     87152      13622.2      0.2      7.3              for i in range(len(path)):
   168     86736      20730.8      0.2     11.2                  next_i = (i + 1) % len(path)
   169     86736      66019.3      0.8     35.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170     86736      15874.8      0.2      8.6                  if increase < best_increase:
   171      9697       1407.2      0.1      0.8                      best_increase = increase
   172      9697       1793.8      0.2      1.0                      best_position = i + 1
   173                                           
   174       416        173.1      0.4      0.1              path.insert(best_position, to_insert)
   175       416        106.9      0.3      0.1              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178     86736      18283.7      0.2      9.9              for i, (cost, node) in enumerate(h):
   179     86320      29904.1      0.3     16.1                  if node not in in_path and distances[to_insert, node] < cost:
   180     15548       5007.0      0.3      2.7                      h[i] = (distances[to_insert, node], node)
   181       416       5787.3     13.9      3.1              heapq.heapify(h)
   182                                           
   183         1          2.2      2.2      0.0          self.tour = path
   184         1        185.3    185.3      0.1          self.calculateCost()

Total time: 0.480046 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.6      0.6      0.0          n = self.numCity
   189         1       4564.5   4564.5      1.0          adj = np.array(self.adj)
   190         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          0.5      0.5      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.3      0.3      0.0          h = []
   195       417         59.4      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197       416        246.9      0.6      0.1              cost = adj[0][i] + adj[i][0]
   198       416        128.7      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         25.8     25.8      0.0          heapq.heapify(h)
   200                                           
   201       417        142.8      0.3      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203       416        285.6      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206       416         86.3      0.2      0.0              best_increase = np.inf
   207       416         66.7      0.2      0.0              best_pos = None
   208     87152      13166.1      0.2      2.7              for i in range(len(path)):
   209     86736      22099.8      0.3      4.6                  next_i = (i + 1) % len(path)
   210     86736      66498.4      0.8     13.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211     86736      16957.9      0.2      3.5                  if increase < best_increase:
   212     10394       1387.0      0.1      0.3                      best_increase = increase
   213     10394       1610.4      0.2      0.3                      best_pos = next_i
   214                                           
   215       416        154.9      0.4      0.0              path.insert(best_pos, to_ins)
   216       416        115.3      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221     86736      19543.2      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223     86320      33430.1      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       346         61.7      0.2      0.0                      best_cost = np.inf
   225       346         55.9      0.2      0.0                      posL, posR = -1, -1
   226     13819       2258.7      0.2      0.5                      for i2 in range(len(path)):
   227     13473       3476.7      0.3      0.7                          next_i = (i2 + 1) % len(path)
   228     13473      12706.4      0.9      2.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229     13473       2578.0      0.2      0.5                          if best_cost > insertion_cost:
   230      1740        376.6      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       346         88.8      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234     86320     107958.1      1.3     22.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     14169      16355.7      1.2      3.4                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     14169       5532.8      0.4      1.2                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     14169       3330.6      0.2      0.7                      best_pos = (best_pos + 1) % (len(path))
   240     86320     113189.8      1.3     23.6                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     15927      18494.7      1.2      3.9                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     15927       7037.2      0.4      1.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243       416       5757.3     13.8      1.2              heapq.heapify(h)
   244                                           
   245         1          2.4      2.4      0.0          self.tour = path
   246         1        212.8    212.8      0.0          self.calculateCost()

Total time: 0.194682 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1       4908.8   4908.8      2.5          distances = np.array(self.adj)
   252         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          0.6      0.6      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.2      0.2      0.0          h = []
   257       417         56.2      0.1      0.0          for i in range(1, n):
   258       416        159.5      0.4      0.1              h.append((-distances[0, i], i))
   259         1         23.0     23.0      0.0          heapq.heapify(h)
   260                                           
   261       417        120.7      0.3      0.1          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263       416        245.5      0.6      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266       416         78.9      0.2      0.0              best_increase = np.inf
   267       416         52.3      0.1      0.0              best_position = None
   268     87152      12792.5      0.1      6.6              for i in range(len(path)):
   269     86736      20624.7      0.2     10.6                  next_i = (i + 1) % len(path)
   270     86736      66608.5      0.8     34.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271     86736      16068.4      0.2      8.3                  if increase < best_increase:
   272      7571        967.6      0.1      0.5                      best_increase = increase
   273      7571       1348.2      0.2      0.7                      best_position = i + 1
   274                                           
   275       416        143.9      0.3      0.1              path.insert(best_position, to_insert)
   276       416         86.1      0.2      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279     86736      16990.4      0.2      8.7              for i, (cost, node) in enumerate(h):
   280     86320      16774.8      0.2      8.6                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282     86320      30148.1      0.3     15.5                  if node not in in_path and distances[to_insert, node] < cost:
   283      1456        528.6      0.4      0.3                      h[i] = (-distances[to_insert, node], node)
   284       416       5777.5     13.9      3.0              heapq.heapify(h)
   285                                           
   286         1          1.9      1.9      0.0          self.tour = path
   287         1        174.2    174.2      0.1          self.calculateCost()

Total time: 0.475517 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1       4365.7   4365.7      0.9          adj = np.array(self.adj)
   293         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          0.4      0.4      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298       417         58.6      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300       416        245.5      0.6      0.1              cost = adj[0][i] + adj[i][0]
   301       416        124.6      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         21.9     21.9      0.0          heapq.heapify(h)
   303                                           
   304       417        139.7      0.3      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306       416        264.4      0.6      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309       416         87.8      0.2      0.0              best_increase = np.inf
   310       416         62.0      0.1      0.0              best_pos = None
   311     87152      12910.4      0.1      2.7              for i in range(len(path)):
   312     86736      21147.0      0.2      4.4                  next_i = (i + 1) % len(path)
   313     86736      64574.2      0.7     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314     86736      16138.6      0.2      3.4                  if increase < best_increase:
   315     10326       1320.4      0.1      0.3                      best_increase = increase
   316     10326       1525.8      0.1      0.3                      best_pos = next_i
   317                                           
   318       416        153.1      0.4      0.0              path.insert(best_pos, to_ins)
   319       416         97.8      0.2      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322     86736      20326.4      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323     86320      16909.6      0.2      3.6                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325     86320      31966.2      0.4      6.7                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       444         83.5      0.2      0.0                      best_cost = np.inf
   327       444         72.1      0.2      0.0                      posL, posR = -1, -1
   328     36449       5524.5      0.2      1.2                      for i2 in range(len(path)):
   329     36005       8826.1      0.2      1.9                          next_i = (i2 + 1) % len(path)
   330     36005      33328.5      0.9      7.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     36005       6630.4      0.2      1.4                          if best_cost > insertion_cost:
   332      5786       1216.0      0.2      0.3                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       444        122.8      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336     86320     105934.3      1.2     22.3                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337       685        813.1      1.2      0.2                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338       685        258.9      0.4      0.1                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341       685        169.6      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342     86320     111602.2      1.3     23.5                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      1526       1799.7      1.2      0.4                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      1526        657.7      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345       416       5830.9     14.0      1.2              heapq.heapify(h)
   346                                           
   347         1          1.9      1.9      0.0          self.tour = path
   348         1        203.2    203.2      0.0          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1479197807451416
nearestInsertion 1.1982723362653798
cheapestInsertion 1.21905297363948
nearestNeighbor 1.2206870545691801
farthestInsertion 1.1371343272562013
furthestInsertion 1.1251808980844065

[('pcb442', 1.1479197807451416, 1.1982723362653798, 1.21905297363948, 1.2206870545691801, 1.1371343272562013, 1.1251808980844065)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.137355 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.7      0.7      0.0          n = self.numCity
   103         1       5402.8   5402.8      3.9          distances = np.array(self.adj)
   104         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          0.7      0.7      0.0          in_path = {0}
   106         1         31.7     31.7      0.0          notInPath = [x for x in range(1, n)]
   107         1        415.3    415.3      0.3          random.shuffle(notInPath)
   108                                           
   109       442        123.8      0.3      0.1          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111       441         89.5      0.2      0.1              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114       441         84.9      0.2      0.1              best_increase = np.inf
   115       441         57.9      0.1      0.0              best_position = None
   116     97902      15023.4      0.2     10.9              for i in range(len(path)):
   117     97461      23049.7      0.2     16.8                  next_i = (i + 1) % len(path)
   118     97461      71286.3      0.7     51.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119     97461      18859.9      0.2     13.7                  if increase < best_increase:
   120      8346       1151.9      0.1      0.8                      best_increase = increase
   121      8346       1322.3      0.2      1.0                      best_position = next_i
   122                                           
   123       441        137.3      0.3      0.1              path.insert(best_position, to_insert)
   124       441        117.0      0.3      0.1              in_path.add(to_insert)
   125                                           
   126         1          1.6      1.6      0.0          self.tour = path
   127         1        197.6    197.6      0.1          self.calculateCost()

Total time: 0.0499873 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          2.7      2.7      0.0          self.tour = [0]
   132         1          1.8      1.8      0.0          visited = set([0])
   133         1         11.6     11.6      0.0          notVisited = set(range(1, self.numCity))
   134       442        156.2      0.4      0.3          while len(self.tour) < self.numCity:
   135       441         81.2      0.2      0.2              cost = np.inf
   136       441         56.1      0.1      0.1              j = -1
   137     97902      15753.0      0.2     31.5              for j2 in notVisited:
   138     97461      30829.2      0.3     61.7                  if self.adj[self.tour[-1]][j2] < cost:
   139      6469       1568.5      0.2      3.1                      cost = self.adj[self.tour[-1]][j2]
   140      6469        951.5      0.1      1.9                      j = j2
   141       441        137.1      0.3      0.3              self.tour.append(j)
   142       441        105.7      0.2      0.2              visited.add(j)
   143       441        102.0      0.2      0.2              notVisited.remove(j)
   144         1        230.7    230.7      0.5          self.calculateCost()

Total time: 0.234035 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.4      0.4      0.0          n = self.numCity
   149         1       5670.5   5670.5      2.4          distances = np.array(self.adj)
   150         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.2      1.2      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156       442         63.3      0.1      0.0          for i in range(1, n):
   157       441        685.7      1.6      0.3              h.append((distances[0, i], i))
   158         1         29.0     29.0      0.0          heapq.heapify(h)
   159                                           
   160       442        205.1      0.5      0.1          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162       441        343.2      0.8      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165       441        120.3      0.3      0.1              best_increase = np.inf
   166       441         70.8      0.2      0.0              best_position = None
   167     97902      16103.5      0.2      6.9              for i in range(len(path)):
   168     97461      25357.2      0.3     10.8                  next_i = (i + 1) % len(path)
   169     97461      83532.0      0.9     35.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170     97461      19669.7      0.2      8.4                  if increase < best_increase:
   171     11940       1895.2      0.2      0.8                      best_increase = increase
   172     11940       2455.0      0.2      1.0                      best_position = i + 1
   173                                           
   174       441        228.4      0.5      0.1              path.insert(best_position, to_insert)
   175       441        186.4      0.4      0.1              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178     97461      23524.6      0.2     10.1              for i, (cost, node) in enumerate(h):
   179     97020      39372.0      0.4     16.8                  if node not in in_path and distances[to_insert, node] < cost:
   180     17707       6479.0      0.4      2.8                      h[i] = (distances[to_insert, node], node)
   181       441       7769.1     17.6      3.3              heapq.heapify(h)
   182                                           
   183         1          4.8      4.8      0.0          self.tour = path
   184         1        267.5    267.5      0.1          self.calculateCost()

Total time: 0.539058 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.4      0.4      0.0          n = self.numCity
   189         1       6404.1   6404.1      1.2          adj = np.array(self.adj)
   190         1          1.5      1.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.2      1.2      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.9      0.9      0.0          h = []
   195       442         71.3      0.2      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197       441        281.6      0.6      0.1              cost = adj[0][i] + adj[i][0]
   198       441        143.7      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         32.4     32.4      0.0          heapq.heapify(h)
   200                                           
   201       442        179.4      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203       441        303.3      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206       441        104.9      0.2      0.0              best_increase = np.inf
   207       441         65.1      0.1      0.0              best_pos = None
   208     97902      15486.0      0.2      2.9              for i in range(len(path)):
   209     97461      23961.2      0.2      4.4                  next_i = (i + 1) % len(path)
   210     97461      76697.4      0.8     14.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211     97461      19130.2      0.2      3.5                  if increase < best_increase:
   212     14018       2000.2      0.1      0.4                      best_increase = increase
   213     14018       2120.7      0.2      0.4                      best_pos = next_i
   214                                           
   215       441        211.3      0.5      0.0              path.insert(best_pos, to_ins)
   216       441        135.9      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221     97461      24092.5      0.2      4.5              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223     97020      37540.8      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       455         90.4      0.2      0.0                      best_cost = np.inf
   225       455         77.2      0.2      0.0                      posL, posR = -1, -1
   226     18003       3097.4      0.2      0.6                      for i2 in range(len(path)):
   227     17548       4448.1      0.3      0.8                          next_i = (i2 + 1) % len(path)
   228     17548      16380.9      0.9      3.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229     17548       3322.5      0.2      0.6                          if best_cost > insertion_cost:
   230      3020        642.6      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       455        112.8      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234     97020     120099.9      1.2     22.3                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     14433      15600.7      1.1      2.9                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     14433       5535.2      0.4      1.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     14433       3583.6      0.2      0.7                      best_pos = (best_pos + 1) % (len(path))
   240     97020     124275.0      1.3     23.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     16284      18233.3      1.1      3.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     16284       7365.3      0.5      1.4                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243       441       6966.5     15.8      1.3              heapq.heapify(h)
   244                                           
   245         1          4.7      4.7      0.0          self.tour = path
   246         1        256.0    256.0      0.0          self.calculateCost()

Total time: 0.23641 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.6      0.6      0.0          n = self.numCity
   251         1       6532.5   6532.5      2.8          distances = np.array(self.adj)
   252         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.2      1.2      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.3      0.3      0.0          h = []
   257       442         68.5      0.2      0.0          for i in range(1, n):
   258       441        192.9      0.4      0.1              h.append((-distances[0, i], i))
   259         1         26.6     26.6      0.0          heapq.heapify(h)
   260                                           
   261       442        163.2      0.4      0.1          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263       441        311.7      0.7      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266       441        109.3      0.2      0.0              best_increase = np.inf
   267       441         66.9      0.2      0.0              best_position = None
   268     97902      15917.1      0.2      6.7              for i in range(len(path)):
   269     97461      23955.3      0.2     10.1                  next_i = (i + 1) % len(path)
   270     97461      77642.5      0.8     32.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271     97461      18759.0      0.2      7.9                  if increase < best_increase:
   272     11184       1524.1      0.1      0.6                      best_increase = increase
   273     11184       2178.6      0.2      0.9                      best_position = i + 1
   274                                           
   275       441        181.3      0.4      0.1              path.insert(best_position, to_insert)
   276       441        144.5      0.3      0.1              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279     97461      21049.4      0.2      8.9              for i, (cost, node) in enumerate(h):
   280     97020      21512.7      0.2      9.1                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282     97020      38216.2      0.4     16.2                  if node not in in_path and distances[to_insert, node] < cost:
   283      1614        610.4      0.4      0.3                      h[i] = (-distances[to_insert, node], node)
   284       441       7002.7     15.9      3.0              heapq.heapify(h)
   285                                           
   286         1          3.6      3.6      0.0          self.tour = path
   287         1        238.3    238.3      0.1          self.calculateCost()

Total time: 0.476703 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.4      0.4      0.0          n = self.numCity
   292         1       6031.3   6031.3      1.3          adj = np.array(self.adj)
   293         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.0      1.0      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298       442         63.4      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300       441        251.0      0.6      0.1              cost = adj[0][i] + adj[i][0]
   301       441        130.9      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         24.5     24.5      0.0          heapq.heapify(h)
   303                                           
   304       442        147.6      0.3      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306       441        292.9      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309       441         93.9      0.2      0.0              best_increase = np.inf
   310       441         60.1      0.1      0.0              best_pos = None
   311     97902      14650.3      0.1      3.1              for i in range(len(path)):
   312     97461      23233.4      0.2      4.9                  next_i = (i + 1) % len(path)
   313     97461      71560.7      0.7     15.0                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314     97461      17801.2      0.2      3.7                  if increase < best_increase:
   315     10150       1370.5      0.1      0.3                      best_increase = increase
   316     10150       1469.6      0.1      0.3                      best_pos = next_i
   317                                           
   318       441        157.9      0.4      0.0              path.insert(best_pos, to_ins)
   319       441        139.3      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322     97461      23117.7      0.2      4.8              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323     97020      20243.4      0.2      4.2                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325     97020      35262.9      0.4      7.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       235         48.9      0.2      0.0                      best_cost = np.inf
   327       235         39.1      0.2      0.0                      posL, posR = -1, -1
   328     10948       1711.3      0.2      0.4                      for i2 in range(len(path)):
   329     10713       2613.6      0.2      0.5                          next_i = (i2 + 1) % len(path)
   330     10713       9491.5      0.9      2.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     10713       1922.3      0.2      0.4                          if best_cost > insertion_cost:
   332      1452        294.3      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       235         63.5      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336     97020     114765.3      1.2     24.1                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337       763        829.8      1.1      0.2                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338       763        285.7      0.4      0.1                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341       763        189.6      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342     97020     119449.3      1.2     25.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      1354       1496.0      1.1      0.3                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      1354        581.3      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345       441       6583.8     14.9      1.4              heapq.heapify(h)
   346                                           
   347         1          3.2      3.2      0.0          self.tour = path
   348         1        229.3    229.3      0.0          self.calculateCost()


Optimal 36905
_________________
u574
randomInsertion 1.1106782390085457
nearestInsertion 1.2232127382809193
cheapestInsertion 1.229510729311989
nearestNeighbor 1.3837703550046516
farthestInsertion 1.1006370718670588
furthestInsertion 1.1115182881270869

[('u574', 1.1106782390085457, 1.2232127382809193, 1.229510729311989, 1.3837703550046516, 1.1006370718670588, 1.1115182881270869)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.234341 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.6      0.6      0.0          n = self.numCity
   103         1       9299.0   9299.0      4.0          distances = np.array(self.adj)
   104         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          0.7      0.7      0.0          in_path = {0}
   106         1         43.4     43.4      0.0          notInPath = [x for x in range(1, n)]
   107         1        601.0    601.0      0.3          random.shuffle(notInPath)
   108                                           
   109       574        160.3      0.3      0.1          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111       573        125.3      0.2      0.1              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114       573        115.0      0.2      0.0              best_increase = np.inf
   115       573        264.9      0.5      0.1              best_position = None
   116    165024      25895.3      0.2     11.1              for i in range(len(path)):
   117    164451      39645.4      0.2     16.9                  next_i = (i + 1) % len(path)
   118    164451     121870.4      0.7     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    164451      30947.1      0.2     13.2                  if increase < best_increase:
   120     15977       2103.3      0.1      0.9                      best_increase = increase
   121     15977       2608.9      0.2      1.1                      best_position = next_i
   122                                           
   123       573        204.0      0.4      0.1              path.insert(best_position, to_insert)
   124       573        146.2      0.3      0.1              in_path.add(to_insert)
   125                                           
   126         1          2.8      2.8      0.0          self.tour = path
   127         1        306.3    306.3      0.1          self.calculateCost()

Total time: 0.0797928 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          2.8      2.8      0.0          self.tour = [0]
   132         1          1.4      1.4      0.0          visited = set([0])
   133         1         12.1     12.1      0.0          notVisited = set(range(1, self.numCity))
   134       574        196.2      0.3      0.2          while len(self.tour) < self.numCity:
   135       573        104.0      0.2      0.1              cost = np.inf
   136       573         73.0      0.1      0.1              j = -1
   137    165024      25694.1      0.2     32.2              for j2 in notVisited:
   138    164451      49379.8      0.3     61.9                  if self.adj[self.tour[-1]][j2] < cost:
   139      9871       2322.2      0.2      2.9                      cost = self.adj[self.tour[-1]][j2]
   140      9871       1343.6      0.1      1.7                      j = j2
   141       573        159.8      0.3      0.2              self.tour.append(j)
   142       573        129.4      0.2      0.2              visited.add(j)
   143       573        131.9      0.2      0.2              notVisited.remove(j)
   144         1        242.7    242.7      0.3          self.calculateCost()

Total time: 0.356141 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.4      0.4      0.0          n = self.numCity
   149         1      10748.3  10748.3      3.0          distances = np.array(self.adj)
   150         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          0.9      0.9      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156       574         83.3      0.1      0.0          for i in range(1, n):
   157       573       1471.2      2.6      0.4              h.append((distances[0, i], i))
   158         1         39.5     39.5      0.0          heapq.heapify(h)
   159                                           
   160       574        178.5      0.3      0.1          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162       573        374.9      0.7      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165       573        118.4      0.2      0.0              best_increase = np.inf
   166       573         90.8      0.2      0.0              best_position = None
   167    165024      26762.6      0.2      7.5              for i in range(len(path)):
   168    164451      38821.0      0.2     10.9                  next_i = (i + 1) % len(path)
   169    164451     124373.7      0.8     34.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    164451      31566.7      0.2      8.9                  if increase < best_increase:
   171     20582       2967.7      0.1      0.8                      best_increase = increase
   172     20582       3906.0      0.2      1.1                      best_position = i + 1
   173                                           
   174       573        212.6      0.4      0.1              path.insert(best_position, to_insert)
   175       573        161.0      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    164451      35816.9      0.2     10.1              for i, (cost, node) in enumerate(h):
   179    163878      57162.7      0.3     16.1                  if node not in in_path and distances[to_insert, node] < cost:
   180     29084       9706.5      0.3      2.7                      h[i] = (distances[to_insert, node], node)
   181       573      11232.3     19.6      3.2              heapq.heapify(h)
   182                                           
   183         1          3.7      3.7      0.0          self.tour = path
   184         1        340.1    340.1      0.1          self.calculateCost()

Total time: 0.836377 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1       9960.9   9960.9      1.2          adj = np.array(self.adj)
   190         1          0.6      0.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.0      1.0      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195       574        100.0      0.2      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197       573        352.0      0.6      0.0              cost = adj[0][i] + adj[i][0]
   198       573        172.8      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         37.4     37.4      0.0          heapq.heapify(h)
   200                                           
   201       574        202.9      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203       573        369.5      0.6      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206       573        124.1      0.2      0.0              best_increase = np.inf
   207       573         88.0      0.2      0.0              best_pos = None
   208    165024      27651.8      0.2      3.3              for i in range(len(path)):
   209    164451      39866.0      0.2      4.8                  next_i = (i + 1) % len(path)
   210    164451     120700.5      0.7     14.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    164451      31130.6      0.2      3.7                  if increase < best_increase:
   212     21401       2806.5      0.1      0.3                      best_increase = increase
   213     21401       3285.2      0.2      0.4                      best_pos = next_i
   214                                           
   215       573        247.0      0.4      0.0              path.insert(best_pos, to_ins)
   216       573        155.6      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    164451      38869.8      0.2      4.6              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    163878      59690.4      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       163         33.7      0.2      0.0                      best_cost = np.inf
   225       163         27.6      0.2      0.0                      posL, posR = -1, -1
   226     17065       2710.3      0.2      0.3                      for i2 in range(len(path)):
   227     16902       3941.3      0.2      0.5                          next_i = (i2 + 1) % len(path)
   228     16902      14951.1      0.9      1.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229     16902       3023.9      0.2      0.4                          if best_cost > insertion_cost:
   230      2506        513.4      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       163         39.1      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    163878     191749.0      1.2     22.9                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     19889      21018.3      1.1      2.5                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     19889       7501.1      0.4      0.9                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     19889       4825.6      0.2      0.6                      best_pos = (best_pos + 1) % (len(path))
   240    163878     203115.3      1.2     24.3                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     22955      25852.4      1.1      3.1                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     22955      10004.5      0.4      1.2                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243       573      10927.7     19.1      1.3              heapq.heapify(h)
   244                                           
   245         1          3.4      3.4      0.0          self.tour = path
   246         1        326.3    326.3      0.0          self.calculateCost()

Total time: 0.429837 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.6      0.6      0.0          n = self.numCity
   251         1       9442.3   9442.3      2.2          distances = np.array(self.adj)
   252         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          0.9      0.9      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.3      0.3      0.0          h = []
   257       574         85.8      0.1      0.0          for i in range(1, n):
   258       573        228.6      0.4      0.1              h.append((-distances[0, i], i))
   259         1         31.2     31.2      0.0          heapq.heapify(h)
   260                                           
   261       574        443.4      0.8      0.1          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263       573        495.7      0.9      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266       573        195.7      0.3      0.0              best_increase = np.inf
   267       573        101.0      0.2      0.0              best_position = None
   268    165024      30253.3      0.2      7.0              for i in range(len(path)):
   269    164451      45435.6      0.3     10.6                  next_i = (i + 1) % len(path)
   270    164451     149573.9      0.9     34.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    164451      34910.9      0.2      8.1                  if increase < best_increase:
   272     15771       2333.3      0.1      0.5                      best_increase = increase
   273     15771       3187.4      0.2      0.7                      best_position = i + 1
   274                                           
   275       573        387.8      0.7      0.1              path.insert(best_position, to_insert)
   276       573        227.3      0.4      0.1              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    164451      37554.1      0.2      8.7              for i, (cost, node) in enumerate(h):
   280    163878      36139.3      0.2      8.4                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    163878      65563.2      0.4     15.3                  if node not in in_path and distances[to_insert, node] < cost:
   283      2691       1083.4      0.4      0.3                      h[i] = (-distances[to_insert, node], node)
   284       573      11833.8     20.7      2.8              heapq.heapify(h)
   285                                           
   286         1          4.6      4.6      0.0          self.tour = path
   287         1        322.6    322.6      0.1          self.calculateCost()

Total time: 0.846296 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1      10284.1  10284.1      1.2          adj = np.array(self.adj)
   293         1          0.5      0.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          0.8      0.8      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.5      0.5      0.0          h = []
   298       574         90.4      0.2      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300       573        353.8      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301       573        184.1      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         33.1     33.1      0.0          heapq.heapify(h)
   303                                           
   304       574        242.9      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306       573        396.3      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309       573        148.4      0.3      0.0              best_increase = np.inf
   310       573         82.9      0.1      0.0              best_pos = None
   311    165024      26188.1      0.2      3.1              for i in range(len(path)):
   312    164451      41061.1      0.2      4.9                  next_i = (i + 1) % len(path)
   313    164451     131036.4      0.8     15.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    164451      31568.2      0.2      3.7                  if increase < best_increase:
   315     18758       2630.9      0.1      0.3                      best_increase = increase
   316     18758       2942.9      0.2      0.3                      best_pos = next_i
   317                                           
   318       573        269.0      0.5      0.0              path.insert(best_pos, to_ins)
   319       573        155.3      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    164451      41210.6      0.3      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    163878      36380.7      0.2      4.3                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    163878      62377.0      0.4      7.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       363         74.0      0.2      0.0                      best_cost = np.inf
   327       363         61.1      0.2      0.0                      posL, posR = -1, -1
   328     22001       3677.9      0.2      0.4                      for i2 in range(len(path)):
   329     21638       5184.5      0.2      0.6                          next_i = (i2 + 1) % len(path)
   330     21638      20314.6      0.9      2.4                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     21638       4029.6      0.2      0.5                          if best_cost > insertion_cost:
   332      3049        635.5      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       363        125.5      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    163878     201273.5      1.2     23.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337       983       1122.6      1.1      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338       983        370.4      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341       983        250.1      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    163878     206692.0      1.3     24.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      1957       2246.8      1.1      0.3                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      1957        851.4      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345       573      11416.7     19.9      1.3              heapq.heapify(h)
   346                                           
   347         1          4.4      4.4      0.0          self.tour = path
   348         1        326.2    326.2      0.0          self.calculateCost()


Optimal 34643
_________________
p654
randomInsertion 1.0554133294032404
nearestInsertion 1.2126837319868062
cheapestInsertion 1.2016004119323607
nearestNeighbor 1.2530816604201624
farthestInsertion 1.031160077511625
furthestInsertion 1.0640032711395835

[('p654', 1.0554133294032404, 1.2126837319868062, 1.2016004119323607, 1.2530816604201624, 1.031160077511625, 1.0640032711395835)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.316854 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.9      0.9      0.0          n = self.numCity
   103         1      13698.9  13698.9      4.3          distances = np.array(self.adj)
   104         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.1      1.1      0.0          in_path = {0}
   106         1         58.2     58.2      0.0          notInPath = [x for x in range(1, n)]
   107         1        629.0    629.0      0.2          random.shuffle(notInPath)
   108                                           
   109       654        187.5      0.3      0.1          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111       653        137.4      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114       653        144.6      0.2      0.0              best_increase = np.inf
   115       653         91.6      0.1      0.0              best_position = None
   116    214184      34402.7      0.2     10.9              for i in range(len(path)):
   117    213531      52226.5      0.2     16.5                  next_i = (i + 1) % len(path)
   118    213531     168634.0      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    213531      40512.1      0.2     12.8                  if increase < best_increase:
   120     17354       2579.8      0.1      0.8                      best_increase = increase
   121     17354       2749.6      0.2      0.9                      best_position = next_i
   122                                           
   123       653        255.5      0.4      0.1              path.insert(best_position, to_insert)
   124       653        192.8      0.3      0.1              in_path.add(to_insert)
   125                                           
   126         1          3.9      3.9      0.0          self.tour = path
   127         1        346.8    346.8      0.1          self.calculateCost()

Total time: 0.102417 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          3.3      3.3      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         13.4     13.4      0.0          notVisited = set(range(1, self.numCity))
   134       654        213.8      0.3      0.2          while len(self.tour) < self.numCity:
   135       653        114.2      0.2      0.1              cost = np.inf
   136       653         84.6      0.1      0.1              j = -1
   137    214184      32331.0      0.2     31.6              for j2 in notVisited:
   138    213531      63197.8      0.3     61.7                  if self.adj[self.tour[-1]][j2] < cost:
   139     15500       3482.9      0.2      3.4                      cost = self.adj[self.tour[-1]][j2]
   140     15500       2176.5      0.1      2.1                      j = j2
   141       653        184.5      0.3      0.2              self.tour.append(j)
   142       653        150.3      0.2      0.1              visited.add(j)
   143       653        144.6      0.2      0.1              notVisited.remove(j)
   144         1        319.3    319.3      0.3          self.calculateCost()

Total time: 0.466127 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.5      0.5      0.0          n = self.numCity
   149         1      14352.6  14352.6      3.1          distances = np.array(self.adj)
   150         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          0.9      0.9      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156       654         97.3      0.1      0.0          for i in range(1, n):
   157       653        524.4      0.8      0.1              h.append((distances[0, i], i))
   158         1         41.3     41.3      0.0          heapq.heapify(h)
   159                                           
   160       654        206.2      0.3      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162       653        417.6      0.6      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165       653        142.2      0.2      0.0              best_increase = np.inf
   166       653         97.0      0.1      0.0              best_position = None
   167    214184      33839.4      0.2      7.3              for i in range(len(path)):
   168    213531      49603.2      0.2     10.6                  next_i = (i + 1) % len(path)
   169    213531     159872.4      0.7     34.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    213531      39471.7      0.2      8.5                  if increase < best_increase:
   171     37635       5433.3      0.1      1.2                      best_increase = increase
   172     37635       6867.2      0.2      1.5                      best_position = i + 1
   173                                           
   174       653        249.6      0.4      0.1              path.insert(best_position, to_insert)
   175       653        166.1      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    213531      46233.9      0.2      9.9              for i, (cost, node) in enumerate(h):
   179    212878      74413.8      0.3     16.0                  if node not in in_path and distances[to_insert, node] < cost:
   180     59644      19285.0      0.3      4.1                      h[i] = (distances[to_insert, node], node)
   181       653      14462.5     22.1      3.1              heapq.heapify(h)
   182                                           
   183         1          5.8      5.8      0.0          self.tour = path
   184         1        341.6    341.6      0.1          self.calculateCost()

Total time: 1.20471 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1      13241.5  13241.5      1.1          adj = np.array(self.adj)
   190         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.6      1.6      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195       654        104.8      0.2      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197       653        457.8      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198       653        209.1      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         40.6     40.6      0.0          heapq.heapify(h)
   200                                           
   201       654        264.0      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203       653        466.4      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206       653        153.3      0.2      0.0              best_increase = np.inf
   207       653        115.3      0.2      0.0              best_pos = None
   208    214184      33497.3      0.2      2.8              for i in range(len(path)):
   209    213531      53160.7      0.2      4.4                  next_i = (i + 1) % len(path)
   210    213531     161686.2      0.8     13.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    213531      40872.1      0.2      3.4                  if increase < best_increase:
   212     17951       2468.0      0.1      0.2                      best_increase = increase
   213     17951       2757.2      0.2      0.2                      best_pos = next_i
   214                                           
   215       653        320.0      0.5      0.0              path.insert(best_pos, to_ins)
   216       653        175.4      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    213531      51727.9      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    212878      77852.4      0.4      6.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       536        102.1      0.2      0.0                      best_cost = np.inf
   225       536         90.8      0.2      0.0                      posL, posR = -1, -1
   226     32506       5233.9      0.2      0.4                      for i2 in range(len(path)):
   227     31970       7786.1      0.2      0.6                          next_i = (i2 + 1) % len(path)
   228     31970      32152.5      1.0      2.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229     31970       6050.0      0.2      0.5                          if best_cost > insertion_cost:
   230      3118        658.4      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       536        133.5      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    212878     274011.1      1.3     22.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     38164      44986.8      1.2      3.7                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     38164      14583.9      0.4      1.2                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     38164       9321.0      0.2      0.8                      best_pos = (best_pos + 1) % (len(path))
   240    212878     284402.4      1.3     23.6                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     43327      51738.0      1.2      4.3                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     43327      18934.1      0.4      1.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243       653      14608.2     22.4      1.2              heapq.heapify(h)
   244                                           
   245         1          3.8      3.8      0.0          self.tour = path
   246         1        343.5    343.5      0.0          self.calculateCost()

Total time: 0.497971 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1      14360.9  14360.9      2.9          distances = np.array(self.adj)
   252         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.2      1.2      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.4      0.4      0.0          h = []
   257       654         96.9      0.1      0.0          for i in range(1, n):
   258       653        269.8      0.4      0.1              h.append((-distances[0, i], i))
   259         1         39.2     39.2      0.0          heapq.heapify(h)
   260                                           
   261       654        228.1      0.3      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263       653        425.4      0.7      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266       653        132.9      0.2      0.0              best_increase = np.inf
   267       653        101.9      0.2      0.0              best_position = None
   268    214184      32468.0      0.2      6.5              for i in range(len(path)):
   269    213531      50194.8      0.2     10.1                  next_i = (i + 1) % len(path)
   270    213531     161188.8      0.8     32.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    213531      39913.0      0.2      8.0                  if increase < best_increase:
   272     36243       5253.9      0.1      1.1                      best_increase = increase
   273     36243       6703.3      0.2      1.3                      best_position = i + 1
   274                                           
   275       653        269.5      0.4      0.1              path.insert(best_position, to_insert)
   276       653        155.2      0.2      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    213531      45587.4      0.2      9.2              for i, (cost, node) in enumerate(h):
   280    212878      43678.3      0.2      8.8                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    212878      80286.2      0.4     16.1                  if node not in in_path and distances[to_insert, node] < cost:
   283      2833       1065.5      0.4      0.2                      h[i] = (-distances[to_insert, node], node)
   284       653      15203.9     23.3      3.1              heapq.heapify(h)
   285                                           
   286         1          3.4      3.4      0.0          self.tour = path
   287         1        342.3    342.3      0.1          self.calculateCost()

Total time: 1.09079 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.6      0.6      0.0          n = self.numCity
   292         1      13390.2  13390.2      1.2          adj = np.array(self.adj)
   293         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.2      1.2      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.3      0.3      0.0          h = []
   298       654         95.7      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300       653        414.5      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301       653        200.6      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         36.4     36.4      0.0          heapq.heapify(h)
   303                                           
   304       654        244.0      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306       653        448.5      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309       653        134.3      0.2      0.0              best_increase = np.inf
   310       653         97.3      0.1      0.0              best_pos = None
   311    214184      32876.6      0.2      3.0              for i in range(len(path)):
   312    213531      50943.3      0.2      4.7                  next_i = (i + 1) % len(path)
   313    213531     159840.2      0.7     14.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    213531      38772.5      0.2      3.6                  if increase < best_increase:
   315     33388       4651.8      0.1      0.4                      best_increase = increase
   316     33388       4957.4      0.1      0.5                      best_pos = next_i
   317                                           
   318       653        289.5      0.4      0.0              path.insert(best_pos, to_ins)
   319       653        166.3      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    213531      50901.1      0.2      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    212878      43320.3      0.2      4.0                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    212878      77332.6      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       408         88.2      0.2      0.0                      best_cost = np.inf
   327       408         76.9      0.2      0.0                      posL, posR = -1, -1
   328     26117       3985.3      0.2      0.4                      for i2 in range(len(path)):
   329     25709       5911.6      0.2      0.5                          next_i = (i2 + 1) % len(path)
   330     25709      25459.6      1.0      2.3                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     25709       4607.6      0.2      0.4                          if best_cost > insertion_cost:
   332      5077       1047.2      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       408        127.8      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    212878     269486.5      1.3     24.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      1136       1332.0      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      1136        409.9      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      1136        265.6      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    212878     280531.7      1.3     25.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      2154       2521.4      1.2      0.2                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      2154        878.4      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345       653      14596.3     22.4      1.3              heapq.heapify(h)
   346                                           
   347         1          3.6      3.6      0.0          self.tour = path
   348         1        342.2    342.2      0.0          self.calculateCost()


Optimal 8806
_________________
rat783
randomInsertion 1.132910812469723
nearestInsertion 1.2494135327810867
cheapestInsertion 1.2057258134671984
nearestNeighbor 1.2781138138726136
farthestInsertion 1.124742928365735
furthestInsertion 1.1591708142163253

[('rat783', 1.132910812469723, 1.2494135327810867, 1.2057258134671984, 1.2781138138726136, 1.124742928365735, 1.1591708142163253)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.435029 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          1.4      1.4      0.0          n = self.numCity
   103         1      19952.7  19952.7      4.6          distances = np.array(self.adj)
   104         1          1.7      1.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.1      1.1      0.0          in_path = {0}
   106         1         73.3     73.3      0.0          notInPath = [x for x in range(1, n)]
   107         1        808.6    808.6      0.2          random.shuffle(notInPath)
   108                                           
   109       783        221.1      0.3      0.1          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111       782        168.0      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114       782        167.8      0.2      0.0              best_increase = np.inf
   115       782        110.2      0.1      0.0              best_position = None
   116    306935      49214.9      0.2     11.3              for i in range(len(path)):
   117    306153      70989.9      0.2     16.3                  next_i = (i + 1) % len(path)
   118    306153     227987.2      0.7     52.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    306153      56531.6      0.2     13.0                  if increase < best_increase:
   120     26569       3765.8      0.1      0.9                      best_increase = increase
   121     26569       4100.1      0.2      0.9                      best_position = next_i
   122                                           
   123       782        297.8      0.4      0.1              path.insert(best_position, to_insert)
   124       782        200.3      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          2.7      2.7      0.0          self.tour = path
   127         1        433.2    433.2      0.1          self.calculateCost()

Total time: 0.15286 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          3.6      3.6      0.0          self.tour = [0]
   132         1          1.2      1.2      0.0          visited = set([0])
   133         1         14.4     14.4      0.0          notVisited = set(range(1, self.numCity))
   134       783        270.9      0.3      0.2          while len(self.tour) < self.numCity:
   135       782        152.7      0.2      0.1              cost = np.inf
   136       782         99.0      0.1      0.1              j = -1
   137    306935      47640.0      0.2     31.2              for j2 in notVisited:
   138    306153      96138.3      0.3     62.9                  if self.adj[self.tour[-1]][j2] < cost:
   139     20286       4636.1      0.2      3.0                      cost = self.adj[self.tour[-1]][j2]
   140     20286       2966.9      0.1      1.9                      j = j2
   141       782        229.5      0.3      0.2              self.tour.append(j)
   142       782        166.6      0.2      0.1              visited.add(j)
   143       782        171.8      0.2      0.1              notVisited.remove(j)
   144         1        369.0    369.0      0.2          self.calculateCost()

Total time: 0.64289 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.7      0.7      0.0          n = self.numCity
   149         1      20525.7  20525.7      3.2          distances = np.array(self.adj)
   150         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.1      1.1      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156       783        111.4      0.1      0.0          for i in range(1, n):
   157       782       1704.6      2.2      0.3              h.append((distances[0, i], i))
   158         1         52.8     52.8      0.0          heapq.heapify(h)
   159                                           
   160       783        239.9      0.3      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162       782        502.3      0.6      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165       782        167.2      0.2      0.0              best_increase = np.inf
   166       782        120.5      0.2      0.0              best_position = None
   167    306935      47472.7      0.2      7.4              for i in range(len(path)):
   168    306153      73183.6      0.2     11.4                  next_i = (i + 1) % len(path)
   169    306153     229949.0      0.8     35.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    306153      55746.0      0.2      8.7                  if increase < best_increase:
   171     31277       4114.2      0.1      0.6                      best_increase = increase
   172     31277       5582.4      0.2      0.9                      best_position = i + 1
   173                                           
   174       782        305.8      0.4      0.0              path.insert(best_position, to_insert)
   175       782        216.1      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    306153      63360.2      0.2      9.9              for i, (cost, node) in enumerate(h):
   179    305371     105658.8      0.3     16.4                  if node not in in_path and distances[to_insert, node] < cost:
   180     40669      13232.4      0.3      2.1                      h[i] = (distances[to_insert, node], node)
   181       782      20200.4     25.8      3.1              heapq.heapify(h)
   182                                           
   183         1          6.3      6.3      0.0          self.tour = path
   184         1        435.0    435.0      0.1          self.calculateCost()

Total time: 1.63733 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1      20246.0  20246.0      1.2          adj = np.array(self.adj)
   190         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.2      1.2      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195       783        116.3      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197       782        556.3      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198       782        243.9      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         51.7     51.7      0.0          heapq.heapify(h)
   200                                           
   201       783        292.8      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203       782        583.9      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206       782        175.5      0.2      0.0              best_increase = np.inf
   207       782        126.8      0.2      0.0              best_pos = None
   208    306935      48742.3      0.2      3.0              for i in range(len(path)):
   209    306153      76703.1      0.3      4.7                  next_i = (i + 1) % len(path)
   210    306153     232127.4      0.8     14.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    306153      58275.2      0.2      3.6                  if increase < best_increase:
   212     35504       4789.1      0.1      0.3                      best_increase = increase
   213     35504       5671.7      0.2      0.3                      best_pos = next_i
   214                                           
   215       782        321.5      0.4      0.0              path.insert(best_pos, to_ins)
   216       782        208.2      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    306153      71124.1      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    305371     114300.9      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       900        164.3      0.2      0.0                      best_cost = np.inf
   225       900        160.1      0.2      0.0                      posL, posR = -1, -1
   226     48064       8090.1      0.2      0.5                      for i2 in range(len(path)):
   227     47164      11943.4      0.3      0.7                          next_i = (i2 + 1) % len(path)
   228     47164      46336.3      1.0      2.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229     47164       9194.6      0.2      0.6                          if best_cost > insertion_cost:
   230      7940       1741.2      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       900        213.6      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    305371     385191.9      1.3     23.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     32302      37093.4      1.1      2.3                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     32302      11905.0      0.4      0.7                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     32302       7779.9      0.2      0.5                      best_pos = (best_pos + 1) % (len(path))
   240    305371     404660.7      1.3     24.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     35928      41521.3      1.2      2.5                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     35928      15777.3      0.4      1.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243       782      20417.3     26.1      1.2              heapq.heapify(h)
   244                                           
   245         1          4.5      4.5      0.0          self.tour = path
   246         1        471.2    471.2      0.0          self.calculateCost()

Total time: 0.70309 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.7      0.7      0.0          n = self.numCity
   251         1      18670.1  18670.1      2.7          distances = np.array(self.adj)
   252         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.1      1.1      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.2      0.2      0.0          h = []
   257       783        112.4      0.1      0.0          for i in range(1, n):
   258       782        312.0      0.4      0.0              h.append((-distances[0, i], i))
   259         1         41.3     41.3      0.0          heapq.heapify(h)
   260                                           
   261       783        254.1      0.3      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263       782        513.4      0.7      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266       782        166.8      0.2      0.0              best_increase = np.inf
   267       782        118.3      0.2      0.0              best_position = None
   268    306935      49496.7      0.2      7.0              for i in range(len(path)):
   269    306153      72997.1      0.2     10.4                  next_i = (i + 1) % len(path)
   270    306153     231058.9      0.8     32.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    306153      57817.3      0.2      8.2                  if increase < best_increase:
   272     26544       3666.9      0.1      0.5                      best_increase = increase
   273     26544       4926.4      0.2      0.7                      best_position = i + 1
   274                                           
   275       782        315.9      0.4      0.0              path.insert(best_position, to_insert)
   276       782        194.9      0.2      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    306153      64101.6      0.2      9.1              for i, (cost, node) in enumerate(h):
   280    305371      62027.1      0.2      8.8                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    305371     114345.4      0.4     16.3                  if node not in in_path and distances[to_insert, node] < cost:
   283      3597       1332.5      0.4      0.2                      h[i] = (-distances[to_insert, node], node)
   284       782      20175.3     25.8      2.9              heapq.heapify(h)
   285                                           
   286         1          4.7      4.7      0.0          self.tour = path
   287         1        437.0    437.0      0.1          self.calculateCost()

Total time: 1.53337 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1      19634.4  19634.4      1.3          adj = np.array(self.adj)
   293         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.4      1.4      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298       783        109.6      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300       782        519.7      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301       782        234.2      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         41.3     41.3      0.0          heapq.heapify(h)
   303                                           
   304       783        279.4      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306       782        549.0      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309       782        168.7      0.2      0.0              best_increase = np.inf
   310       782        139.8      0.2      0.0              best_pos = None
   311    306935      46237.0      0.2      3.0              for i in range(len(path)):
   312    306153      71409.3      0.2      4.7                  next_i = (i + 1) % len(path)
   313    306153     231450.1      0.8     15.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    306153      55945.3      0.2      3.6                  if increase < best_increase:
   315     24408       3384.6      0.1      0.2                      best_increase = increase
   316     24408       3658.8      0.1      0.2                      best_pos = next_i
   317                                           
   318       782        318.5      0.4      0.0              path.insert(best_pos, to_ins)
   319       782        198.8      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    306153      70623.6      0.2      4.6              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    305371      57331.6      0.2      3.7                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    305371     108414.8      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       420         79.2      0.2      0.0                      best_cost = np.inf
   327       420         62.7      0.1      0.0                      posL, posR = -1, -1
   328     26818       4049.8      0.2      0.3                      for i2 in range(len(path)):
   329     26398       6058.4      0.2      0.4                          next_i = (i2 + 1) % len(path)
   330     26398      25915.3      1.0      1.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     26398       4719.2      0.2      0.3                          if best_cost > insertion_cost:
   332      3131        658.1      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       420        116.2      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    305371     388270.7      1.3     25.3                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      1234       1455.4      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      1234        441.0      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      1234        290.4      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    305371     405563.2      1.3     26.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      2643       3181.2      1.2      0.2                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      2643       1150.1      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345       782      20253.8     25.9      1.3              heapq.heapify(h)
   346                                           
   347         1          4.4      4.4      0.0          self.tour = path
   348         1        445.9    445.9      0.0          self.calculateCost()


Optimal 259045
_________________
pr1002
randomInsertion 1.1231652790579545
nearestInsertion 1.1865895908718964
cheapestInsertion 1.2205939425081265
nearestNeighbor 1.2183079673193584
farthestInsertion 1.1032732605433553
furthestInsertion 1.1472550779348325

[('pr1002', 1.1231652790579545, 1.1865895908718964, 1.2205939425081265, 1.2183079673193584, 1.1032732605433553, 1.1472550779348325)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.710145 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.7      0.7      0.0          n = self.numCity
   103         1      34222.1  34222.1      4.8          distances = np.array(self.adj)
   104         1          1.5      1.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.0      1.0      0.0          in_path = {0}
   106         1         92.3     92.3      0.0          notInPath = [x for x in range(1, n)]
   107         1        983.4    983.4      0.1          random.shuffle(notInPath)
   108                                           
   109      1002        295.1      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1001        212.2      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1001        213.2      0.2      0.0              best_increase = np.inf
   115      1001        131.3      0.1      0.0              best_position = None
   116    502502      78169.9      0.2     11.0              for i in range(len(path)):
   117    501501     121283.2      0.2     17.1                  next_i = (i + 1) % len(path)
   118    501501     369323.3      0.7     52.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    501501      95620.4      0.2     13.5                  if increase < best_increase:
   120     28140       4015.7      0.1      0.6                      best_increase = increase
   121     28140       4358.0      0.2      0.6                      best_position = next_i
   122                                           
   123      1001        395.7      0.4      0.1              path.insert(best_position, to_insert)
   124      1001        266.6      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          3.0      3.0      0.0          self.tour = path
   127         1        555.9    555.9      0.1          self.calculateCost()

Total time: 0.238573 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          5.1      5.1      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         17.7     17.7      0.0          notVisited = set(range(1, self.numCity))
   134      1002        360.9      0.4      0.2          while len(self.tour) < self.numCity:
   135      1001        204.5      0.2      0.1              cost = np.inf
   136      1001        123.8      0.1      0.1              j = -1
   137    502502      75801.4      0.2     31.8              for j2 in notVisited:
   138    501501     153067.1      0.3     64.2                  if self.adj[self.tour[-1]][j2] < cost:
   139     20721       4740.1      0.2      2.0                      cost = self.adj[self.tour[-1]][j2]
   140     20721       2915.8      0.1      1.2                      j = j2
   141      1001        290.4      0.3      0.1              self.tour.append(j)
   142      1001        234.7      0.2      0.1              visited.add(j)
   143      1001        255.9      0.3      0.1              notVisited.remove(j)
   144         1        554.0    554.0      0.2          self.calculateCost()

Total time: 1.08773 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.6      0.6      0.0          n = self.numCity
   149         1      35021.9  35021.9      3.2          distances = np.array(self.adj)
   150         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.4      1.4      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156      1002        149.3      0.1      0.0          for i in range(1, n):
   157      1001        888.2      0.9      0.1              h.append((distances[0, i], i))
   158         1         69.5     69.5      0.0          heapq.heapify(h)
   159                                           
   160      1002        338.6      0.3      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1001        698.8      0.7      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1001        248.4      0.2      0.0              best_increase = np.inf
   166      1001        156.2      0.2      0.0              best_position = None
   167    502502      77952.4      0.2      7.2              for i in range(len(path)):
   168    501501     128498.4      0.3     11.8                  next_i = (i + 1) % len(path)
   169    501501     391580.8      0.8     36.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    501501      97743.6      0.2      9.0                  if increase < best_increase:
   171     41095       5763.3      0.1      0.5                      best_increase = increase
   172     41095       7897.7      0.2      0.7                      best_position = i + 1
   173                                           
   174      1001        451.3      0.5      0.0              path.insert(best_position, to_insert)
   175      1001        272.5      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    501501     107893.3      0.2      9.9              for i, (cost, node) in enumerate(h):
   179    500500     177875.8      0.4     16.4                  if node not in in_path and distances[to_insert, node] < cost:
   180     60312      20159.6      0.3      1.9                      h[i] = (distances[to_insert, node], node)
   181      1001      33504.2     33.5      3.1              heapq.heapify(h)
   182                                           
   183         1          7.9      7.9      0.0          self.tour = path
   184         1        554.0    554.0      0.1          self.calculateCost()

Total time: 2.66349 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1      33939.8  33939.8      1.3          adj = np.array(self.adj)
   190         1          1.5      1.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.4      1.4      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.4      0.4      0.0          h = []
   195      1002        140.2      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1001        670.8      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1001        331.3      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         69.5     69.5      0.0          heapq.heapify(h)
   200                                           
   201      1002        397.2      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1001        748.6      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1001        256.4      0.3      0.0              best_increase = np.inf
   207      1001        173.5      0.2      0.0              best_pos = None
   208    502502      77029.3      0.2      2.9              for i in range(len(path)):
   209    501501     127036.8      0.3      4.8                  next_i = (i + 1) % len(path)
   210    501501     377346.5      0.8     14.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    501501      97407.6      0.2      3.7                  if increase < best_increase:
   212     49052       6774.5      0.1      0.3                      best_increase = increase
   213     49052       7962.5      0.2      0.3                      best_pos = next_i
   214                                           
   215      1001        474.5      0.5      0.0              path.insert(best_pos, to_ins)
   216      1001        315.6      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    501501     117848.6      0.2      4.4              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    500500     188810.2      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       416         81.3      0.2      0.0                      best_cost = np.inf
   225       416         65.6      0.2      0.0                      posL, posR = -1, -1
   226     98957      15146.3      0.2      0.6                      for i2 in range(len(path)):
   227     98541      24195.3      0.2      0.9                          next_i = (i2 + 1) % len(path)
   228     98541      93280.4      0.9      3.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229     98541      18430.5      0.2      0.7                          if best_cost > insertion_cost:
   230     10196       2165.6      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       416        104.8      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    500500     624178.1      1.2     23.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     39842      45170.1      1.1      1.7                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     39842      14863.9      0.4      0.6                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     39842       9361.6      0.2      0.4                      best_pos = (best_pos + 1) % (len(path))
   240    500500     666874.0      1.3     25.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     48409      55503.8      1.1      2.1                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     48409      21887.4      0.5      0.8                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1001      33884.3     33.9      1.3              heapq.heapify(h)
   244                                           
   245         1          6.3      6.3      0.0          self.tour = path
   246         1        555.1    555.1      0.0          self.calculateCost()

Total time: 1.15542 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1      35208.8  35208.8      3.0          distances = np.array(self.adj)
   252         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.2      1.2      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.2      0.2      0.0          h = []
   257      1002        147.3      0.1      0.0          for i in range(1, n):
   258      1001        423.3      0.4      0.0              h.append((-distances[0, i], i))
   259         1         53.2     53.2      0.0          heapq.heapify(h)
   260                                           
   261      1002        356.1      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1001        717.8      0.7      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1001        240.0      0.2      0.0              best_increase = np.inf
   267      1001        158.5      0.2      0.0              best_position = None
   268    502502      79075.4      0.2      6.8              for i in range(len(path)):
   269    501501     124522.3      0.2     10.8                  next_i = (i + 1) % len(path)
   270    501501     379571.2      0.8     32.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    501501      94394.2      0.2      8.2                  if increase < best_increase:
   272     37200       4935.9      0.1      0.4                      best_increase = increase
   273     37200       6953.6      0.2      0.6                      best_position = i + 1
   274                                           
   275      1001        431.5      0.4      0.0              path.insert(best_position, to_insert)
   276      1001        255.7      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    501501     105173.8      0.2      9.1              for i, (cost, node) in enumerate(h):
   280    500500     100761.3      0.2      8.7                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    500500     185696.3      0.4     16.1                  if node not in in_path and distances[to_insert, node] < cost:
   283      4907       1800.4      0.4      0.2                      h[i] = (-distances[to_insert, node], node)
   284      1001      33961.3     33.9      2.9              heapq.heapify(h)
   285                                           
   286         1          9.6      9.6      0.0          self.tour = path
   287         1        567.8    567.8      0.0          self.calculateCost()

Total time: 2.60769 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1      33745.4  33745.4      1.3          adj = np.array(self.adj)
   293         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.3      1.3      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      1002        140.5      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1001        667.7      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      1001        302.5      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         54.0     54.0      0.0          heapq.heapify(h)
   303                                           
   304      1002        397.7      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1001        810.4      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1001        279.4      0.3      0.0              best_increase = np.inf
   310      1001        158.2      0.2      0.0              best_pos = None
   311    502502      75420.8      0.2      2.9              for i in range(len(path)):
   312    501501     123618.3      0.2      4.7                  next_i = (i + 1) % len(path)
   313    501501     389508.0      0.8     14.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    501501      94516.1      0.2      3.6                  if increase < best_increase:
   315     31994       4245.8      0.1      0.2                      best_increase = increase
   316     31994       5027.2      0.2      0.2                      best_pos = next_i
   317                                           
   318      1001        517.0      0.5      0.0              path.insert(best_pos, to_ins)
   319      1001        315.3      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    501501     125590.2      0.3      4.8              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    500500      98113.6      0.2      3.8                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    500500     187554.7      0.4      7.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       576        132.9      0.2      0.0                      best_cost = np.inf
   327       576        102.2      0.2      0.0                      posL, posR = -1, -1
   328     47276       7417.5      0.2      0.3                      for i2 in range(len(path)):
   329     46700      11175.7      0.2      0.4                          next_i = (i2 + 1) % len(path)
   330     46700      46568.7      1.0      1.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     46700       8920.1      0.2      0.3                          if best_cost > insertion_cost:
   332      4511        952.2      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       576        181.4      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    500500     662717.1      1.3     25.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      1857       2206.8      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      1857        692.8      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      1857        462.9      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    500500     683463.2      1.4     26.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      3599       4235.7      1.2      0.2                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      3599       1549.5      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1001      35352.8     35.3      1.4              heapq.heapify(h)
   346                                           
   347         1          6.7      6.7      0.0          self.tour = path
   348         1        568.6    568.6      0.0          self.calculateCost()


Optimal 224094
_________________
u1060
randomInsertion 1.1142037576734616
nearestInsertion 1.235196035022902
cheapestInsertion 1.2094622636037948
nearestNeighbor 1.27196349379042
farthestInsertion 1.1144350550986448
furthestInsertion 1.1239418894006858

[('u1060', 1.1142037576734616, 1.235196035022902, 1.2094622636037948, 1.27196349379042, 1.1144350550986448, 1.1239418894006858)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.841302 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.7      0.7      0.0          n = self.numCity
   103         1      38801.6  38801.6      4.6          distances = np.array(self.adj)
   104         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.5      1.5      0.0          in_path = {0}
   106         1         87.5     87.5      0.0          notInPath = [x for x in range(1, n)]
   107         1       1015.1   1015.1      0.1          random.shuffle(notInPath)
   108                                           
   109      1060        313.6      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1059        212.6      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1059        251.1      0.2      0.0              best_increase = np.inf
   115      1059        153.4      0.1      0.0              best_position = None
   116    562329      91279.3      0.2     10.8              for i in range(len(path)):
   117    561270     137443.1      0.2     16.3                  next_i = (i + 1) % len(path)
   118    561270     449740.3      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    561270     107162.6      0.2     12.7                  if increase < best_increase:
   120     46959       6495.6      0.1      0.8                      best_increase = increase
   121     46959       6996.4      0.1      0.8                      best_position = next_i
   122                                           
   123      1059        412.2      0.4      0.0              path.insert(best_position, to_insert)
   124      1059        305.4      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          3.3      3.3      0.0          self.tour = path
   127         1        625.6    625.6      0.1          self.calculateCost()

Total time: 0.263075 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          5.4      5.4      0.0          self.tour = [0]
   132         1          1.5      1.5      0.0          visited = set([0])
   133         1         18.4     18.4      0.0          notVisited = set(range(1, self.numCity))
   134      1060        365.6      0.3      0.1          while len(self.tour) < self.numCity:
   135      1059        215.8      0.2      0.1              cost = np.inf
   136      1059        142.0      0.1      0.1              j = -1
   137    562329      83978.3      0.1     31.9              for j2 in notVisited:
   138    561270     168906.0      0.3     64.2                  if self.adj[self.tour[-1]][j2] < cost:
   139     21792       5058.9      0.2      1.9                      cost = self.adj[self.tour[-1]][j2]
   140     21792       3038.4      0.1      1.2                      j = j2
   141      1059        306.9      0.3      0.1              self.tour.append(j)
   142      1059        272.7      0.3      0.1              visited.add(j)
   143      1059        247.6      0.2      0.1              notVisited.remove(j)
   144         1        517.4    517.4      0.2          self.calculateCost()

Total time: 1.23428 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.5      0.5      0.0          n = self.numCity
   149         1      38895.9  38895.9      3.2          distances = np.array(self.adj)
   150         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.7      1.7      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      1060        156.4      0.1      0.0          for i in range(1, n):
   157      1059       1744.1      1.6      0.1              h.append((distances[0, i], i))
   158         1         71.0     71.0      0.0          heapq.heapify(h)
   159                                           
   160      1060        357.4      0.3      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1059        760.9      0.7      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1059        250.5      0.2      0.0              best_increase = np.inf
   166      1059        185.6      0.2      0.0              best_position = None
   167    562329      90023.8      0.2      7.3              for i in range(len(path)):
   168    561270     133388.3      0.2     10.8                  next_i = (i + 1) % len(path)
   169    561270     459553.7      0.8     37.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    561270     106700.4      0.2      8.6                  if increase < best_increase:
   171     63432       8451.9      0.1      0.7                      best_increase = increase
   172     63432      11795.0      0.2      1.0                      best_position = i + 1
   173                                           
   174      1059        470.5      0.4      0.0              path.insert(best_position, to_insert)
   175      1059        296.3      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    561270     118663.6      0.2      9.6              for i, (cost, node) in enumerate(h):
   179    560211     199464.5      0.4     16.2                  if node not in in_path and distances[to_insert, node] < cost:
   180     73691      24593.4      0.3      2.0                      h[i] = (distances[to_insert, node], node)
   181      1059      37851.7     35.7      3.1              heapq.heapify(h)
   182                                           
   183         1          8.9      8.9      0.0          self.tour = path
   184         1        595.1    595.1      0.0          self.calculateCost()

Total time: 3.02227 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.6      0.6      0.0          n = self.numCity
   189         1      38250.8  38250.8      1.3          adj = np.array(self.adj)
   190         1          2.0      2.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.4      1.4      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.5      0.5      0.0          h = []
   195      1060        158.0      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1059        754.1      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1059        377.3      0.4      0.0              h.append((cost, i, 0, 0))
   199         1         70.1     70.1      0.0          heapq.heapify(h)
   200                                           
   201      1060        400.3      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1059        860.8      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1059        281.6      0.3      0.0              best_increase = np.inf
   207      1059        182.3      0.2      0.0              best_pos = None
   208    562329      87725.9      0.2      2.9              for i in range(len(path)):
   209    561270     136913.6      0.2      4.5                  next_i = (i + 1) % len(path)
   210    561270     455906.4      0.8     15.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    561270     104486.6      0.2      3.5                  if increase < best_increase:
   212     62714       8657.1      0.1      0.3                      best_increase = increase
   213     62714       9587.3      0.2      0.3                      best_pos = next_i
   214                                           
   215      1059        511.0      0.5      0.0              path.insert(best_pos, to_ins)
   216      1059        271.3      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    561270     134282.2      0.2      4.4              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    560211     212623.4      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       409         85.4      0.2      0.0                      best_cost = np.inf
   225       409         67.8      0.2      0.0                      posL, posR = -1, -1
   226     75268      12206.3      0.2      0.4                      for i2 in range(len(path)):
   227     74859      18345.8      0.2      0.6                          next_i = (i2 + 1) % len(path)
   228     74859      76353.5      1.0      2.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229     74859      13797.8      0.2      0.5                          if best_cost > insertion_cost:
   230     10344       2290.0      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       409        102.2      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    560211     725005.6      1.3     24.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     50544      59162.0      1.2      2.0                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     50544      19456.3      0.4      0.6                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     50544      12329.7      0.2      0.4                      best_pos = (best_pos + 1) % (len(path))
   240    560211     756683.5      1.4     25.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     58748      69779.2      1.2      2.3                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     58748      25600.1      0.4      0.8                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1059      38109.7     36.0      1.3              heapq.heapify(h)
   244                                           
   245         1          5.7      5.7      0.0          self.tour = path
   246         1        586.7    586.7      0.0          self.calculateCost()

Total time: 1.34342 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1      38721.8  38721.8      2.9          distances = np.array(self.adj)
   252         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.1      1.1      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.2      0.2      0.0          h = []
   257      1060        146.9      0.1      0.0          for i in range(1, n):
   258      1059        440.2      0.4      0.0              h.append((-distances[0, i], i))
   259         1         57.6     57.6      0.0          heapq.heapify(h)
   260                                           
   261      1060        366.1      0.3      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1059        808.5      0.8      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1059        266.3      0.3      0.0              best_increase = np.inf
   267      1059        180.4      0.2      0.0              best_position = None
   268    562329      87152.4      0.2      6.5              for i in range(len(path)):
   269    561270     138311.7      0.2     10.3                  next_i = (i + 1) % len(path)
   270    561270     458334.6      0.8     34.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    561270     107924.7      0.2      8.0                  if increase < best_increase:
   272     43424       5763.9      0.1      0.4                      best_increase = increase
   273     43424       8276.2      0.2      0.6                      best_position = i + 1
   274                                           
   275      1059        476.3      0.4      0.0              path.insert(best_position, to_insert)
   276      1059        277.4      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    561270     118503.2      0.2      8.8              for i, (cost, node) in enumerate(h):
   280    560211     115316.6      0.2      8.6                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    560211     220786.4      0.4     16.4                  if node not in in_path and distances[to_insert, node] < cost:
   283      5159       1979.7      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1059      38728.3     36.6      2.9              heapq.heapify(h)
   285                                           
   286         1          8.5      8.5      0.0          self.tour = path
   287         1        588.7    588.7      0.0          self.calculateCost()

Total time: 2.98085 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.4      0.4      0.0          n = self.numCity
   292         1      38405.5  38405.5      1.3          adj = np.array(self.adj)
   293         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.3      1.3      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.4      0.4      0.0          h = []
   298      1060        159.0      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1059        761.5      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      1059        342.3      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         59.7     59.7      0.0          heapq.heapify(h)
   303                                           
   304      1060        433.4      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1059        867.6      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1059        267.5      0.3      0.0              best_increase = np.inf
   310      1059        186.5      0.2      0.0              best_pos = None
   311    562329      87311.8      0.2      2.9              for i in range(len(path)):
   312    561270     135175.2      0.2      4.5                  next_i = (i + 1) % len(path)
   313    561270     455178.4      0.8     15.3                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    561270     103708.2      0.2      3.5                  if increase < best_increase:
   315     43107       5738.6      0.1      0.2                      best_increase = increase
   316     43107       6582.3      0.2      0.2                      best_pos = next_i
   317                                           
   318      1059        473.7      0.4      0.0              path.insert(best_pos, to_ins)
   319      1059        282.6      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    561270     145763.9      0.3      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    560211     125599.5      0.2      4.2                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    560211     209765.1      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       595        130.6      0.2      0.0                      best_cost = np.inf
   327       595         99.3      0.2      0.0                      posL, posR = -1, -1
   328     76862      12284.8      0.2      0.4                      for i2 in range(len(path)):
   329     76267      18302.1      0.2      0.6                          next_i = (i2 + 1) % len(path)
   330     76267      76228.0      1.0      2.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     76267      13787.1      0.2      0.5                          if best_cost > insertion_cost:
   332      7296       1489.6      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       595        173.9      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    560211     737900.0      1.3     24.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      1783       2120.5      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      1783        686.3      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      1783        430.6      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    560211     755321.9      1.3     25.3                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      3523       4158.5      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      3523       1506.0      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1059      38574.8     36.4      1.3              heapq.heapify(h)
   346                                           
   347         1          6.1      6.1      0.0          self.tour = path
   348         1        580.9    580.9      0.0          self.calculateCost()


Optimal 56892
_________________
pcb1173
randomInsertion 1.1740897892623254
nearestInsertion 1.2717332461172952
cheapestInsertion 1.247595495170384
nearestNeighbor 1.2352868855978227
farthestInsertion 1.1510140712143822
furthestInsertion 1.183446278210052

[('pcb1173', 1.1740897892623254, 1.2717332461172952, 1.247595495170384, 1.2352868855978227, 1.1510140712143822, 1.183446278210052)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.02934 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.8      0.8      0.0          n = self.numCity
   103         1      48650.1  48650.1      4.7          distances = np.array(self.adj)
   104         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.2      1.2      0.0          in_path = {0}
   106         1        107.0    107.0      0.0          notInPath = [x for x in range(1, n)]
   107         1       1130.2   1130.2      0.1          random.shuffle(notInPath)
   108                                           
   109      1173        346.1      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1172        259.3      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1172        276.0      0.2      0.0              best_increase = np.inf
   115      1172        163.8      0.1      0.0              best_position = None
   116    688550     110416.6      0.2     10.7              for i in range(len(path)):
   117    687378     176149.0      0.3     17.1                  next_i = (i + 1) % len(path)
   118    687378     540118.7      0.8     52.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    687378     135873.4      0.2     13.2                  if increase < best_increase:
   120     45487       6909.8      0.2      0.7                      best_increase = increase
   121     45487       7455.9      0.2      0.7                      best_position = next_i
   122                                           
   123      1172        472.4      0.4      0.0              path.insert(best_position, to_insert)
   124      1172        343.9      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          3.0      3.0      0.0          self.tour = path
   127         1        658.4    658.4      0.1          self.calculateCost()

Total time: 0.329614 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          5.6      5.6      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         22.2     22.2      0.0          notVisited = set(range(1, self.numCity))
   134      1173        423.5      0.4      0.1          while len(self.tour) < self.numCity:
   135      1172        223.6      0.2      0.1              cost = np.inf
   136      1172        146.5      0.1      0.0              j = -1
   137    688550     104666.1      0.2     31.8              for j2 in notVisited:
   138    687378     210993.6      0.3     64.0                  if self.adj[self.tour[-1]][j2] < cost:
   139     30589       7144.7      0.2      2.2                      cost = self.adj[self.tour[-1]][j2]
   140     30589       4452.6      0.1      1.4                      j = j2
   141      1172        335.7      0.3      0.1              self.tour.append(j)
   142      1172        284.2      0.2      0.1              visited.add(j)
   143      1172        286.6      0.2      0.1              notVisited.remove(j)
   144         1        628.0    628.0      0.2          self.calculateCost()

Total time: 1.4709 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.7      0.7      0.0          n = self.numCity
   149         1      48266.9  48266.9      3.3          distances = np.array(self.adj)
   150         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.1      1.1      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.4      0.4      0.0          h = []
   156      1173        178.0      0.2      0.0          for i in range(1, n):
   157      1172       3983.4      3.4      0.3              h.append((distances[0, i], i))
   158         1         75.7     75.7      0.0          heapq.heapify(h)
   159                                           
   160      1173        401.0      0.3      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1172        844.3      0.7      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1172        295.5      0.3      0.0              best_increase = np.inf
   166      1172        163.7      0.1      0.0              best_position = None
   167    688550     108313.1      0.2      7.4              for i in range(len(path)):
   168    687378     167524.5      0.2     11.4                  next_i = (i + 1) % len(path)
   169    687378     525182.4      0.8     35.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    687378     139748.0      0.2      9.5                  if increase < best_increase:
   171     57097       8078.0      0.1      0.5                      best_increase = increase
   172     57097      10664.0      0.2      0.7                      best_position = i + 1
   173                                           
   174      1172        532.3      0.5      0.0              path.insert(best_position, to_insert)
   175      1172        309.7      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    687378     145203.9      0.2      9.9              for i, (cost, node) in enumerate(h):
   179    686206     238644.4      0.3     16.2                  if node not in in_path and distances[to_insert, node] < cost:
   180     78544      26319.9      0.3      1.8                      h[i] = (distances[to_insert, node], node)
   181      1172      45503.4     38.8      3.1              heapq.heapify(h)
   182                                           
   183         1          9.2      9.2      0.0          self.tour = path
   184         1        654.9    654.9      0.0          self.calculateCost()

Total time: 3.50275 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.8      0.8      0.0          n = self.numCity
   189         1      47133.5  47133.5      1.3          adj = np.array(self.adj)
   190         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.2      1.2      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195      1173        168.6      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1172        780.3      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1172        375.1      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         75.1     75.1      0.0          heapq.heapify(h)
   200                                           
   201      1173        434.2      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1172        893.2      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1172        334.1      0.3      0.0              best_increase = np.inf
   207      1172        195.1      0.2      0.0              best_pos = None
   208    688550     109080.9      0.2      3.1              for i in range(len(path)):
   209    687378     169365.7      0.2      4.8                  next_i = (i + 1) % len(path)
   210    687378     526371.9      0.8     15.0                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    687378     132498.8      0.2      3.8                  if increase < best_increase:
   212     64110       8580.0      0.1      0.2                      best_increase = increase
   213     64110      10333.2      0.2      0.3                      best_pos = next_i
   214                                           
   215      1172        549.8      0.5      0.0              path.insert(best_pos, to_ins)
   216      1172        305.6      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    687378     163628.6      0.2      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    686206     263590.9      0.4      7.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      1311        261.4      0.2      0.0                      best_cost = np.inf
   225      1311        208.6      0.2      0.0                      posL, posR = -1, -1
   226    106657      16752.8      0.2      0.5                      for i2 in range(len(path)):
   227    105346      26225.1      0.2      0.7                          next_i = (i2 + 1) % len(path)
   228    105346      95352.6      0.9      2.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    105346      20047.9      0.2      0.6                          if best_cost > insertion_cost:
   230     11350       2411.8      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      1311        320.4      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    686206     817818.5      1.2     23.3                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     53816      57477.1      1.1      1.6                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     53816      20027.3      0.4      0.6                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     53816      13482.0      0.3      0.4                      best_pos = (best_pos + 1) % (len(path))
   240    686206     858093.3      1.3     24.5                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     59398      66176.4      1.1      1.9                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     59398      25227.7      0.4      0.7                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1172      47510.6     40.5      1.4              heapq.heapify(h)
   244                                           
   245         1          8.0      8.0      0.0          self.tour = path
   246         1        652.9    652.9      0.0          self.calculateCost()

Total time: 1.62514 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.5      0.5      0.0          n = self.numCity
   251         1      47717.1  47717.1      2.9          distances = np.array(self.adj)
   252         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.0      1.0      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.3      0.3      0.0          h = []
   257      1173        171.2      0.1      0.0          for i in range(1, n):
   258      1172        483.0      0.4      0.0              h.append((-distances[0, i], i))
   259         1         63.6     63.6      0.0          heapq.heapify(h)
   260                                           
   261      1173        403.3      0.3      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1172        893.8      0.8      0.1              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1172        289.4      0.2      0.0              best_increase = np.inf
   267      1172        222.5      0.2      0.0              best_position = None
   268    688550     117702.7      0.2      7.2              for i in range(len(path)):
   269    687378     178876.7      0.3     11.0                  next_i = (i + 1) % len(path)
   270    687378     540872.7      0.8     33.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    687378     141779.4      0.2      8.7                  if increase < best_increase:
   272     44323       6013.5      0.1      0.4                      best_increase = increase
   273     44323       8882.4      0.2      0.5                      best_position = i + 1
   274                                           
   275      1172        542.2      0.5      0.0              path.insert(best_position, to_insert)
   276      1172        333.8      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    687378     143602.5      0.2      8.8              for i, (cost, node) in enumerate(h):
   280    686206     132970.3      0.2      8.2                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    686206     254003.8      0.4     15.6                  if node not in in_path and distances[to_insert, node] < cost:
   283      5849       2218.2      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1172      46426.5     39.6      2.9              heapq.heapify(h)
   285                                           
   286         1          8.5      8.5      0.0          self.tour = path
   287         1        657.0    657.0      0.0          self.calculateCost()

Total time: 3.5323 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          1.0      1.0      0.0          n = self.numCity
   292         1      47313.3  47313.3      1.3          adj = np.array(self.adj)
   293         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.2      1.2      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.5      0.5      0.0          h = []
   298      1173        166.5      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1172        718.0      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301      1172        344.6      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         65.9     65.9      0.0          heapq.heapify(h)
   303                                           
   304      1173        486.4      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1172        946.8      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1172        325.1      0.3      0.0              best_increase = np.inf
   310      1172        192.7      0.2      0.0              best_pos = None
   311    688550     112885.6      0.2      3.2              for i in range(len(path)):
   312    687378     172624.1      0.3      4.9                  next_i = (i + 1) % len(path)
   313    687378     550571.8      0.8     15.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    687378     134027.9      0.2      3.8                  if increase < best_increase:
   315     44531       6177.3      0.1      0.2                      best_increase = increase
   316     44531       7287.7      0.2      0.2                      best_pos = next_i
   317                                           
   318      1172        588.8      0.5      0.0              path.insert(best_pos, to_ins)
   319      1172        341.6      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    687378     171455.9      0.2      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    686206     135628.3      0.2      3.8                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    686206     262482.8      0.4      7.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       752        157.5      0.2      0.0                      best_cost = np.inf
   327       752        122.2      0.2      0.0                      posL, posR = -1, -1
   328     79407      12447.5      0.2      0.4                      for i2 in range(len(path)):
   329     78655      19561.6      0.2      0.6                          next_i = (i2 + 1) % len(path)
   330     78655      74325.1      0.9      2.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331     78655      14818.4      0.2      0.4                          if best_cost > insertion_cost:
   332      7837       1665.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       752        229.9      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    686206     854181.4      1.2     24.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      2144       2329.1      1.1      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      2144        776.7      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      2144        506.4      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    686206     889837.3      1.3     25.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      4242       4661.5      1.1      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      4242       1780.1      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1172      49597.4     42.3      1.4              heapq.heapify(h)
   346                                           
   347         1          6.6      6.6      0.0          self.tour = path
   348         1        660.5    660.5      0.0          self.calculateCost()


Optimal 50801
_________________
d1291
randomInsertion 1.1826726786174988
nearestInsertion 1.2272567257766993
cheapestInsertion 1.2295577556665873
nearestNeighbor 1.1880958916870108
farthestInsertion 1.210489030513705
furthestInsertion 1.249315558117154

[('d1291', 1.1826726786174988, 1.2272567257766993, 1.2295577556665873, 1.1880958916870108, 1.210489030513705, 1.249315558117154)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.20617 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.7      0.7      0.0          n = self.numCity
   103         1      58239.4  58239.4      4.8          distances = np.array(self.adj)
   104         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.0      1.0      0.0          in_path = {0}
   106         1         99.3     99.3      0.0          notInPath = [x for x in range(1, n)]
   107         1       1241.8   1241.8      0.1          random.shuffle(notInPath)
   108                                           
   109      1291        384.7      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1290        270.7      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1290        281.5      0.2      0.0              best_increase = np.inf
   115      1290        196.4      0.2      0.0              best_position = None
   116    833985     138403.9      0.2     11.5              for i in range(len(path)):
   117    832695     201063.9      0.2     16.7                  next_i = (i + 1) % len(path)
   118    832695     633917.4      0.8     52.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    832695     156623.1      0.2     13.0                  if increase < best_increase:
   120     48869       6291.5      0.1      0.5                      best_increase = increase
   121     48869       7461.1      0.2      0.6                      best_position = next_i
   122                                           
   123      1290        541.0      0.4      0.0              path.insert(best_position, to_insert)
   124      1290        424.9      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          4.1      4.1      0.0          self.tour = path
   127         1        717.2    717.2      0.1          self.calculateCost()

Total time: 0.410884 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          6.8      6.8      0.0          self.tour = [0]
   132         1          1.1      1.1      0.0          visited = set([0])
   133         1         23.8     23.8      0.0          notVisited = set(range(1, self.numCity))
   134      1291        504.3      0.4      0.1          while len(self.tour) < self.numCity:
   135      1290        246.6      0.2      0.1              cost = np.inf
   136      1290        188.0      0.1      0.0              j = -1
   137    833985     133280.9      0.2     32.4              for j2 in notVisited:
   138    832695     260152.8      0.3     63.3                  if self.adj[self.tour[-1]][j2] < cost:
   139     37932       9080.0      0.2      2.2                      cost = self.adj[self.tour[-1]][j2]
   140     37932       5558.3      0.1      1.4                      j = j2
   141      1290        506.0      0.4      0.1              self.tour.append(j)
   142      1290        329.0      0.3      0.1              visited.add(j)
   143      1290        330.6      0.3      0.1              notVisited.remove(j)
   144         1        675.9    675.9      0.2          self.calculateCost()

Total time: 1.77356 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.6      0.6      0.0          n = self.numCity
   149         1      59877.1  59877.1      3.4          distances = np.array(self.adj)
   150         1          1.9      1.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.1      1.1      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156      1291        185.3      0.1      0.0          for i in range(1, n):
   157      1290       6939.9      5.4      0.4              h.append((distances[0, i], i))
   158         1         85.8     85.8      0.0          heapq.heapify(h)
   159                                           
   160      1291        468.1      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1290        918.3      0.7      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1290        291.8      0.2      0.0              best_increase = np.inf
   166      1290        228.2      0.2      0.0              best_position = None
   167    833985     136403.4      0.2      7.7              for i in range(len(path)):
   168    832695     205682.8      0.2     11.6                  next_i = (i + 1) % len(path)
   169    832695     619090.9      0.7     34.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    832695     152894.8      0.2      8.6                  if increase < best_increase:
   171     75404      10122.7      0.1      0.6                      best_increase = increase
   172     75404      13889.0      0.2      0.8                      best_position = i + 1
   173                                           
   174      1290        578.1      0.4      0.0              path.insert(best_position, to_insert)
   175      1290        418.8      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    832695     179881.5      0.2     10.1              for i, (cost, node) in enumerate(h):
   179    831405     290537.5      0.3     16.4                  if node not in in_path and distances[to_insert, node] < cost:
   180    115244      37655.1      0.3      2.1                      h[i] = (distances[to_insert, node], node)
   181      1290      56683.7     43.9      3.2              heapq.heapify(h)
   182                                           
   183         1         11.2     11.2      0.0          self.tour = path
   184         1        712.9    712.9      0.0          self.calculateCost()

Total time: 4.90202 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.6      0.6      0.0          n = self.numCity
   189         1      56081.2  56081.2      1.1          adj = np.array(self.adj)
   190         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.2      1.2      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.4      0.4      0.0          h = []
   195      1291        190.8      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1290        802.3      0.6      0.0              cost = adj[0][i] + adj[i][0]
   198      1290        406.9      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         85.8     85.8      0.0          heapq.heapify(h)
   200                                           
   201      1291        587.7      0.5      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1290        975.4      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1290        301.5      0.2      0.0              best_increase = np.inf
   207      1290        210.3      0.2      0.0              best_pos = None
   208    833985     134671.0      0.2      2.7              for i in range(len(path)):
   209    832695     204783.5      0.2      4.2                  next_i = (i + 1) % len(path)
   210    832695     615689.2      0.7     12.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    832695     154353.0      0.2      3.1                  if increase < best_increase:
   212     65151       8732.2      0.1      0.2                      best_increase = increase
   213     65151      10116.6      0.2      0.2                      best_pos = next_i
   214                                           
   215      1290        625.6      0.5      0.0              path.insert(best_pos, to_ins)
   216      1290        343.7      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    832695     200433.5      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    831405     311675.3      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      1818        376.0      0.2      0.0                      best_cost = np.inf
   225      1818        318.0      0.2      0.0                      posL, posR = -1, -1
   226    443638      73097.8      0.2      1.5                      for i2 in range(len(path)):
   227    441820     109984.4      0.2      2.2                          next_i = (i2 + 1) % len(path)
   228    441820     439346.2      1.0      9.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    441820      85078.2      0.2      1.7                          if best_cost > insertion_cost:
   230     35856       7786.6      0.2      0.2                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      1818        462.0      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    831405    1065611.8      1.3     21.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     67560      78999.1      1.2      1.6                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     67560      25238.8      0.4      0.5                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     67560      16704.2      0.2      0.3                      best_pos = (best_pos + 1) % (len(path))
   240    831405    1121938.6      1.3     22.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     73031      86901.3      1.2      1.8                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     73031      31510.3      0.4      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1290      56818.9     44.0      1.2              heapq.heapify(h)
   244                                           
   245         1          9.4      9.4      0.0          self.tour = path
   246         1        773.8    773.8      0.0          self.calculateCost()

Total time: 1.86875 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.6      0.6      0.0          n = self.numCity
   251         1      57719.1  57719.1      3.1          distances = np.array(self.adj)
   252         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.1      1.1      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.6      0.6      0.0          h = []
   257      1291        187.5      0.1      0.0          for i in range(1, n):
   258      1290        508.8      0.4      0.0              h.append((-distances[0, i], i))
   259         1         70.3     70.3      0.0          heapq.heapify(h)
   260                                           
   261      1291        489.0      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1290        911.0      0.7      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1290        335.9      0.3      0.0              best_increase = np.inf
   267      1290        215.2      0.2      0.0              best_position = None
   268    833985     129973.3      0.2      7.0              for i in range(len(path)):
   269    832695     203984.5      0.2     10.9                  next_i = (i + 1) % len(path)
   270    832695     618756.1      0.7     33.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    832695     154445.8      0.2      8.3                  if increase < best_increase:
   272     52422       6825.1      0.1      0.4                      best_increase = increase
   273     52422       9605.4      0.2      0.5                      best_position = i + 1
   274                                           
   275      1290        569.9      0.4      0.0              path.insert(best_position, to_insert)
   276      1290        306.5      0.2      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    832695     175030.4      0.2      9.4              for i, (cost, node) in enumerate(h):
   280    831405     161745.3      0.2      8.7                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    831405     285768.9      0.3     15.3                  if node not in in_path and distances[to_insert, node] < cost:
   283      7161       2564.4      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1290      58012.4     45.0      3.1              heapq.heapify(h)
   285                                           
   286         1         10.1     10.1      0.0          self.tour = path
   287         1        711.5    711.5      0.0          self.calculateCost()

Total time: 4.39408 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1      56748.0  56748.0      1.3          adj = np.array(self.adj)
   293         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.0      1.0      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      1291        205.3      0.2      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1290        824.8      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301      1290        381.0      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         70.2     70.2      0.0          heapq.heapify(h)
   303                                           
   304      1291        556.6      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1290       1003.3      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1290        315.3      0.2      0.0              best_increase = np.inf
   310      1290        218.8      0.2      0.0              best_pos = None
   311    833985     135538.3      0.2      3.1              for i in range(len(path)):
   312    832695     203525.2      0.2      4.6                  next_i = (i + 1) % len(path)
   313    832695     631815.7      0.8     14.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    832695     155630.7      0.2      3.5                  if increase < best_increase:
   315     50708       6919.0      0.1      0.2                      best_increase = increase
   316     50708       7881.1      0.2      0.2                      best_pos = next_i
   317                                           
   318      1290        646.3      0.5      0.0              path.insert(best_pos, to_ins)
   319      1290        402.4      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    832695     208235.9      0.3      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    831405     159286.4      0.2      3.6                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    831405     310050.7      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       905        198.2      0.2      0.0                      best_cost = np.inf
   327       905        151.8      0.2      0.0                      posL, posR = -1, -1
   328    138428      22583.7      0.2      0.5                      for i2 in range(len(path)):
   329    137523      33191.9      0.2      0.8                          next_i = (i2 + 1) % len(path)
   330    137523     138306.1      1.0      3.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    137523      25025.5      0.2      0.6                          if best_cost > insertion_cost:
   332      9359       1921.1      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       905        262.4      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    831405    1088809.8      1.3     24.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      2462       2986.1      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      2462        901.9      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      2462        633.2      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    831405    1131993.1      1.4     25.8                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      4967       5974.0      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      4967       2116.6      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1290      58038.2     45.0      1.3              heapq.heapify(h)
   346                                           
   347         1          9.6      9.6      0.0          self.tour = path
   348         1        720.1    720.1      0.0          self.calculateCost()


Optimal 270199
_________________
rl1323
randomInsertion 1.204933718762672
nearestInsertion 1.305035438712621
cheapestInsertion 1.2673425047210451
nearestNeighbor 1.2290754949633589
farthestInsertion 1.2074690727489923
furthestInsertion 1.2273323421991211

[('rl1323', 1.204933718762672, 1.305035438712621, 1.2673425047210451, 1.2290754949633589, 1.2074690727489923, 1.2273323421991211)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.29796 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.9      0.9      0.0          n = self.numCity
   103         1      61432.3  61432.3      4.7          distances = np.array(self.adj)
   104         1          2.0      2.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.0      1.0      0.0          in_path = {0}
   106         1        104.1    104.1      0.0          notInPath = [x for x in range(1, n)]
   107         1       1267.9   1267.9      0.1          random.shuffle(notInPath)
   108                                           
   109      1323        422.2      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1322        333.8      0.3      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1322        300.8      0.2      0.0              best_increase = np.inf
   115      1322        187.3      0.1      0.0              best_position = None
   116    875825     138650.7      0.2     10.7              for i in range(len(path)):
   117    874503     210291.6      0.2     16.2                  next_i = (i + 1) % len(path)
   118    874503     689317.6      0.8     53.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    874503     176871.4      0.2     13.6                  if increase < best_increase:
   120     56451       7613.1      0.1      0.6                      best_increase = increase
   121     56451       9325.9      0.2      0.7                      best_position = next_i
   122                                           
   123      1322        576.4      0.4      0.0              path.insert(best_position, to_insert)
   124      1322        469.0      0.4      0.0              in_path.add(to_insert)
   125                                           
   126         1          3.7      3.7      0.0          self.tour = path
   127         1        790.9    790.9      0.1          self.calculateCost()

Total time: 0.427881 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          8.8      8.8      0.0          self.tour = [0]
   132         1          1.5      1.5      0.0          visited = set([0])
   133         1         27.3     27.3      0.0          notVisited = set(range(1, self.numCity))
   134      1323        553.2      0.4      0.1          while len(self.tour) < self.numCity:
   135      1322        305.3      0.2      0.1              cost = np.inf
   136      1322        176.2      0.1      0.0              j = -1
   137    875825     141299.1      0.2     33.0              for j2 in notVisited:
   138    874503     279024.4      0.3     65.2                  if self.adj[self.tour[-1]][j2] < cost:
   139     12164       2810.6      0.2      0.7                      cost = self.adj[self.tour[-1]][j2]
   140     12164       1807.6      0.1      0.4                      j = j2
   141      1322        486.2      0.4      0.1              self.tour.append(j)
   142      1322        360.6      0.3      0.1              visited.add(j)
   143      1322        346.2      0.3      0.1              notVisited.remove(j)
   144         1        673.9    673.9      0.2          self.calculateCost()

Total time: 1.88658 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.6      0.6      0.0          n = self.numCity
   149         1      62461.3  62461.3      3.3          distances = np.array(self.adj)
   150         1          1.8      1.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.2      1.2      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      1323        193.9      0.1      0.0          for i in range(1, n):
   157      1322        801.9      0.6      0.0              h.append((distances[0, i], i))
   158         1         78.9     78.9      0.0          heapq.heapify(h)
   159                                           
   160      1323        467.9      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1322        962.6      0.7      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1322        345.8      0.3      0.0              best_increase = np.inf
   166      1322        208.2      0.2      0.0              best_position = None
   167    875825     137286.7      0.2      7.3              for i in range(len(path)):
   168    874503     213940.3      0.2     11.3                  next_i = (i + 1) % len(path)
   169    874503     692222.4      0.8     36.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    874503     172252.2      0.2      9.1                  if increase < best_increase:
   171     62944       8995.3      0.1      0.5                      best_increase = increase
   172     62944      12014.6      0.2      0.6                      best_position = i + 1
   173                                           
   174      1322        715.8      0.5      0.0              path.insert(best_position, to_insert)
   175      1322        426.1      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    874503     185311.7      0.2      9.8              for i, (cost, node) in enumerate(h):
   179    873181     305929.5      0.4     16.2                  if node not in in_path and distances[to_insert, node] < cost:
   180     97674      32227.6      0.3      1.7                      h[i] = (distances[to_insert, node], node)
   181      1322      58956.9     44.6      3.1              heapq.heapify(h)
   182                                           
   183         1         13.9     13.9      0.0          self.tour = path
   184         1        767.6    767.6      0.0          self.calculateCost()

Total time: 4.96657 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.8      0.8      0.0          n = self.numCity
   189         1      62450.4  62450.4      1.3          adj = np.array(self.adj)
   190         1          1.5      1.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.6      1.6      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.3      0.3      0.0          h = []
   195      1323        199.6      0.2      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1322        915.5      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1322        436.6      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         83.4     83.4      0.0          heapq.heapify(h)
   200                                           
   201      1323        540.3      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1322       1042.3      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1322        339.2      0.3      0.0              best_increase = np.inf
   207      1322        194.7      0.1      0.0              best_pos = None
   208    875825     137359.9      0.2      2.8              for i in range(len(path)):
   209    874503     211095.7      0.2      4.3                  next_i = (i + 1) % len(path)
   210    874503     667911.2      0.8     13.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    874503     164016.6      0.2      3.3                  if increase < best_increase:
   212     79377      10834.7      0.1      0.2                      best_increase = increase
   213     79377      12889.7      0.2      0.3                      best_pos = next_i
   214                                           
   215      1322        665.0      0.5      0.0              path.insert(best_pos, to_ins)
   216      1322        368.3      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    874503     214634.3      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    873181     326365.2      0.4      6.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       742        184.6      0.2      0.0                      best_cost = np.inf
   225       742        152.7      0.2      0.0                      posL, posR = -1, -1
   226    305775      50028.1      0.2      1.0                      for i2 in range(len(path)):
   227    305033      75283.0      0.2      1.5                          next_i = (i2 + 1) % len(path)
   228    305033     310097.3      1.0      6.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    305033      60320.9      0.2      1.2                          if best_cost > insertion_cost:
   230     31606       7099.8      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       742        207.2      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    873181    1136002.6      1.3     22.9                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     74493      87323.3      1.2      1.8                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     74493      28735.9      0.4      0.6                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     74493      17560.0      0.2      0.4                      best_pos = (best_pos + 1) % (len(path))
   240    873181    1185552.8      1.4     23.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     81665      97489.2      1.2      2.0                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     81665      36992.9      0.5      0.7                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1322      60441.1     45.7      1.2              heapq.heapify(h)
   244                                           
   245         1         11.7     11.7      0.0          self.tour = path
   246         1        743.2    743.2      0.0          self.calculateCost()

Total time: 2.03128 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1      61115.9  61115.9      3.0          distances = np.array(self.adj)
   252         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.3      1.3      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.3      0.3      0.0          h = []
   257      1323        184.5      0.1      0.0          for i in range(1, n):
   258      1322        560.3      0.4      0.0              h.append((-distances[0, i], i))
   259         1         80.8     80.8      0.0          heapq.heapify(h)
   260                                           
   261      1323        519.8      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1322        992.6      0.8      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1322        349.3      0.3      0.0              best_increase = np.inf
   267      1322        209.1      0.2      0.0              best_position = None
   268    875825     142106.0      0.2      7.0              for i in range(len(path)):
   269    874503     209328.0      0.2     10.3                  next_i = (i + 1) % len(path)
   270    874503     672809.1      0.8     33.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    874503     167657.8      0.2      8.3                  if increase < best_increase:
   272     51915       6652.6      0.1      0.3                      best_increase = increase
   273     51915       9768.6      0.2      0.5                      best_position = i + 1
   274                                           
   275      1322        630.0      0.5      0.0              path.insert(best_position, to_insert)
   276      1322        320.0      0.2      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    874503     188090.1      0.2      9.3              for i, (cost, node) in enumerate(h):
   280    873181     182940.3      0.2      9.0                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    873181     323960.0      0.4     15.9                  if node not in in_path and distances[to_insert, node] < cost:
   283      6496       2360.6      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1322      59874.4     45.3      2.9              heapq.heapify(h)
   285                                           
   286         1         12.2     12.2      0.0          self.tour = path
   287         1        751.2    751.2      0.0          self.calculateCost()

Total time: 4.61078 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.7      0.7      0.0          n = self.numCity
   292         1      59937.3  59937.3      1.3          adj = np.array(self.adj)
   293         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.0      1.0      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      1323        190.0      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1322        914.5      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      1322        403.8      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         84.8     84.8      0.0          heapq.heapify(h)
   303                                           
   304      1323        542.9      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1322       1021.9      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1322        336.7      0.3      0.0              best_increase = np.inf
   310      1322        199.7      0.2      0.0              best_pos = None
   311    875825     141748.5      0.2      3.1              for i in range(len(path)):
   312    874503     207049.4      0.2      4.5                  next_i = (i + 1) % len(path)
   313    874503     667952.3      0.8     14.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    874503     166782.1      0.2      3.6                  if increase < best_increase:
   315     46164       6509.3      0.1      0.1                      best_increase = increase
   316     46164       7329.9      0.2      0.2                      best_pos = next_i
   317                                           
   318      1322        625.0      0.5      0.0              path.insert(best_pos, to_ins)
   319      1322        369.4      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    874503     217134.6      0.2      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    873181     180200.9      0.2      3.9                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    873181     319122.1      0.4      6.9                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       768        167.9      0.2      0.0                      best_cost = np.inf
   327       768        129.6      0.2      0.0                      posL, posR = -1, -1
   328    137179      22354.0      0.2      0.5                      for i2 in range(len(path)):
   329    136411      32807.6      0.2      0.7                          next_i = (i2 + 1) % len(path)
   330    136411     137449.2      1.0      3.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    136411      26431.3      0.2      0.6                          if best_cost > insertion_cost:
   332      8445       1856.7      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       768        237.3      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    873181    1142564.8      1.3     24.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      2537       3003.3      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      2537        954.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      2537        605.3      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    873181    1194224.3      1.4     25.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      4989       6005.8      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      4989       2254.8      0.5      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1322      60512.0     45.8      1.3              heapq.heapify(h)
   346                                           
   347         1         11.2     11.2      0.0          self.tour = path
   348         1        749.3    749.3      0.0          self.calculateCost()


Optimal 20127
_________________
fl1400
randomInsertion 1.0649836929079075
nearestInsertion 1.1977791849263177
cheapestInsertion 1.2129939918998178
nearestNeighbor 1.3652097742596425
farthestInsertion 1.0527097496741282
furthestInsertion 1.0852887103361335

[('fl1400', 1.0649836929079075, 1.1977791849263177, 1.2129939918998178, 1.3652097742596425, 1.0527097496741282, 1.0852887103361335)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.4591 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          1.3      1.3      0.0          n = self.numCity
   103         1      68612.1  68612.1      4.7          distances = np.array(self.adj)
   104         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.0      1.0      0.0          in_path = {0}
   106         1        111.8    111.8      0.0          notInPath = [x for x in range(1, n)]
   107         1       1432.1   1432.1      0.1          random.shuffle(notInPath)
   108                                           
   109      1400        392.4      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1399        294.6      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1399        328.6      0.2      0.0              best_increase = np.inf
   115      1399        182.2      0.1      0.0              best_position = None
   116    980699     150062.3      0.2     10.3              for i in range(len(path)):
   117    979300     235174.2      0.2     16.1                  next_i = (i + 1) % len(path)
   118    979300     789955.5      0.8     54.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119    979300     181681.4      0.2     12.5                  if increase < best_increase:
   120    102589      13776.8      0.1      0.9                      best_increase = increase
   121    102589      15238.2      0.1      1.0                      best_position = next_i
   122                                           
   123      1399        576.6      0.4      0.0              path.insert(best_position, to_insert)
   124      1399        453.5      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          3.9      3.9      0.0          self.tour = path
   127         1        823.7    823.7      0.1          self.calculateCost()

Total time: 0.486528 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          9.5      9.5      0.0          self.tour = [0]
   132         1          2.2      2.2      0.0          visited = set([0])
   133         1         32.8     32.8      0.0          notVisited = set(range(1, self.numCity))
   134      1400        538.0      0.4      0.1          while len(self.tour) < self.numCity:
   135      1399        307.9      0.2      0.1              cost = np.inf
   136      1399        202.4      0.1      0.0              j = -1
   137    980699     150612.0      0.2     31.0              for j2 in notVisited:
   138    979300     324751.0      0.3     66.7                  if self.adj[self.tour[-1]][j2] < cost:
   139     20812       5124.4      0.2      1.1                      cost = self.adj[self.tour[-1]][j2]
   140     20812       2988.3      0.1      0.6                      j = j2
   141      1399        477.0      0.3      0.1              self.tour.append(j)
   142      1399        380.9      0.3      0.1              visited.add(j)
   143      1399        364.1      0.3      0.1              notVisited.remove(j)
   144         1        737.5    737.5      0.2          self.calculateCost()

Total time: 2.1252 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.6      0.6      0.0          n = self.numCity
   149         1      68864.0  68864.0      3.2          distances = np.array(self.adj)
   150         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.1      1.1      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.4      0.4      0.0          h = []
   156      1400        199.8      0.1      0.0          for i in range(1, n):
   157      1399       2346.5      1.7      0.1              h.append((distances[0, i], i))
   158         1         84.8     84.8      0.0          heapq.heapify(h)
   159                                           
   160      1400        527.7      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1399        994.9      0.7      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1399        330.4      0.2      0.0              best_increase = np.inf
   166      1399        223.1      0.2      0.0              best_position = None
   167    980699     147869.9      0.2      7.0              for i in range(len(path)):
   168    979300     233078.5      0.2     11.0                  next_i = (i + 1) % len(path)
   169    979300     758570.3      0.8     35.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170    979300     181987.2      0.2      8.6                  if increase < best_increase:
   171    114895      15321.8      0.1      0.7                      best_increase = increase
   172    114895      21381.7      0.2      1.0                      best_position = i + 1
   173                                           
   174      1399        616.2      0.4      0.0              path.insert(best_position, to_insert)
   175      1399        403.4      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178    979300     207911.4      0.2      9.8              for i, (cost, node) in enumerate(h):
   179    977901     360211.2      0.4     16.9                  if node not in in_path and distances[to_insert, node] < cost:
   180    162702      57487.1      0.4      2.7                      h[i] = (distances[to_insert, node], node)
   181      1399      65958.6     47.1      3.1              heapq.heapify(h)
   182                                           
   183         1         10.9     10.9      0.0          self.tour = path
   184         1        815.3    815.3      0.0          self.calculateCost()

Total time: 5.35201 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1      66610.3  66610.3      1.2          adj = np.array(self.adj)
   190         1          1.5      1.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.2      1.2      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195      1400        190.8      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1399       1002.0      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1399        474.9      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         85.4     85.4      0.0          heapq.heapify(h)
   200                                           
   201      1400        569.5      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1399       1104.5      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1399        368.9      0.3      0.0              best_increase = np.inf
   207      1399        229.1      0.2      0.0              best_pos = None
   208    980699     152641.3      0.2      2.9              for i in range(len(path)):
   209    979300     241108.4      0.2      4.5                  next_i = (i + 1) % len(path)
   210    979300     803174.6      0.8     15.0                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211    979300     185228.5      0.2      3.5                  if increase < best_increase:
   212     94770      12736.1      0.1      0.2                      best_increase = increase
   213     94770      14495.3      0.2      0.3                      best_pos = next_i
   214                                           
   215      1399        848.4      0.6      0.0              path.insert(best_pos, to_ins)
   216      1399        419.4      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221    979300     225226.6      0.2      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223    977901     367409.2      0.4      6.9                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224       893        169.2      0.2      0.0                      best_cost = np.inf
   225       893        142.7      0.2      0.0                      posL, posR = -1, -1
   226    124337      19908.0      0.2      0.4                      for i2 in range(len(path)):
   227    123444      30396.2      0.2      0.6                          next_i = (i2 + 1) % len(path)
   228    123444     122067.8      1.0      2.3                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    123444      23304.5      0.2      0.4                          if best_cost > insertion_cost:
   230     12055       2529.7      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   231       893        207.2      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234    977901    1265518.3      1.3     23.6                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235    116012     136345.0      1.2      2.5                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236    116012      44539.1      0.4      0.8                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239    116012      27639.0      0.2      0.5                      best_pos = (best_pos + 1) % (len(path))
   240    977901    1319905.1      1.3     24.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    132905     157180.5      1.2      2.9                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    132905      59975.4      0.5      1.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1399      67357.0     48.1      1.3              heapq.heapify(h)
   244                                           
   245         1         12.7     12.7      0.0          self.tour = path
   246         1        884.3    884.3      0.0          self.calculateCost()

Total time: 2.27771 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.5      0.5      0.0          n = self.numCity
   251         1      67697.7  67697.7      3.0          distances = np.array(self.adj)
   252         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.1      1.1      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.4      0.4      0.0          h = []
   257      1400        195.9      0.1      0.0          for i in range(1, n):
   258      1399        625.6      0.4      0.0              h.append((-distances[0, i], i))
   259         1         76.6     76.6      0.0          heapq.heapify(h)
   260                                           
   261      1400        511.1      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1399       1011.9      0.7      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1399        353.3      0.3      0.0              best_increase = np.inf
   267      1399        234.0      0.2      0.0              best_position = None
   268    980699     147610.3      0.2      6.5              for i in range(len(path)):
   269    979300     236472.1      0.2     10.4                  next_i = (i + 1) % len(path)
   270    979300     768556.3      0.8     33.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271    979300     187857.4      0.2      8.2                  if increase < best_increase:
   272     53735       7308.1      0.1      0.3                      best_increase = increase
   273     53735      10250.1      0.2      0.5                      best_position = i + 1
   274                                           
   275      1399        612.6      0.4      0.0              path.insert(best_position, to_insert)
   276      1399        369.9      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279    979300     209887.7      0.2      9.2              for i, (cost, node) in enumerate(h):
   280    977901     193828.8      0.2      8.5                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282    977901     371858.3      0.4     16.3                  if node not in in_path and distances[to_insert, node] < cost:
   283      7519       2941.4      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1399      68587.0     49.0      3.0              heapq.heapify(h)
   285                                           
   286         1         11.0     11.0      0.0          self.tour = path
   287         1        847.9    847.9      0.0          self.calculateCost()

Total time: 5.16967 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.4      0.4      0.0          n = self.numCity
   292         1      66539.2  66539.2      1.3          adj = np.array(self.adj)
   293         1          0.9      0.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.2      1.2      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.3      0.3      0.0          h = []
   298      1400        194.9      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1399        964.1      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      1399        447.5      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         76.6     76.6      0.0          heapq.heapify(h)
   303                                           
   304      1400        597.3      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1399       1068.8      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1399        342.2      0.2      0.0              best_increase = np.inf
   310      1399        243.7      0.2      0.0              best_pos = None
   311    980699     146224.5      0.1      2.8              for i in range(len(path)):
   312    979300     231199.4      0.2      4.5                  next_i = (i + 1) % len(path)
   313    979300     784421.6      0.8     15.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314    979300     180968.6      0.2      3.5                  if increase < best_increase:
   315    104738      13924.7      0.1      0.3                      best_increase = increase
   316    104738      16008.8      0.2      0.3                      best_pos = next_i
   317                                           
   318      1399        614.6      0.4      0.0              path.insert(best_pos, to_ins)
   319      1399        424.2      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322    979300     237760.6      0.2      4.6              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323    977901     200221.6      0.2      3.9                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325    977901     359087.5      0.4      6.9                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       957        194.3      0.2      0.0                      best_cost = np.inf
   327       957        159.4      0.2      0.0                      posL, posR = -1, -1
   328    125887      19229.7      0.2      0.4                      for i2 in range(len(path)):
   329    124930      29427.7      0.2      0.6                          next_i = (i2 + 1) % len(path)
   330    124930     122500.1      1.0      2.4                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    124930      22415.8      0.2      0.4                          if best_cost > insertion_cost:
   332     17308       3495.0      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       957        283.8      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336    977901    1302051.1      1.3     25.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      3052       3686.1      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      3052       1186.0      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      3052        798.0      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   342    977901    1344763.7      1.4     26.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      5564       6664.5      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      5564       2441.7      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1399      68197.2     48.7      1.3              heapq.heapify(h)
   346                                           
   347         1          9.5      9.5      0.0          self.tour = path
   348         1        830.7    830.7      0.0          self.calculateCost()


Optimal 152970
_________________
u1432
randomInsertion 1.123069485731933
nearestInsertion 1.153004281894739
cheapestInsertion 1.1827117264405593
nearestNeighbor 1.2343270596893654
farthestInsertion 1.1274569198077526
furthestInsertion 1.1487310002566988

[('u1432', 1.123069485731933, 1.153004281894739, 1.1827117264405593, 1.2343270596893654, 1.1274569198077526, 1.1487310002566988)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.50021 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.8      0.8      0.0          n = self.numCity
   103         1      71419.0  71419.0      4.8          distances = np.array(self.adj)
   104         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.2      1.2      0.0          in_path = {0}
   106         1        110.2    110.2      0.0          notInPath = [x for x in range(1, n)]
   107         1       1446.4   1446.4      0.1          random.shuffle(notInPath)
   108                                           
   109      1432        445.6      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1431        308.9      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1431        327.8      0.2      0.0              best_increase = np.inf
   115      1431        200.5      0.1      0.0              best_position = None
   116   1026027     174227.8      0.2     11.6              for i in range(len(path)):
   117   1024596     251122.0      0.2     16.7                  next_i = (i + 1) % len(path)
   118   1024596     784099.1      0.8     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   1024596     199624.7      0.2     13.3                  if increase < best_increase:
   120     47989       6916.2      0.1      0.5                      best_increase = increase
   121     47989       8012.5      0.2      0.5                      best_position = next_i
   122                                           
   123      1431        667.2      0.5      0.0              path.insert(best_position, to_insert)
   124      1431        481.5      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          4.5      4.5      0.0          self.tour = path
   127         1        792.6    792.6      0.1          self.calculateCost()

Total time: 0.508956 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          7.7      7.7      0.0          self.tour = [0]
   132         1          1.2      1.2      0.0          visited = set([0])
   133         1         26.4     26.4      0.0          notVisited = set(range(1, self.numCity))
   134      1432        563.5      0.4      0.1          while len(self.tour) < self.numCity:
   135      1431        347.7      0.2      0.1              cost = np.inf
   136      1431        189.6      0.1      0.0              j = -1
   137   1026027     168509.7      0.2     33.1              for j2 in notVisited:
   138   1024596     324605.8      0.3     63.8                  if self.adj[self.tour[-1]][j2] < cost:
   139     31765       8124.0      0.3      1.6                      cost = self.adj[self.tour[-1]][j2]
   140     31765       4608.5      0.1      0.9                      j = j2
   141      1431        498.2      0.3      0.1              self.tour.append(j)
   142      1431        394.7      0.3      0.1              visited.add(j)
   143      1431        340.6      0.2      0.1              notVisited.remove(j)
   144         1        738.3    738.3      0.1          self.calculateCost()

Total time: 2.11287 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.5      0.5      0.0          n = self.numCity
   149         1      72132.8  72132.8      3.4          distances = np.array(self.adj)
   150         1          1.6      1.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.4      1.4      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      1432        214.6      0.1      0.0          for i in range(1, n):
   157      1431       3063.0      2.1      0.1              h.append((distances[0, i], i))
   158         1         94.1     94.1      0.0          heapq.heapify(h)
   159                                           
   160      1432        554.3      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1431       1078.0      0.8      0.1              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1431        383.0      0.3      0.0              best_increase = np.inf
   166      1431        217.9      0.2      0.0              best_position = None
   167   1026027     159989.4      0.2      7.6              for i in range(len(path)):
   168   1024596     242643.0      0.2     11.5                  next_i = (i + 1) % len(path)
   169   1024596     756163.6      0.7     35.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   1024596     190076.3      0.2      9.0                  if increase < best_increase:
   171     57763       7419.9      0.1      0.4                      best_increase = increase
   172     57763      10553.5      0.2      0.5                      best_position = i + 1
   173                                           
   174      1431        691.8      0.5      0.0              path.insert(best_position, to_insert)
   175      1431        450.5      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   1024596     213040.2      0.2     10.1              for i, (cost, node) in enumerate(h):
   179   1023165     360123.1      0.4     17.0                  if node not in in_path and distances[to_insert, node] < cost:
   180     69548      23024.5      0.3      1.1                      h[i] = (distances[to_insert, node], node)
   181      1431      70136.5     49.0      3.3              heapq.heapify(h)
   182                                           
   183         1         10.9     10.9      0.0          self.tour = path
   184         1        804.8    804.8      0.0          self.calculateCost()

Total time: 5.08277 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1      70564.0  70564.0      1.4          adj = np.array(self.adj)
   190         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.5      1.5      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.3      0.3      0.0          h = []
   195      1432        198.2      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1431        919.6      0.6      0.0              cost = adj[0][i] + adj[i][0]
   198      1431        460.2      0.3      0.0              h.append((cost, i, 0, 0))
   199         1         92.3     92.3      0.0          heapq.heapify(h)
   200                                           
   201      1432        585.2      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1431       1115.9      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1431        343.1      0.2      0.0              best_increase = np.inf
   207      1431        223.7      0.2      0.0              best_pos = None
   208   1026027     155340.0      0.2      3.1              for i in range(len(path)):
   209   1024596     247082.3      0.2      4.9                  next_i = (i + 1) % len(path)
   210   1024596     770522.0      0.8     15.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   1024596     187686.4      0.2      3.7                  if increase < best_increase:
   212     62867       8470.2      0.1      0.2                      best_increase = increase
   213     62867       9606.4      0.2      0.2                      best_pos = next_i
   214                                           
   215      1431        754.8      0.5      0.0              path.insert(best_pos, to_ins)
   216      1431        386.6      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   1024596     237539.2      0.2      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   1023165     385867.4      0.4      7.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      1299        275.7      0.2      0.0                      best_cost = np.inf
   225      1299        196.1      0.2      0.0                      posL, posR = -1, -1
   226    121612      19982.6      0.2      0.4                      for i2 in range(len(path)):
   227    120313      29802.7      0.2      0.6                          next_i = (i2 + 1) % len(path)
   228    120313     113194.7      0.9      2.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    120313      22887.7      0.2      0.5                          if best_cost > insertion_cost:
   230      9569       2120.7      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      1299        311.0      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   1023165    1254998.1      1.2     24.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     43332      49519.1      1.1      1.0                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     43332      16658.6      0.4      0.3                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     43332      10829.1      0.2      0.2                      best_pos = (best_pos + 1) % (len(path))
   240   1023165    1330386.8      1.3     26.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     51915      60014.8      1.2      1.2                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     51915      22995.7      0.4      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1431      70023.5     48.9      1.4              heapq.heapify(h)
   244                                           
   245         1          8.5      8.5      0.0          self.tour = path
   246         1        805.6    805.6      0.0          self.calculateCost()

Total time: 2.372 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.5      0.5      0.0          n = self.numCity
   251         1      72044.3  72044.3      3.0          distances = np.array(self.adj)
   252         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.4      1.4      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.3      0.3      0.0          h = []
   257      1432        202.0      0.1      0.0          for i in range(1, n):
   258      1431        573.0      0.4      0.0              h.append((-distances[0, i], i))
   259         1         81.5     81.5      0.0          heapq.heapify(h)
   260                                           
   261      1432        543.3      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1431       1151.0      0.8      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1431        417.1      0.3      0.0              best_increase = np.inf
   267      1431        215.7      0.2      0.0              best_position = None
   268   1026027     167806.0      0.2      7.1              for i in range(len(path)):
   269   1024596     254309.9      0.2     10.7                  next_i = (i + 1) % len(path)
   270   1024596     786305.4      0.8     33.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   1024596     209881.2      0.2      8.8                  if increase < best_increase:
   272     48267       6189.4      0.1      0.3                      best_increase = increase
   273     48267       9019.5      0.2      0.4                      best_position = i + 1
   274                                           
   275      1431        739.7      0.5      0.0              path.insert(best_position, to_insert)
   276      1431        406.8      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   1024596     216176.5      0.2      9.1              for i, (cost, node) in enumerate(h):
   280   1023165     203689.4      0.2      8.6                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   1023165     368432.6      0.4     15.5                  if node not in in_path and distances[to_insert, node] < cost:
   283      5861       2144.6      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1431      70837.5     49.5      3.0              heapq.heapify(h)
   285                                           
   286         1         12.7     12.7      0.0          self.tour = path
   287         1        812.3    812.3      0.0          self.calculateCost()

Total time: 5.29155 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.9      0.9      0.0          n = self.numCity
   292         1      72927.4  72927.4      1.4          adj = np.array(self.adj)
   293         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.3      1.3      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.4      0.4      0.0          h = []
   298      1432        226.8      0.2      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1431        966.0      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      1431        466.7      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         92.0     92.0      0.0          heapq.heapify(h)
   303                                           
   304      1432        602.3      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1431       1128.7      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1431        370.5      0.3      0.0              best_increase = np.inf
   310      1431        250.4      0.2      0.0              best_pos = None
   311   1026027     162461.3      0.2      3.1              for i in range(len(path)):
   312   1024596     245026.5      0.2      4.6                  next_i = (i + 1) % len(path)
   313   1024596     781326.5      0.8     14.8                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   1024596     196925.3      0.2      3.7                  if increase < best_increase:
   315     50055       6721.3      0.1      0.1                      best_increase = increase
   316     50055       8048.4      0.2      0.2                      best_pos = next_i
   317                                           
   318      1431        779.2      0.5      0.0              path.insert(best_pos, to_ins)
   319      1431        399.5      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   1024596     257387.9      0.3      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   1023165     196049.6      0.2      3.7                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   1023165     400481.5      0.4      7.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       806        198.7      0.2      0.0                      best_cost = np.inf
   327       806        133.8      0.2      0.0                      posL, posR = -1, -1
   328    156203      24820.2      0.2      0.5                      for i2 in range(len(path)):
   329    155397      37322.1      0.2      0.7                          next_i = (i2 + 1) % len(path)
   330    155397     145961.0      0.9      2.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    155397      29246.1      0.2      0.6                          if best_cost > insertion_cost:
   332     10866       2357.9      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       806        262.3      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   1023165    1293450.0      1.3     24.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      1881       2229.7      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      1881        752.4      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      1881        482.7      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   1023165    1339449.1      1.3     25.3                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      5088       5983.4      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      5088       2253.4      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1431      73160.7     51.1      1.4              heapq.heapify(h)
   346                                           
   347         1          8.8      8.8      0.0          self.tour = path
   348         1        833.5    833.5      0.0          self.calculateCost()


Optimal 22249
_________________
fl1577
randomInsertion 1.1769242392097217
nearestInsertion 1.2220933062234205
cheapestInsertion 1.2161528151489727
nearestNeighbor 1.3330069924091936
farthestInsertion 1.1820371533842746
furthestInsertion 1.193277343593778

[('fl1577', 1.1769242392097217, 1.2220933062234205, 1.2161528151489727, 1.3330069924091936, 1.1820371533842746, 1.193277343593778)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.79018 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          1.0      1.0      0.0          n = self.numCity
   103         1      88356.1  88356.1      4.9          distances = np.array(self.adj)
   104         1          1.9      1.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.0      1.0      0.0          in_path = {0}
   106         1        121.4    121.4      0.0          notInPath = [x for x in range(1, n)]
   107         1       1564.1   1564.1      0.1          random.shuffle(notInPath)
   108                                           
   109      1577        451.2      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1576        340.9      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1576        379.3      0.2      0.0              best_increase = np.inf
   115      1576        235.3      0.1      0.0              best_position = None
   116   1244252     198778.1      0.2     11.1              for i in range(len(path)):
   117   1242676     295324.9      0.2     16.5                  next_i = (i + 1) % len(path)
   118   1242676     952956.5      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   1242676     231226.2      0.2     12.9                  if increase < best_increase:
   120     63653       8501.8      0.1      0.5                      best_increase = increase
   121     63653       9793.4      0.2      0.5                      best_position = next_i
   122                                           
   123      1576        736.8      0.5      0.0              path.insert(best_position, to_insert)
   124      1576        509.3      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          4.0      4.0      0.0          self.tour = path
   127         1        897.3    897.3      0.1          self.calculateCost()

Total time: 0.588149 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          7.4      7.4      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         30.8     30.8      0.0          notVisited = set(range(1, self.numCity))
   134      1577        632.0      0.4      0.1          while len(self.tour) < self.numCity:
   135      1576        337.1      0.2      0.1              cost = np.inf
   136      1576        218.3      0.1      0.0              j = -1
   137   1244252     190006.3      0.2     32.3              for j2 in notVisited:
   138   1242676     381870.6      0.3     64.9                  if self.adj[self.tour[-1]][j2] < cost:
   139     33969       7959.2      0.2      1.4                      cost = self.adj[self.tour[-1]][j2]
   140     33969       4775.5      0.1      0.8                      j = j2
   141      1576        593.3      0.4      0.1              self.tour.append(j)
   142      1576        419.5      0.3      0.1              visited.add(j)
   143      1576        436.4      0.3      0.1              notVisited.remove(j)
   144         1        861.2    861.2      0.1          self.calculateCost()

Total time: 2.6427 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.6      0.6      0.0          n = self.numCity
   149         1      88208.4  88208.4      3.3          distances = np.array(self.adj)
   150         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.3      1.3      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      1577        230.5      0.1      0.0          for i in range(1, n):
   157      1576       6537.2      4.1      0.2              h.append((distances[0, i], i))
   158         1        103.9    103.9      0.0          heapq.heapify(h)
   159                                           
   160      1577        591.0      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1576       1159.6      0.7      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1576        416.5      0.3      0.0              best_increase = np.inf
   166      1576        254.1      0.2      0.0              best_position = None
   167   1244252     192013.8      0.2      7.3              for i in range(len(path)):
   168   1242676     299293.3      0.2     11.3                  next_i = (i + 1) % len(path)
   169   1242676     939447.9      0.8     35.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   1242676     238297.4      0.2      9.0                  if increase < best_increase:
   171     65210       8962.1      0.1      0.3                      best_increase = increase
   172     65210      12620.6      0.2      0.5                      best_position = i + 1
   173                                           
   174      1576        805.4      0.5      0.0              path.insert(best_position, to_insert)
   175      1576        495.2      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   1242676     265363.1      0.2     10.0              for i, (cost, node) in enumerate(h):
   179   1241100     437382.0      0.4     16.6                  if node not in in_path and distances[to_insert, node] < cost:
   180    189671      63273.9      0.3      2.4                      h[i] = (distances[to_insert, node], node)
   181      1576      86346.8     54.8      3.3              heapq.heapify(h)
   182                                           
   183         1         13.3     13.3      0.0          self.tour = path
   184         1        883.6    883.6      0.0          self.calculateCost()

Total time: 6.26948 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          1.1      1.1      0.0          n = self.numCity
   189         1      86003.1  86003.1      1.4          adj = np.array(self.adj)
   190         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.8      1.8      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195      1577        229.1      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1576       1019.6      0.6      0.0              cost = adj[0][i] + adj[i][0]
   198      1576        487.0      0.3      0.0              h.append((cost, i, 0, 0))
   199         1        103.5    103.5      0.0          heapq.heapify(h)
   200                                           
   201      1577        640.7      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1576       1181.3      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1576        389.1      0.2      0.0              best_increase = np.inf
   207      1576        288.1      0.2      0.0              best_pos = None
   208   1244252     191246.5      0.2      3.1              for i in range(len(path)):
   209   1242676     301560.5      0.2      4.8                  next_i = (i + 1) % len(path)
   210   1242676     938708.4      0.8     15.0                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   1242676     235204.3      0.2      3.8                  if increase < best_increase:
   212    106231      14423.5      0.1      0.2                      best_increase = increase
   213    106231      17106.3      0.2      0.3                      best_pos = next_i
   214                                           
   215      1576        767.0      0.5      0.0              path.insert(best_pos, to_ins)
   216      1576        451.4      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   1242676     292006.8      0.2      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   1241100     462242.2      0.4      7.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      1747        335.7      0.2      0.0                      best_cost = np.inf
   225      1747        266.7      0.2      0.0                      posL, posR = -1, -1
   226    254754      39651.0      0.2      0.6                      for i2 in range(len(path)):
   227    253007      60678.7      0.2      1.0                          next_i = (i2 + 1) % len(path)
   228    253007     226664.4      0.9      3.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    253007      46109.2      0.2      0.7                          if best_cost > insertion_cost:
   230     23906       4970.7      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      1747        399.0      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   1241100    1466870.0      1.2     23.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     71019      75790.3      1.1      1.2                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     71019      26096.5      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     71019      16928.0      0.2      0.3                      best_pos = (best_pos + 1) % (len(path))
   240   1241100    1548656.0      1.2     24.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241     81426      89529.3      1.1      1.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242     81426      35071.5      0.4      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1576      86499.5     54.9      1.4              heapq.heapify(h)
   244                                           
   245         1          8.7      8.7      0.0          self.tour = path
   246         1        892.7    892.7      0.0          self.calculateCost()

Total time: 2.80605 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.6      0.6      0.0          n = self.numCity
   251         1      87632.9  87632.9      3.1          distances = np.array(self.adj)
   252         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.2      1.2      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.4      0.4      0.0          h = []
   257      1577        218.9      0.1      0.0          for i in range(1, n):
   258      1576        662.6      0.4      0.0              h.append((-distances[0, i], i))
   259         1         85.1     85.1      0.0          heapq.heapify(h)
   260                                           
   261      1577        624.4      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1576       1135.2      0.7      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1576        398.9      0.3      0.0              best_increase = np.inf
   267      1576        255.8      0.2      0.0              best_position = None
   268   1244252     193613.4      0.2      6.9              for i in range(len(path)):
   269   1242676     295765.8      0.2     10.5                  next_i = (i + 1) % len(path)
   270   1242676     938987.6      0.8     33.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   1242676     227163.3      0.2      8.1                  if increase < best_increase:
   272     84948      10890.7      0.1      0.4                      best_increase = increase
   273     84948      15273.8      0.2      0.5                      best_position = i + 1
   274                                           
   275      1576        732.4      0.5      0.0              path.insert(best_position, to_insert)
   276      1576        433.5      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   1242676     272437.2      0.2      9.7              for i, (cost, node) in enumerate(h):
   280   1241100     232864.4      0.2      8.3                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   1241100     432448.5      0.3     15.4                  if node not in in_path and distances[to_insert, node] < cost:
   283      7470       2757.6      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1576      90681.6     57.5      3.2              heapq.heapify(h)
   285                                           
   286         1         14.6     14.6      0.0          self.tour = path
   287         1        966.5    966.5      0.0          self.calculateCost()

Total time: 6.34829 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          1.3      1.3      0.0          n = self.numCity
   292         1      90975.1  90975.1      1.4          adj = np.array(self.adj)
   293         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.3      1.3      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.4      0.4      0.0          h = []
   298      1577        241.2      0.2      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1576       1063.7      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      1576        519.9      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         99.3     99.3      0.0          heapq.heapify(h)
   303                                           
   304      1577        643.9      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1576       1260.4      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1576        400.9      0.3      0.0              best_increase = np.inf
   310      1576        242.6      0.2      0.0              best_pos = None
   311   1244252     188063.5      0.2      3.0              for i in range(len(path)):
   312   1242676     297331.0      0.2      4.7                  next_i = (i + 1) % len(path)
   313   1242676     963874.7      0.8     15.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   1242676     228982.0      0.2      3.6                  if increase < best_increase:
   315     62713       8822.4      0.1      0.1                      best_increase = increase
   316     62713       9646.9      0.2      0.2                      best_pos = next_i
   317                                           
   318      1576        856.2      0.5      0.0              path.insert(best_pos, to_ins)
   319      1576        493.9      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   1242676     310321.2      0.2      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   1241100     243887.9      0.2      3.8                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   1241100     454241.0      0.4      7.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       821        207.3      0.3      0.0                      best_cost = np.inf
   327       821        153.2      0.2      0.0                      posL, posR = -1, -1
   328    209230      32094.9      0.2      0.5                      for i2 in range(len(path)):
   329    208409      50162.1      0.2      0.8                          next_i = (i2 + 1) % len(path)
   330    208409     189537.0      0.9      3.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    208409      38546.9      0.2      0.6                          if best_cost > insertion_cost:
   332     13212       2848.1      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       821        259.4      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   1241100    1529550.4      1.2     24.1                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      3146       3512.3      1.1      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      3146       1184.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      3146        768.7      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   1241100    1595425.5      1.3     25.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      6552       7427.1      1.1      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      6552       2850.8      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1576      90864.9     57.7      1.4              heapq.heapify(h)
   346                                           
   347         1         10.3     10.3      0.0          self.tour = path
   348         1        913.9    913.9      0.0          self.calculateCost()


Optimal 62128
_________________
d1655
randomInsertion 1.1620005544970116
nearestInsertion 1.2151854911259856
cheapestInsertion 1.2186880743090958
nearestNeighbor 1.1975894261002455
farthestInsertion 1.1757078995778911
furthestInsertion 1.2055288322290088

[('d1655', 1.1620005544970116, 1.2151854911259856, 1.2186880743090958, 1.1975894261002455, 1.1757078995778911, 1.2055288322290088)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 2.05298 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.9      0.9      0.0          n = self.numCity
   103         1      97420.4  97420.4      4.7          distances = np.array(self.adj)
   104         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.3      1.3      0.0          in_path = {0}
   106         1        129.2    129.2      0.0          notInPath = [x for x in range(1, n)]
   107         1       1699.9   1699.9      0.1          random.shuffle(notInPath)
   108                                           
   109      1655        513.2      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1654        345.4      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1654        432.7      0.3      0.0              best_increase = np.inf
   115      1654        231.0      0.1      0.0              best_position = None
   116   1370339     225359.4      0.2     11.0              for i in range(len(path)):
   117   1368685     334723.7      0.2     16.3                  next_i = (i + 1) % len(path)
   118   1368685    1108426.8      0.8     54.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   1368685     259124.7      0.2     12.6                  if increase < best_increase:
   120     77279      10561.4      0.1      0.5                      best_increase = increase
   121     77279      11758.0      0.2      0.6                      best_position = next_i
   122                                           
   123      1654        757.0      0.5      0.0              path.insert(best_position, to_insert)
   124      1654        548.7      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          4.3      4.3      0.0          self.tour = path
   127         1        938.7    938.7      0.0          self.calculateCost()

Total time: 0.665852 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          7.6      7.6      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         29.0     29.0      0.0          notVisited = set(range(1, self.numCity))
   134      1655        676.1      0.4      0.1          while len(self.tour) < self.numCity:
   135      1654        360.3      0.2      0.1              cost = np.inf
   136      1654        237.5      0.1      0.0              j = -1
   137   1370339     215820.6      0.2     32.4              for j2 in notVisited:
   138   1368685     414358.3      0.3     62.2                  if self.adj[self.tour[-1]][j2] < cost:
   139     84615      19900.0      0.2      3.0                      cost = self.adj[self.tour[-1]][j2]
   140     84615      12143.5      0.1      1.8                      j = j2
   141      1654        596.0      0.4      0.1              self.tour.append(j)
   142      1654        425.3      0.3      0.1              visited.add(j)
   143      1654        427.3      0.3      0.1              notVisited.remove(j)
   144         1        868.8    868.8      0.1          self.calculateCost()

Total time: 2.94395 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.5      0.5      0.0          n = self.numCity
   149         1      97358.2  97358.2      3.3          distances = np.array(self.adj)
   150         1          1.7      1.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.1      1.1      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      1655        246.5      0.1      0.0          for i in range(1, n):
   157      1654        704.1      0.4      0.0              h.append((distances[0, i], i))
   158         1        107.2    107.2      0.0          heapq.heapify(h)
   159                                           
   160      1655        615.7      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1654       1202.4      0.7      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1654        431.3      0.3      0.0              best_increase = np.inf
   166      1654        282.2      0.2      0.0              best_position = None
   167   1370339     221974.0      0.2      7.5              for i in range(len(path)):
   168   1368685     328075.0      0.2     11.1                  next_i = (i + 1) % len(path)
   169   1368685    1067085.2      0.8     36.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   1368685     256893.9      0.2      8.7                  if increase < best_increase:
   171    101400      14141.1      0.1      0.5                      best_increase = increase
   172    101400      19676.4      0.2      0.7                      best_position = i + 1
   173                                           
   174      1654        764.9      0.5      0.0              path.insert(best_position, to_insert)
   175      1654        513.6      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   1368685     299514.6      0.2     10.2              for i, (cost, node) in enumerate(h):
   179   1367031     484221.0      0.4     16.4                  if node not in in_path and distances[to_insert, node] < cost:
   180    169758      55897.0      0.3      1.9                      h[i] = (distances[to_insert, node], node)
   181      1654      93240.3     56.4      3.2              heapq.heapify(h)
   182                                           
   183         1         13.6     13.6      0.0          self.tour = path
   184         1        985.6    985.6      0.0          self.calculateCost()

Total time: 7.44276 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1      95717.9  95717.9      1.3          adj = np.array(self.adj)
   190         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.3      1.3      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.4      0.4      0.0          h = []
   195      1655        243.9      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1654       1078.2      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1654        511.4      0.3      0.0              h.append((cost, i, 0, 0))
   199         1        108.2    108.2      0.0          heapq.heapify(h)
   200                                           
   201      1655        729.3      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1654       1281.2      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1654        429.8      0.3      0.0              best_increase = np.inf
   207      1654        303.0      0.2      0.0              best_pos = None
   208   1370339     216168.5      0.2      2.9              for i in range(len(path)):
   209   1368685     338410.1      0.2      4.5                  next_i = (i + 1) % len(path)
   210   1368685    1078841.9      0.8     14.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   1368685     264232.8      0.2      3.6                  if increase < best_increase:
   212    142176      20213.4      0.1      0.3                      best_increase = increase
   213    142176      22852.4      0.2      0.3                      best_pos = next_i
   214                                           
   215      1654        800.2      0.5      0.0              path.insert(best_pos, to_ins)
   216      1654        439.1      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   1368685     321596.5      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   1367031     521171.1      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      2241        452.7      0.2      0.0                      best_cost = np.inf
   225      2241        352.5      0.2      0.0                      posL, posR = -1, -1
   226    433538      69305.6      0.2      0.9                      for i2 in range(len(path)):
   227    431297     105120.2      0.2      1.4                          next_i = (i2 + 1) % len(path)
   228    431297     399815.9      0.9      5.4                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    431297      79325.3      0.2      1.1                          if best_cost > insertion_cost:
   230     64723      13837.6      0.2      0.2                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      2241        557.6      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   1367031    1677760.9      1.2     22.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     97173     106943.0      1.1      1.4                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     97173      36865.6      0.4      0.5                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     97173      23509.7      0.2      0.3                      best_pos = (best_pos + 1) % (len(path))
   240   1367031    1773752.7      1.3     23.8                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    109089     124132.6      1.1      1.7                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    109089      48054.7      0.4      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1654      96886.2     58.6      1.3              heapq.heapify(h)
   244                                           
   245         1          9.9      9.9      0.0          self.tour = path
   246         1        949.3    949.3      0.0          self.calculateCost()

Total time: 3.2611 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.5      0.5      0.0          n = self.numCity
   251         1      97466.8  97466.8      3.0          distances = np.array(self.adj)
   252         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.3      1.3      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.4      0.4      0.0          h = []
   257      1655        238.4      0.1      0.0          for i in range(1, n):
   258      1654        673.0      0.4      0.0              h.append((-distances[0, i], i))
   259         1         91.0     91.0      0.0          heapq.heapify(h)
   260                                           
   261      1655        714.7      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1654       1271.8      0.8      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1654        448.3      0.3      0.0              best_increase = np.inf
   267      1654        280.9      0.2      0.0              best_position = None
   268   1370339     216698.6      0.2      6.6              for i in range(len(path)):
   269   1368685     336146.2      0.2     10.3                  next_i = (i + 1) % len(path)
   270   1368685    1097705.2      0.8     33.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   1368685     266533.9      0.2      8.2                  if increase < best_increase:
   272     78963      10655.2      0.1      0.3                      best_increase = increase
   273     78963      15120.0      0.2      0.5                      best_position = i + 1
   274                                           
   275      1654        878.9      0.5      0.0              path.insert(best_position, to_insert)
   276      1654        425.4      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   1368685     300762.0      0.2      9.2              for i, (cost, node) in enumerate(h):
   280   1367031     300226.9      0.2      9.2                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   1367031     510998.2      0.4     15.7                  if node not in in_path and distances[to_insert, node] < cost:
   283      9552       3495.8      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1654      99307.5     60.0      3.0              heapq.heapify(h)
   285                                           
   286         1         14.2     14.2      0.0          self.tour = path
   287         1        948.1    948.1      0.0          self.calculateCost()

Total time: 7.17347 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1      95565.9  95565.9      1.3          adj = np.array(self.adj)
   293         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.1      1.1      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.5      0.5      0.0          h = []
   298      1655        242.6      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1654       1068.0      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301      1654        526.9      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1         94.5     94.5      0.0          heapq.heapify(h)
   303                                           
   304      1655        681.0      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1654       1236.3      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1654        425.0      0.3      0.0              best_increase = np.inf
   310      1654        252.5      0.2      0.0              best_pos = None
   311   1370339     214793.0      0.2      3.0              for i in range(len(path)):
   312   1368685     328570.1      0.2      4.6                  next_i = (i + 1) % len(path)
   313   1368685    1108795.0      0.8     15.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   1368685     256729.3      0.2      3.6                  if increase < best_increase:
   315     79357      10626.5      0.1      0.1                      best_increase = increase
   316     79357      11966.9      0.2      0.2                      best_pos = next_i
   317                                           
   318      1654        805.8      0.5      0.0              path.insert(best_pos, to_ins)
   319      1654        480.4      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   1368685     348701.0      0.3      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   1367031     308448.6      0.2      4.3                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   1367031     513592.7      0.4      7.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326      1318        296.4      0.2      0.0                      best_cost = np.inf
   327      1318        227.1      0.2      0.0                      posL, posR = -1, -1
   328    222948      36088.9      0.2      0.5                      for i2 in range(len(path)):
   329    221630      55552.0      0.3      0.8                          next_i = (i2 + 1) % len(path)
   330    221630     205695.5      0.9      2.9                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    221630      41909.2      0.2      0.6                          if best_cost > insertion_cost:
   332     15081       3292.5      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333      1318        384.7      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   1367031    1723427.2      1.3     24.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      3302       3733.7      1.1      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      3302       1265.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      3302        812.0      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   1367031    1787757.6      1.3     24.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      6186       7034.0      1.1      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      6186       2716.6      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1654      98705.7     59.7      1.4              heapq.heapify(h)
   346                                           
   347         1         10.2     10.2      0.0          self.tour = path
   348         1        951.8    951.8      0.0          self.calculateCost()


Optimal 336556
_________________
vm1748
randomInsertion 1.1192327209312458
nearestInsertion 1.2115410450379414
cheapestInsertion 1.205323498313003
nearestNeighbor 1.2125492008590812
farthestInsertion 1.1196004372501673
furthestInsertion 1.13935409608785

[('vm1748', 1.1192327209312458, 1.2115410450379414, 1.205323498313003, 1.2125492008590812, 1.1196004372501673, 1.13935409608785)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 2.28805 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.9      0.9      0.0          n = self.numCity
   103         1     107977.3 107977.3      4.7          distances = np.array(self.adj)
   104         1          1.9      1.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.4      1.4      0.0          in_path = {0}
   106         1        136.6    136.6      0.0          notInPath = [x for x in range(1, n)]
   107         1       1659.1   1659.1      0.1          random.shuffle(notInPath)
   108                                           
   109      1748        518.6      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1747        388.8      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1747        441.8      0.3      0.0              best_increase = np.inf
   115      1747        263.9      0.2      0.0              best_position = None
   116   1528625     245554.5      0.2     10.7              for i in range(len(path)):
   117   1526878     373292.0      0.2     16.3                  next_i = (i + 1) % len(path)
   118   1526878    1245908.5      0.8     54.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   1526878     289515.7      0.2     12.7                  if increase < best_increase:
   120     67126       9093.1      0.1      0.4                      best_increase = increase
   121     67126      10849.1      0.2      0.5                      best_position = next_i
   122                                           
   123      1747        827.9      0.5      0.0              path.insert(best_position, to_insert)
   124      1747        585.1      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          4.5      4.5      0.0          self.tour = path
   127         1       1031.2   1031.2      0.0          self.calculateCost()

Total time: 0.787746 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1         24.1     24.1      0.0          self.tour = [0]
   132         1          1.6      1.6      0.0          visited = set([0])
   133         1         31.3     31.3      0.0          notVisited = set(range(1, self.numCity))
   134      1748        716.5      0.4      0.1          while len(self.tour) < self.numCity:
   135      1747        407.1      0.2      0.1              cost = np.inf
   136      1747        264.3      0.2      0.0              j = -1
   137   1528625     256784.6      0.2     32.6              for j2 in notVisited:
   138   1526878     521045.6      0.3     66.1                  if self.adj[self.tour[-1]][j2] < cost:
   139     14910       3636.1      0.2      0.5                      cost = self.adj[self.tour[-1]][j2]
   140     14910       2221.6      0.1      0.3                      j = j2
   141      1747        660.7      0.4      0.1              self.tour.append(j)
   142      1747        529.4      0.3      0.1              visited.add(j)
   143      1747        472.6      0.3      0.1              notVisited.remove(j)
   144         1        950.5    950.5      0.1          self.calculateCost()

Total time: 3.27785 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.6      0.6      0.0          n = self.numCity
   149         1     109117.5 109117.5      3.3          distances = np.array(self.adj)
   150         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.6      1.6      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      1748        262.0      0.1      0.0          for i in range(1, n):
   157      1747       2955.1      1.7      0.1              h.append((distances[0, i], i))
   158         1        106.3    106.3      0.0          heapq.heapify(h)
   159                                           
   160      1748        688.3      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1747       1374.7      0.8      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1747        445.9      0.3      0.0              best_increase = np.inf
   166      1747        300.0      0.2      0.0              best_position = None
   167   1528625     243507.0      0.2      7.4              for i in range(len(path)):
   168   1526878     369663.7      0.2     11.3                  next_i = (i + 1) % len(path)
   169   1526878    1224448.5      0.8     37.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   1526878     289305.5      0.2      8.8                  if increase < best_increase:
   171     94743      13307.7      0.1      0.4                      best_increase = increase
   172     94743      18079.0      0.2      0.6                      best_position = i + 1
   173                                           
   174      1747        875.4      0.5      0.0              path.insert(best_position, to_insert)
   175      1747        540.1      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   1526878     311322.2      0.2      9.5              for i, (cost, node) in enumerate(h):
   179   1525131     524668.3      0.3     16.0                  if node not in in_path and distances[to_insert, node] < cost:
   180    189172      61017.9      0.3      1.9                      h[i] = (distances[to_insert, node], node)
   181      1747     104810.5     60.0      3.2              heapq.heapify(h)
   182                                           
   183         1         16.4     16.4      0.0          self.tour = path
   184         1       1029.4   1029.4      0.0          self.calculateCost()

Total time: 8.28866 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.6      0.6      0.0          n = self.numCity
   189         1     106164.8 106164.8      1.3          adj = np.array(self.adj)
   190         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.2      1.2      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.4      0.4      0.0          h = []
   195      1748        261.6      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1747       1159.2      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1747        549.4      0.3      0.0              h.append((cost, i, 0, 0))
   199         1        108.1    108.1      0.0          heapq.heapify(h)
   200                                           
   201      1748        757.8      0.4      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1747       1429.9      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1747        490.0      0.3      0.0              best_increase = np.inf
   207      1747        313.2      0.2      0.0              best_pos = None
   208   1528625     244070.4      0.2      2.9              for i in range(len(path)):
   209   1526878     374317.5      0.2      4.5                  next_i = (i + 1) % len(path)
   210   1526878    1297246.2      0.8     15.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   1526878     287168.9      0.2      3.5                  if increase < best_increase:
   212     92334      13054.2      0.1      0.2                      best_increase = increase
   213     92334      14595.2      0.2      0.2                      best_pos = next_i
   214                                           
   215      1747       1021.7      0.6      0.0              path.insert(best_pos, to_ins)
   216      1747        519.1      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   1526878     381740.8      0.3      4.6              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   1525131     582194.1      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      1312        324.5      0.2      0.0                      best_cost = np.inf
   225      1312        224.6      0.2      0.0                      posL, posR = -1, -1
   226    316487      51223.8      0.2      0.6                      for i2 in range(len(path)):
   227    315175      84830.2      0.3      1.0                          next_i = (i2 + 1) % len(path)
   228    315175     315722.8      1.0      3.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    315175      61132.5      0.2      0.7                          if best_cost > insertion_cost:
   230     30754       6693.5      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      1312        332.9      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   1525131    1966506.1      1.3     23.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235     91857     105788.6      1.2      1.3                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236     91857      36731.4      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239     91857      24581.0      0.3      0.3                      best_pos = (best_pos + 1) % (len(path))
   240   1525131    2048910.5      1.3     24.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    101594     121661.0      1.2      1.5                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    101594      45631.2      0.4      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1747     110151.3     63.1      1.3              heapq.heapify(h)
   244                                           
   245         1         15.4     15.4      0.0          self.tour = path
   246         1       1028.8   1028.8      0.0          self.calculateCost()

Total time: 3.61911 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1     108142.9 108142.9      3.0          distances = np.array(self.adj)
   252         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.1      1.1      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.5      0.5      0.0          h = []
   257      1748        263.5      0.2      0.0          for i in range(1, n):
   258      1747        747.5      0.4      0.0              h.append((-distances[0, i], i))
   259         1        106.2    106.2      0.0          heapq.heapify(h)
   260                                           
   261      1748        717.6      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1747       1314.8      0.8      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1747        421.2      0.2      0.0              best_increase = np.inf
   267      1747        305.5      0.2      0.0              best_position = None
   268   1528625     244663.8      0.2      6.8              for i in range(len(path)):
   269   1526878     376048.0      0.2     10.4                  next_i = (i + 1) % len(path)
   270   1526878    1228897.0      0.8     34.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   1526878     296296.6      0.2      8.2                  if increase < best_increase:
   272     68325       8249.9      0.1      0.2                      best_increase = increase
   273     68325      13259.9      0.2      0.4                      best_position = i + 1
   274                                           
   275      1747        856.0      0.5      0.0              path.insert(best_position, to_insert)
   276      1747        547.6      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   1526878     329553.2      0.2      9.1              for i, (cost, node) in enumerate(h):
   280   1525131     314529.3      0.2      8.7                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   1525131     582606.9      0.4     16.1                  if node not in in_path and distances[to_insert, node] < cost:
   283      7741       3031.1      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1747     107509.3     61.5      3.0              heapq.heapify(h)
   285                                           
   286         1         15.8     15.8      0.0          self.tour = path
   287         1       1027.9   1027.9      0.0          self.calculateCost()

Total time: 7.77627 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1     105696.0 105696.0      1.4          adj = np.array(self.adj)
   293         1          1.7      1.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.3      1.3      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      1748        276.8      0.2      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1747       1151.2      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      1747        519.5      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1        110.4    110.4      0.0          heapq.heapify(h)
   303                                           
   304      1748        679.8      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1747       1339.4      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1747        410.8      0.2      0.0              best_increase = np.inf
   310      1747        273.3      0.2      0.0              best_pos = None
   311   1528625     242142.6      0.2      3.1              for i in range(len(path)):
   312   1526878     370117.9      0.2      4.8                  next_i = (i + 1) % len(path)
   313   1526878    1214915.1      0.8     15.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   1526878     284725.3      0.2      3.7                  if increase < best_increase:
   315     74933      10370.6      0.1      0.1                      best_increase = increase
   316     74933      11831.3      0.2      0.2                      best_pos = next_i
   317                                           
   318      1747        843.9      0.5      0.0              path.insert(best_pos, to_ins)
   319      1747        481.5      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   1526878     368338.3      0.2      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   1525131     312270.1      0.2      4.0                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   1525131     576064.8      0.4      7.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326       894        179.8      0.2      0.0                      best_cost = np.inf
   327       894        151.2      0.2      0.0                      posL, posR = -1, -1
   328    117985      18464.1      0.2      0.2                      for i2 in range(len(path)):
   329    117091      29756.1      0.3      0.4                          next_i = (i2 + 1) % len(path)
   330    117091     115861.1      1.0      1.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    117091      21823.9      0.2      0.3                          if best_cost > insertion_cost:
   332      7705       1631.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333       894        262.5      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   1525131    1956441.5      1.3     25.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      2898       3217.1      1.1      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      2898       1060.8      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      2898        739.4      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   1525131    2002182.9      1.3     25.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      6223       7059.9      1.1      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      6223       2612.7      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1747     111190.9     63.6      1.4              heapq.heapify(h)
   346                                           
   347         1         12.1     12.1      0.0          self.tour = path
   348         1       1065.6   1065.6      0.0          self.calculateCost()


Optimal 316536
_________________
rl1889
randomInsertion 1.1697882215515978
nearestInsertion 1.2386169014797943
cheapestInsertion 1.2590410880225935
nearestNeighbor 1.2658422373310316
farthestInsertion 1.1769342151924804
furthestInsertion 1.2077977172585437

[('rl1889', 1.1697882215515978, 1.2386169014797943, 1.2590410880225935, 1.2658422373310316, 1.1769342151924804, 1.2077977172585437)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 2.62597 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          1.2      1.2      0.0          n = self.numCity
   103         1     127770.2 127770.2      4.9          distances = np.array(self.adj)
   104         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.5      1.5      0.0          in_path = {0}
   106         1        168.1    168.1      0.0          notInPath = [x for x in range(1, n)]
   107         1       1795.3   1795.3      0.1          random.shuffle(notInPath)
   108                                           
   109      1889        572.5      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      1888        396.0      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      1888        429.6      0.2      0.0              best_increase = np.inf
   115      1888        283.5      0.2      0.0              best_position = None
   116   1785104     284188.8      0.2     10.8              for i in range(len(path)):
   117   1783216     439027.5      0.2     16.7                  next_i = (i + 1) % len(path)
   118   1783216    1400472.5      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   1783216     340477.1      0.2     13.0                  if increase < best_increase:
   120     95831      12928.1      0.1      0.5                      best_increase = increase
   121     95831      14863.4      0.2      0.6                      best_position = next_i
   122                                           
   123      1888        872.9      0.5      0.0              path.insert(best_position, to_insert)
   124      1888        614.6      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          4.7      4.7      0.0          self.tour = path
   127         1       1099.8   1099.8      0.0          self.calculateCost()

Total time: 0.850013 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1         12.3     12.3      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         31.8     31.8      0.0          notVisited = set(range(1, self.numCity))
   134      1889        765.2      0.4      0.1          while len(self.tour) < self.numCity:
   135      1888        449.7      0.2      0.1              cost = np.inf
   136      1888        238.8      0.1      0.0              j = -1
   137   1785104     274007.6      0.2     32.2              for j2 in notVisited:
   138   1783216     559948.7      0.3     65.9                  if self.adj[self.tour[-1]][j2] < cost:
   139     31176       7286.2      0.2      0.9                      cost = self.adj[self.tour[-1]][j2]
   140     31176       4500.9      0.1      0.5                      j = j2
   141      1888        730.8      0.4      0.1              self.tour.append(j)
   142      1888        569.3      0.3      0.1              visited.add(j)
   143      1888        445.6      0.2      0.1              notVisited.remove(j)
   144         1       1025.1   1025.1      0.1          self.calculateCost()

Total time: 3.85796 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.8      0.8      0.0          n = self.numCity
   149         1     128563.5 128563.5      3.3          distances = np.array(self.adj)
   150         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.7      1.7      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      1889        264.7      0.1      0.0          for i in range(1, n):
   157      1888       7150.6      3.8      0.2              h.append((distances[0, i], i))
   158         1        127.5    127.5      0.0          heapq.heapify(h)
   159                                           
   160      1889        687.5      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      1888       1468.3      0.8      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      1888        443.1      0.2      0.0              best_increase = np.inf
   166      1888        336.0      0.2      0.0              best_position = None
   167   1785104     286698.9      0.2      7.4              for i in range(len(path)):
   168   1783216     446435.7      0.3     11.6                  next_i = (i + 1) % len(path)
   169   1783216    1415858.9      0.8     36.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   1783216     333947.7      0.2      8.7                  if increase < best_increase:
   171    126474      17347.7      0.1      0.4                      best_increase = increase
   172    126474      23402.8      0.2      0.6                      best_position = i + 1
   173                                           
   174      1888        936.7      0.5      0.0              path.insert(best_position, to_insert)
   175      1888        592.3      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   1783216     378546.3      0.2      9.8              for i, (cost, node) in enumerate(h):
   179   1781328     624799.3      0.4     16.2                  if node not in in_path and distances[to_insert, node] < cost:
   180    201775      65534.8      0.3      1.7                      h[i] = (distances[to_insert, node], node)
   181      1888     123649.0     65.5      3.2              heapq.heapify(h)
   182                                           
   183         1         20.3     20.3      0.0          self.tour = path
   184         1       1144.6   1144.6      0.0          self.calculateCost()

Total time: 11.6079 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          1.4      1.4      0.0          n = self.numCity
   189         1     131296.4 131296.4      1.1          adj = np.array(self.adj)
   190         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.5      1.5      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.4      0.4      0.0          h = []
   195      1889        304.8      0.2      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      1888       1397.9      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      1888      37275.0     19.7      0.3              h.append((cost, i, 0, 0))
   199         1        132.7    132.7      0.0          heapq.heapify(h)
   200                                           
   201      1889        878.2      0.5      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      1888       1633.5      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      1888        493.2      0.3      0.0              best_increase = np.inf
   207      1888        357.5      0.2      0.0              best_pos = None
   208   1785104     282770.6      0.2      2.4              for i in range(len(path)):
   209   1783216     454806.3      0.3      3.9                  next_i = (i + 1) % len(path)
   210   1783216    1413723.7      0.8     12.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   1783216     330571.4      0.2      2.8                  if increase < best_increase:
   212    164895      22547.6      0.1      0.2                      best_increase = increase
   213    164895      25634.6      0.2      0.2                      best_pos = next_i
   214                                           
   215      1888       1088.9      0.6      0.0              path.insert(best_pos, to_ins)
   216      1888        584.5      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   1783216     461723.3      0.3      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   1781328     674886.3      0.4      5.8                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      4213        900.6      0.2      0.0                      best_cost = np.inf
   225      4213        697.6      0.2      0.0                      posL, posR = -1, -1
   226   1656702     261454.4      0.2      2.3                      for i2 in range(len(path)):
   227   1652489     397925.1      0.2      3.4                          next_i = (i2 + 1) % len(path)
   228   1652489    1529670.3      0.9     13.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229   1652489     304636.2      0.2      2.6                          if best_cost > insertion_cost:
   230    304160      64871.0      0.2      0.6                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      4213       1083.7      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   1781328    2294670.6      1.3     19.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235    131540     144673.3      1.1      1.2                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236    131540      48023.0      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239    131540      32852.6      0.2      0.3                      best_pos = (best_pos + 1) % (len(path))
   240   1781328    2324160.0      1.3     20.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    147654     166146.1      1.1      1.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    147654      63567.6      0.4      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      1888     129308.6     68.5      1.1              heapq.heapify(h)
   244                                           
   245         1         14.0     14.0      0.0          self.tour = path
   246         1       1104.5   1104.5      0.0          self.calculateCost()

Total time: 4.1667 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.5      0.5      0.0          n = self.numCity
   251         1     127864.3 127864.3      3.1          distances = np.array(self.adj)
   252         1          1.6      1.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.6      1.6      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.4      0.4      0.0          h = []
   257      1889        269.1      0.1      0.0          for i in range(1, n):
   258      1888        772.4      0.4      0.0              h.append((-distances[0, i], i))
   259         1        116.8    116.8      0.0          heapq.heapify(h)
   260                                           
   261      1889        734.7      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      1888       1420.5      0.8      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      1888        446.2      0.2      0.0              best_increase = np.inf
   267      1888        286.6      0.2      0.0              best_position = None
   268   1785104     278265.5      0.2      6.7              for i in range(len(path)):
   269   1783216     433913.0      0.2     10.4                  next_i = (i + 1) % len(path)
   270   1783216    1402459.3      0.8     33.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   1783216     327108.2      0.2      7.9                  if increase < best_increase:
   272    108985      14502.4      0.1      0.3                      best_increase = increase
   273    108985      19532.1      0.2      0.5                      best_position = i + 1
   274                                           
   275      1888        969.8      0.5      0.0              path.insert(best_position, to_insert)
   276      1888        509.4      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   1783216     374751.2      0.2      9.0              for i, (cost, node) in enumerate(h):
   280   1781328     389316.7      0.2      9.3                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   1781328     659357.6      0.4     15.8                  if node not in in_path and distances[to_insert, node] < cost:
   283      9681       3591.3      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      1888     129216.5     68.4      3.1              heapq.heapify(h)
   285                                           
   286         1         16.9     16.9      0.0          self.tour = path
   287         1       1277.6   1277.6      0.0          self.calculateCost()

Total time: 9.35204 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.4      0.4      0.0          n = self.numCity
   292         1     125840.0 125840.0      1.3          adj = np.array(self.adj)
   293         1          1.9      1.9      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.2      1.2      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      1889        262.8      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      1888       1219.3      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301      1888        585.1      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1        119.4    119.4      0.0          heapq.heapify(h)
   303                                           
   304      1889        792.2      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      1888       1606.7      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      1888        452.7      0.2      0.0              best_increase = np.inf
   310      1888        286.0      0.2      0.0              best_pos = None
   311   1785104     278004.7      0.2      3.0              for i in range(len(path)):
   312   1783216     443376.3      0.2      4.7                  next_i = (i + 1) % len(path)
   313   1783216    1418909.3      0.8     15.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   1783216     323406.0      0.2      3.5                  if increase < best_increase:
   315    100047      12950.3      0.1      0.1                      best_increase = increase
   316    100047      14968.0      0.1      0.2                      best_pos = next_i
   317                                           
   318      1888       1041.6      0.6      0.0              path.insert(best_pos, to_ins)
   319      1888        541.1      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   1783216     473325.9      0.3      5.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   1781328     373347.4      0.2      4.0                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   1781328     657957.3      0.4      7.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326      1005        200.0      0.2      0.0                      best_cost = np.inf
   327      1005        151.8      0.2      0.0                      posL, posR = -1, -1
   328    277709      43571.5      0.2      0.5                      for i2 in range(len(path)):
   329    276704      68941.0      0.2      0.7                          next_i = (i2 + 1) % len(path)
   330    276704     264638.5      1.0      2.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    276704      49681.6      0.2      0.5                          if best_cost > insertion_cost:
   332     16358       3369.1      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333      1005        309.3      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   1781328    2285543.3      1.3     24.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      3443       3903.9      1.1      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      3443       1258.7      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      3443        809.1      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   1781328    2357319.2      1.3     25.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      7213       8178.7      1.1      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      7213       3046.4      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      1888     131001.8     69.4      1.4              heapq.heapify(h)
   346                                           
   347         1         17.4     17.4      0.0          self.tour = path
   348         1       1103.1   1103.1      0.0          self.calculateCost()


Optimal 64253
_________________
u2152
randomInsertion 1.2178996848725203
nearestInsertion 1.2187798140270028
cheapestInsertion 1.259935645142861
nearestNeighbor 1.2259567766673958
farthestInsertion 1.2147762040975816
furthestInsertion 1.2272557441847745

[('u2152', 1.2178996848725203, 1.2187798140270028, 1.259935645142861, 1.2259567766673958, 1.2147762040975816, 1.2272557441847745)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 3.38742 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.8      0.8      0.0          n = self.numCity
   103         1     169289.5 169289.5      5.0          distances = np.array(self.adj)
   104         1          1.6      1.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          0.8      0.8      0.0          in_path = {0}
   106         1        179.6    179.6      0.0          notInPath = [x for x in range(1, n)]
   107         1       2104.4   2104.4      0.1          random.shuffle(notInPath)
   108                                           
   109      2152        658.6      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      2151        491.4      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      2151        480.2      0.2      0.0              best_increase = np.inf
   115      2151        276.0      0.1      0.0              best_position = None
   116   2316627     357718.4      0.2     10.6              for i in range(len(path)):
   117   2314476     587338.8      0.3     17.3                  next_i = (i + 1) % len(path)
   118   2314476    1804054.5      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   2314476     425491.2      0.2     12.6                  if increase < best_increase:
   120    127932      16509.2      0.1      0.5                      best_increase = increase
   121    127932      19766.8      0.2      0.6                      best_position = next_i
   122                                           
   123      2151       1093.4      0.5      0.0              path.insert(best_position, to_insert)
   124      2151        758.2      0.4      0.0              in_path.add(to_insert)
   125                                           
   126         1          5.5      5.5      0.0          self.tour = path
   127         1       1205.3   1205.3      0.0          self.calculateCost()

Total time: 1.09173 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1          9.7      9.7      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         31.9     31.9      0.0          notVisited = set(range(1, self.numCity))
   134      2152        861.8      0.4      0.1          while len(self.tour) < self.numCity:
   135      2151        461.8      0.2      0.0              cost = np.inf
   136      2151        295.5      0.1      0.0              j = -1
   137   2316627     352795.3      0.2     32.3              for j2 in notVisited:
   138   2314476     697243.7      0.3     63.9                  if self.adj[self.tour[-1]][j2] < cost:
   139     99705      22817.0      0.2      2.1                      cost = self.adj[self.tour[-1]][j2]
   140     99705      14178.9      0.1      1.3                      j = j2
   141      2151        753.7      0.4      0.1              self.tour.append(j)
   142      2151        578.2      0.3      0.1              visited.add(j)
   143      2151        538.1      0.3      0.0              notVisited.remove(j)
   144         1       1158.5   1158.5      0.1          self.calculateCost()

Total time: 4.8547 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.7      0.7      0.0          n = self.numCity
   149         1     168086.2 168086.2      3.5          distances = np.array(self.adj)
   150         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.1      1.1      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156      2152        297.6      0.1      0.0          for i in range(1, n):
   157      2151       4904.1      2.3      0.1              h.append((distances[0, i], i))
   158         1        136.3    136.3      0.0          heapq.heapify(h)
   159                                           
   160      2152        803.4      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      2151       1649.8      0.8      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      2151        522.6      0.2      0.0              best_increase = np.inf
   166      2151        400.5      0.2      0.0              best_position = None
   167   2316627     361970.3      0.2      7.5              for i in range(len(path)):
   168   2314476     576846.7      0.2     11.9                  next_i = (i + 1) % len(path)
   169   2314476    1723691.8      0.7     35.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   2314476     433109.2      0.2      8.9                  if increase < best_increase:
   171    137053      17996.6      0.1      0.4                      best_increase = increase
   172    137053      26633.4      0.2      0.5                      best_position = i + 1
   173                                           
   174      2151       1050.3      0.5      0.0              path.insert(best_position, to_insert)
   175      2151        571.3      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   2314476     506114.9      0.2     10.4              for i, (cost, node) in enumerate(h):
   179   2312325     803908.8      0.3     16.6                  if node not in in_path and distances[to_insert, node] < cost:
   180    191360      61874.0      0.3      1.3                      h[i] = (distances[to_insert, node], node)
   181      2151     162832.6     75.7      3.4              heapq.heapify(h)
   182                                           
   183         1         17.0     17.0      0.0          self.tour = path
   184         1       1281.7   1281.7      0.0          self.calculateCost()

Total time: 12.0705 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.5      0.5      0.0          n = self.numCity
   189         1     168258.8 168258.8      1.4          adj = np.array(self.adj)
   190         1          1.8      1.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.1      1.1      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.2      0.2      0.0          h = []
   195      2152        318.8      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      2151       1371.7      0.6      0.0              cost = adj[0][i] + adj[i][0]
   198      2151      45259.2     21.0      0.4              h.append((cost, i, 0, 0))
   199         1        146.5    146.5      0.0          heapq.heapify(h)
   200                                           
   201      2152        986.8      0.5      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      2151       1791.3      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      2151        535.0      0.2      0.0              best_increase = np.inf
   207      2151        350.9      0.2      0.0              best_pos = None
   208   2316627     355617.5      0.2      2.9              for i in range(len(path)):
   209   2314476     593299.6      0.3      4.9                  next_i = (i + 1) % len(path)
   210   2314476    1766646.9      0.8     14.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   2314476     436632.0      0.2      3.6                  if increase < best_increase:
   212    176010      23914.8      0.1      0.2                      best_increase = increase
   213    176010      27360.6      0.2      0.2                      best_pos = next_i
   214                                           
   215      2151       1251.0      0.6      0.0              path.insert(best_pos, to_ins)
   216      2151        659.3      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   2314476     570079.1      0.2      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   2312325     896764.2      0.4      7.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      1057        217.5      0.2      0.0                      best_cost = np.inf
   225      1057        187.0      0.2      0.0                      posL, posR = -1, -1
   226    464323      71952.5      0.2      0.6                      for i2 in range(len(path)):
   227    463266     122008.0      0.3      1.0                          next_i = (i2 + 1) % len(path)
   228    463266     422507.4      0.9      3.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    463266      84384.9      0.2      0.7                          if best_cost > insertion_cost:
   230     34226       7252.0      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      1057        302.6      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   2312325    2862494.7      1.2     23.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235    131422     145613.1      1.1      1.2                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236    131422      50913.5      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239    131422      34915.3      0.3      0.3                      best_pos = (best_pos + 1) % (len(path))
   240   2312325    2971035.7      1.3     24.6                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    151253     170797.4      1.1      1.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    151253      66750.6      0.4      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      2151     166718.1     77.5      1.4              heapq.heapify(h)
   244                                           
   245         1         11.6     11.6      0.0          self.tour = path
   246         1       1201.4   1201.4      0.0          self.calculateCost()

Total time: 5.20774 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.6      0.6      0.0          n = self.numCity
   251         1     168426.3 168426.3      3.2          distances = np.array(self.adj)
   252         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.0      1.0      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.3      0.3      0.0          h = []
   257      2152        302.0      0.1      0.0          for i in range(1, n):
   258      2151        845.3      0.4      0.0              h.append((-distances[0, i], i))
   259         1        122.6    122.6      0.0          heapq.heapify(h)
   260                                           
   261      2152        818.8      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      2151       1615.9      0.8      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      2151        554.7      0.3      0.0              best_increase = np.inf
   267      2151        295.4      0.1      0.0              best_position = None
   268   2316627     343454.4      0.1      6.6              for i in range(len(path)):
   269   2314476     572578.6      0.2     11.0                  next_i = (i + 1) % len(path)
   270   2314476    1708855.4      0.7     32.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   2314476     413740.8      0.2      7.9                  if increase < best_increase:
   272    116227      14489.2      0.1      0.3                      best_increase = increase
   273    116227      21668.7      0.2      0.4                      best_position = i + 1
   274                                           
   275      2151       1094.5      0.5      0.0              path.insert(best_position, to_insert)
   276      2151        539.8      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   2314476     480479.9      0.2      9.2              for i, (cost, node) in enumerate(h):
   280   2312325     474509.8      0.2      9.1                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   2312325     833326.5      0.4     16.0                  if node not in in_path and distances[to_insert, node] < cost:
   283     10984       3876.3      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      2151     164896.0     76.7      3.2              heapq.heapify(h)
   285                                           
   286         1         15.9     15.9      0.0          self.tour = path
   287         1       1228.4   1228.4      0.0          self.calculateCost()

Total time: 11.9572 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.4      0.4      0.0          n = self.numCity
   292         1     167906.5 167906.5      1.4          adj = np.array(self.adj)
   293         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.2      1.2      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      2152        329.7      0.2      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      2151       1420.4      0.7      0.0              cost = adj[0][i] + adj[i][0]
   301      2151        683.1      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1        130.6    130.6      0.0          heapq.heapify(h)
   303                                           
   304      2152        888.5      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      2151       1741.0      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      2151        517.6      0.2      0.0              best_increase = np.inf
   310      2151        334.2      0.2      0.0              best_pos = None
   311   2316627     352459.0      0.2      2.9              for i in range(len(path)):
   312   2314476     590369.7      0.3      4.9                  next_i = (i + 1) % len(path)
   313   2314476    1817362.0      0.8     15.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   2314476     423507.9      0.2      3.5                  if increase < best_increase:
   315    112416      14623.0      0.1      0.1                      best_increase = increase
   316    112416      17280.7      0.2      0.1                      best_pos = next_i
   317                                           
   318      2151       1190.7      0.6      0.0              path.insert(best_pos, to_ins)
   319      2151        686.6      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   2314476     580830.4      0.3      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   2312325     464512.3      0.2      3.9                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   2312325     874217.2      0.4      7.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326      1446        301.0      0.2      0.0                      best_cost = np.inf
   327      1446        240.0      0.2      0.0                      posL, posR = -1, -1
   328    328504      51381.6      0.2      0.4                      for i2 in range(len(path)):
   329    327058      82227.7      0.3      0.7                          next_i = (i2 + 1) % len(path)
   330    327058     301484.5      0.9      2.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    327058      59221.0      0.2      0.5                          if best_cost > insertion_cost:
   332     21927       4492.0      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333      1446        461.9      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   2312325    2948772.6      1.3     24.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      4187       4734.0      1.1      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      4187       1609.4      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      4187       1041.4      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   2312325    3005577.8      1.3     25.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      8204       9313.3      1.1      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      8204       3618.4      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      2151     170451.1     79.2      1.4              heapq.heapify(h)
   346                                           
   347         1         13.2     13.2      0.0          self.tour = path
   348         1       1234.3   1234.3      0.0          self.calculateCost()


Optimal 378032
_________________
pr2392
randomInsertion 1.156837745701672
nearestInsertion 1.245722704057029
cheapestInsertion 1.2498180312953715
nearestNeighbor 1.2200223520750098
farthestInsertion 1.136359696881029
furthestInsertion 1.1754711114562184

[('pr2392', 1.156837745701672, 1.245722704057029, 1.2498180312953715, 1.2200223520750098, 1.136359696881029, 1.1754711114562184)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 4.15961 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          1.0      1.0      0.0          n = self.numCity
   103         1     210538.7 210538.7      5.1          distances = np.array(self.adj)
   104         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.4      1.4      0.0          in_path = {0}
   106         1        180.0    180.0      0.0          notInPath = [x for x in range(1, n)]
   107         1       2350.3   2350.3      0.1          random.shuffle(notInPath)
   108                                           
   109      2392        736.6      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      2391        660.0      0.3      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      2391        669.6      0.3      0.0              best_increase = np.inf
   115      2391        347.2      0.1      0.0              best_position = None
   116   2862027     447994.0      0.2     10.8              for i in range(len(path)):
   117   2859636     698209.6      0.2     16.8                  next_i = (i + 1) % len(path)
   118   2859636    2215003.8      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   2859636     538571.0      0.2     12.9                  if increase < best_increase:
   120    143763      18727.5      0.1      0.5                      best_increase = increase
   121    143763      22158.5      0.2      0.5                      best_position = next_i
   122                                           
   123      2391       1303.6      0.5      0.0              path.insert(best_position, to_insert)
   124      2391        850.6      0.4      0.0              in_path.add(to_insert)
   125                                           
   126         1          5.2      5.2      0.0          self.tour = path
   127         1       1299.5   1299.5      0.0          self.calculateCost()

Total time: 1.37235 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1         10.6     10.6      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         36.8     36.8      0.0          notVisited = set(range(1, self.numCity))
   134      2392        928.0      0.4      0.1          while len(self.tour) < self.numCity:
   135      2391        592.1      0.2      0.0              cost = np.inf
   136      2391        295.0      0.1      0.0              j = -1
   137   2862027     443937.5      0.2     32.3              for j2 in notVisited:
   138   2859636     888005.6      0.3     64.7                  if self.adj[self.tour[-1]][j2] < cost:
   139     95577      21958.0      0.2      1.6                      cost = self.adj[self.tour[-1]][j2]
   140     95577      13123.5      0.1      1.0                      j = j2
   141      2391        930.4      0.4      0.1              self.tour.append(j)
   142      2391        681.3      0.3      0.0              visited.add(j)
   143      2391        619.6      0.3      0.0              notVisited.remove(j)
   144         1       1234.8   1234.8      0.1          self.calculateCost()

Total time: 5.95186 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.7      0.7      0.0          n = self.numCity
   149         1     212151.3 212151.3      3.6          distances = np.array(self.adj)
   150         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.2      1.2      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.2      0.2      0.0          h = []
   156      2392        332.1      0.1      0.0          for i in range(1, n):
   157      2391       2092.7      0.9      0.0              h.append((distances[0, i], i))
   158         1        145.0    145.0      0.0          heapq.heapify(h)
   159                                           
   160      2392        891.1      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      2391       1866.2      0.8      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      2391        638.6      0.3      0.0              best_increase = np.inf
   166      2391        439.6      0.2      0.0              best_position = None
   167   2862027     428974.7      0.1      7.2              for i in range(len(path)):
   168   2859636     697302.8      0.2     11.7                  next_i = (i + 1) % len(path)
   169   2859636    2122949.6      0.7     35.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   2859636     534381.5      0.2      9.0                  if increase < best_increase:
   171    185042      25572.4      0.1      0.4                      best_increase = increase
   172    185042      34643.3      0.2      0.6                      best_position = i + 1
   173                                           
   174      2391       1306.5      0.5      0.0              path.insert(best_position, to_insert)
   175      2391        691.9      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   2859636     605910.7      0.2     10.2              for i, (cost, node) in enumerate(h):
   179   2857245    1000538.9      0.4     16.8                  if node not in in_path and distances[to_insert, node] < cost:
   180    242380      78675.0      0.3      1.3                      h[i] = (distances[to_insert, node], node)
   181      2391     200949.7     84.0      3.4              heapq.heapify(h)
   182                                           
   183         1         17.7     17.7      0.0          self.tour = path
   184         1       1388.6   1388.6      0.0          self.calculateCost()

Total time: 14.8409 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.4      0.4      0.0          n = self.numCity
   189         1     210693.7 210693.7      1.4          adj = np.array(self.adj)
   190         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.4      1.4      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.3      0.3      0.0          h = []
   195      2392        378.7      0.2      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      2391       1613.3      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      2391      57027.3     23.9      0.4              h.append((cost, i, 0, 0))
   199         1        148.0    148.0      0.0          heapq.heapify(h)
   200                                           
   201      2392       1084.8      0.5      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      2391       2099.3      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      2391        638.4      0.3      0.0              best_increase = np.inf
   207      2391        399.1      0.2      0.0              best_pos = None
   208   2862027     463142.5      0.2      3.1              for i in range(len(path)):
   209   2859636     709583.9      0.2      4.8                  next_i = (i + 1) % len(path)
   210   2859636    2164562.2      0.8     14.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   2859636     550737.3      0.2      3.7                  if increase < best_increase:
   212    188699      25576.9      0.1      0.2                      best_increase = increase
   213    188699      30486.9      0.2      0.2                      best_pos = next_i
   214                                           
   215      2391       1433.7      0.6      0.0              path.insert(best_pos, to_ins)
   216      2391        766.8      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   2859636     725767.7      0.3      4.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   2857245    1108408.4      0.4      7.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      2807        567.8      0.2      0.0                      best_cost = np.inf
   225      2807        460.1      0.2      0.0                      posL, posR = -1, -1
   226    496676      81494.4      0.2      0.5                      for i2 in range(len(path)):
   227    493869     125052.3      0.3      0.8                          next_i = (i2 + 1) % len(path)
   228    493869     460883.8      0.9      3.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    493869     101525.8      0.2      0.7                          if best_cost > insertion_cost:
   230     40496       8942.7      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      2807        694.7      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   2857245    3510369.2      1.2     23.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235    151661     170491.0      1.1      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236    151661      58686.8      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239    151661      36948.8      0.2      0.2                      best_pos = (best_pos + 1) % (len(path))
   240   2857245    3741677.6      1.3     25.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    173212     197938.1      1.1      1.3                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    173212      78532.8      0.5      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      2391     210648.8     88.1      1.4              heapq.heapify(h)
   244                                           
   245         1         13.4     13.4      0.0          self.tour = path
   246         1       1423.3   1423.3      0.0          self.calculateCost()

Total time: 6.63631 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1     210405.2 210405.2      3.2          distances = np.array(self.adj)
   252         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.2      1.2      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.1      0.1      0.0          h = []
   257      2392        330.4      0.1      0.0          for i in range(1, n):
   258      2391        978.2      0.4      0.0              h.append((-distances[0, i], i))
   259         1        148.4    148.4      0.0          heapq.heapify(h)
   260                                           
   261      2392        916.8      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      2391       1992.7      0.8      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      2391        604.0      0.3      0.0              best_increase = np.inf
   267      2391        383.3      0.2      0.0              best_position = None
   268   2862027     432802.9      0.2      6.5              for i in range(len(path)):
   269   2859636     689159.2      0.2     10.4                  next_i = (i + 1) % len(path)
   270   2859636    2242735.0      0.8     33.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   2859636     555418.6      0.2      8.4                  if increase < best_increase:
   272    139676      16127.3      0.1      0.2                      best_increase = increase
   273    139676      25982.3      0.2      0.4                      best_position = i + 1
   274                                           
   275      2391       1331.4      0.6      0.0              path.insert(best_position, to_insert)
   276      2391        693.2      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   2859636     638249.9      0.2      9.6              for i, (cost, node) in enumerate(h):
   280   2857245     552279.5      0.2      8.3                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   2857245    1050639.3      0.4     15.8                  if node not in in_path and distances[to_insert, node] < cost:
   283     13083       4909.3      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      2391     208810.0     87.3      3.1              heapq.heapify(h)
   285                                           
   286         1         18.9     18.9      0.0          self.tour = path
   287         1       1387.8   1387.8      0.0          self.calculateCost()

Total time: 14.7685 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.5      0.5      0.0          n = self.numCity
   292         1     209549.9 209549.9      1.4          adj = np.array(self.adj)
   293         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.5      1.5      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.3      0.3      0.0          h = []
   298      2392        332.0      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      2391       1527.3      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301      2391        781.8      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1        159.0    159.0      0.0          heapq.heapify(h)
   303                                           
   304      2392       1038.5      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      2391       2070.2      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      2391        629.4      0.3      0.0              best_increase = np.inf
   310      2391        396.2      0.2      0.0              best_pos = None
   311   2862027     447147.7      0.2      3.0              for i in range(len(path)):
   312   2859636     683892.8      0.2      4.6                  next_i = (i + 1) % len(path)
   313   2859636    2264979.1      0.8     15.3                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   2859636     553557.8      0.2      3.7                  if increase < best_increase:
   315    134065      17873.6      0.1      0.1                      best_increase = increase
   316    134065      20821.6      0.2      0.1                      best_pos = next_i
   317                                           
   318      2391       1431.5      0.6      0.0              path.insert(best_pos, to_ins)
   319      2391        722.4      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   2859636     773484.4      0.3      5.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   2857245     552897.6      0.2      3.7                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   2857245    1062332.0      0.4      7.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326      1364        276.7      0.2      0.0                      best_cost = np.inf
   327      1364        230.9      0.2      0.0                      posL, posR = -1, -1
   328    359398      54993.8      0.2      0.4                      for i2 in range(len(path)):
   329    358034      86445.2      0.2      0.6                          next_i = (i2 + 1) % len(path)
   330    358034     334836.3      0.9      2.3                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    358034      70201.1      0.2      0.5                          if best_cost > insertion_cost:
   332     21627       4636.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333      1364        417.7      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   2857245    3630969.1      1.3     24.6                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      4215       4821.0      1.1      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      4215       1620.3      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      4215       1015.8      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   2857245    3753841.2      1.3     25.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343      9079      10349.9      1.1      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344      9079       3954.8      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      2391     212787.3     89.0      1.4              heapq.heapify(h)
   346                                           
   347         1         15.1     15.1      0.0          self.tour = path
   348         1       1491.2   1491.2      0.0          self.calculateCost()


Optimal 137694
_________________
pcb3038
randomInsertion 1.1501203576298353
nearestInsertion 1.2302609343438595
cheapestInsertion 1.2227237901856507
nearestNeighbor 1.27509369891956
farthestInsertion 1.150255009309431
furthestInsertion 1.165828274025563

[('pcb3038', 1.1501203576298353, 1.2302609343438595, 1.2227237901856507, 1.27509369891956, 1.150255009309431, 1.165828274025563)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 6.81134 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.9      0.9      0.0          n = self.numCity
   103         1     350518.7 350518.7      5.1          distances = np.array(self.adj)
   104         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          1.2      1.2      0.0          in_path = {0}
   106         1        226.5    226.5      0.0          notInPath = [x for x in range(1, n)]
   107         1       2904.9   2904.9      0.0          random.shuffle(notInPath)
   108                                           
   109      3038        955.5      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      3037        729.5      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      3037        722.7      0.2      0.0              best_increase = np.inf
   115      3037        431.1      0.1      0.0              best_position = None
   116   4616240     746276.3      0.2     11.0              for i in range(len(path)):
   117   4613203    1114614.1      0.2     16.4                  next_i = (i + 1) % len(path)
   118   4613203    3651722.9      0.8     53.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   4613203     877845.1      0.2     12.9                  if increase < best_increase:
   120    196877      27874.3      0.1      0.4                      best_increase = increase
   121    196877      31899.3      0.2      0.5                      best_position = next_i
   122                                           
   123      3037       1806.3      0.6      0.0              path.insert(best_position, to_insert)
   124      3037       1026.7      0.3      0.0              in_path.add(to_insert)
   125                                           
   126         1          6.6      6.6      0.0          self.tour = path
   127         1       1771.5   1771.5      0.0          self.calculateCost()

Total time: 2.24768 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1         14.5     14.5      0.0          self.tour = [0]
   132         1          1.8      1.8      0.0          visited = set([0])
   133         1         40.6     40.6      0.0          notVisited = set(range(1, self.numCity))
   134      3038       1371.4      0.5      0.1          while len(self.tour) < self.numCity:
   135      3037        713.3      0.2      0.0              cost = np.inf
   136      3037        437.8      0.1      0.0              j = -1
   137   4616240     720671.5      0.2     32.1              for j2 in notVisited:
   138   4613203    1440176.1      0.3     64.1                  if self.adj[self.tour[-1]][j2] < cost:
   139    206435      49491.8      0.2      2.2                      cost = self.adj[self.tour[-1]][j2]
   140    206435      29978.6      0.1      1.3                      j = j2
   141      3037       1332.3      0.4      0.1              self.tour.append(j)
   142      3037        916.0      0.3      0.0              visited.add(j)
   143      3037        839.1      0.3      0.0              notVisited.remove(j)
   144         1       1695.8   1695.8      0.1          self.calculateCost()

Total time: 9.83848 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.6      0.6      0.0          n = self.numCity
   149         1     352694.6 352694.6      3.6          distances = np.array(self.adj)
   150         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.2      1.2      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      3038        426.7      0.1      0.0          for i in range(1, n):
   157      3037     112119.4     36.9      1.1              h.append((distances[0, i], i))
   158         1        240.0    240.0      0.0          heapq.heapify(h)
   159                                           
   160      3038       1239.7      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      3037       2494.5      0.8      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      3037        786.2      0.3      0.0              best_increase = np.inf
   166      3037        547.4      0.2      0.0              best_position = None
   167   4616240     727929.1      0.2      7.4              for i in range(len(path)):
   168   4613203    1117884.8      0.2     11.4                  next_i = (i + 1) % len(path)
   169   4613203    3496631.0      0.8     35.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   4613203     885900.3      0.2      9.0                  if increase < best_increase:
   171    257897      36851.7      0.1      0.4                      best_increase = increase
   172    257897      49575.6      0.2      0.5                      best_position = i + 1
   173                                           
   174      3037       1816.4      0.6      0.0              path.insert(best_position, to_insert)
   175      3037        861.2      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   4613203     969772.2      0.2      9.9              for i, (cost, node) in enumerate(h):
   179   4610166    1631269.5      0.4     16.6                  if node not in in_path and distances[to_insert, node] < cost:
   180    321393     107839.4      0.3      1.1                      h[i] = (distances[to_insert, node], node)
   181      3037     339808.3    111.9      3.5              heapq.heapify(h)
   182                                           
   183         1         25.1     25.1      0.0          self.tour = path
   184         1       1765.0   1765.0      0.0          self.calculateCost()

Total time: 24.2578 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.4      0.4      0.0          n = self.numCity
   189         1     351922.4 351922.4      1.5          adj = np.array(self.adj)
   190         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.2      1.2      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.5      0.5      0.0          h = []
   195      3038        431.7      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      3037       1896.8      0.6      0.0              cost = adj[0][i] + adj[i][0]
   198      3037        933.6      0.3      0.0              h.append((cost, i, 0, 0))
   199         1        240.2    240.2      0.0          heapq.heapify(h)
   200                                           
   201      3038       1374.2      0.5      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      3037       2680.3      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      3037        820.5      0.3      0.0              best_increase = np.inf
   207      3037        578.7      0.2      0.0              best_pos = None
   208   4616240     741100.9      0.2      3.1              for i in range(len(path)):
   209   4613203    1139482.0      0.2      4.7                  next_i = (i + 1) % len(path)
   210   4613203    3503474.8      0.8     14.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   4613203     892558.7      0.2      3.7                  if increase < best_increase:
   212    273241      37924.1      0.1      0.2                      best_increase = increase
   213    273241      44812.3      0.2      0.2                      best_pos = next_i
   214                                           
   215      3037       2150.4      0.7      0.0              path.insert(best_pos, to_ins)
   216      3037        896.5      0.3      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   4613203    1099415.3      0.2      4.5              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   4610166    1757374.9      0.4      7.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      3425        719.3      0.2      0.0                      best_cost = np.inf
   225      3425        554.0      0.2      0.0                      posL, posR = -1, -1
   226    810789     134141.7      0.2      0.6                      for i2 in range(len(path)):
   227    807364     203710.0      0.3      0.8                          next_i = (i2 + 1) % len(path)
   228    807364     814765.3      1.0      3.4                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229    807364     161478.5      0.2      0.7                          if best_cost > insertion_cost:
   230     57395      13157.7      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      3425        849.1      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   4610166    5995732.1      1.3     24.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235    194006     225782.8      1.2      0.9                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236    194006      73872.0      0.4      0.3                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239    194006      48910.6      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   240   4610166    6293155.8      1.4     25.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    222141     264599.0      1.2      1.1                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    222141      98989.8      0.4      0.4                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      3037     345492.6    113.8      1.4              heapq.heapify(h)
   244                                           
   245         1         18.8     18.8      0.0          self.tour = path
   246         1       1753.3   1753.3      0.0          self.calculateCost()

Total time: 10.8503 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.4      0.4      0.0          n = self.numCity
   251         1     350236.9 350236.9      3.2          distances = np.array(self.adj)
   252         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.3      1.3      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.4      0.4      0.0          h = []
   257      3038        445.3      0.1      0.0          for i in range(1, n):
   258      3037       1320.5      0.4      0.0              h.append((-distances[0, i], i))
   259         1        201.5    201.5      0.0          heapq.heapify(h)
   260                                           
   261      3038       1275.2      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      3037       2589.8      0.9      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      3037        791.7      0.3      0.0              best_increase = np.inf
   267      3037        450.6      0.1      0.0              best_position = None
   268   4616240     720170.3      0.2      6.6              for i in range(len(path)):
   269   4613203    1105420.9      0.2     10.2                  next_i = (i + 1) % len(path)
   270   4613203    3697040.0      0.8     34.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   4613203     848728.1      0.2      7.8                  if increase < best_increase:
   272    196551      27642.8      0.1      0.3                      best_increase = increase
   273    196551      35857.5      0.2      0.3                      best_position = i + 1
   274                                           
   275      3037       1925.8      0.6      0.0              path.insert(best_position, to_insert)
   276      3037        865.8      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   4613203    1008741.5      0.2      9.3              for i, (cost, node) in enumerate(h):
   280   4610166     964710.5      0.2      8.9                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   4610166    1728449.3      0.4     15.9                  if node not in in_path and distances[to_insert, node] < cost:
   283     17274       6378.4      0.4      0.1                      h[i] = (-distances[to_insert, node], node)
   284      3037     345242.3    113.7      3.2              heapq.heapify(h)
   285                                           
   286         1         25.4     25.4      0.0          self.tour = path
   287         1       1829.7   1829.7      0.0          self.calculateCost()

Total time: 24.3444 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.4      0.4      0.0          n = self.numCity
   292         1     350362.7 350362.7      1.4          adj = np.array(self.adj)
   293         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.1      1.1      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      3038        424.5      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      3037       1846.3      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301      3037       1007.1      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1        174.7    174.7      0.0          heapq.heapify(h)
   303                                           
   304      3038       1309.2      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      3037       2612.9      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      3037        754.0      0.2      0.0              best_increase = np.inf
   310      3037        466.2      0.2      0.0              best_pos = None
   311   4616240     716155.9      0.2      2.9              for i in range(len(path)):
   312   4613203    1132488.6      0.2      4.7                  next_i = (i + 1) % len(path)
   313   4613203    3719170.6      0.8     15.3                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   4613203     859418.2      0.2      3.5                  if increase < best_increase:
   315    202605      27834.4      0.1      0.1                      best_increase = increase
   316    202605      31729.8      0.2      0.1                      best_pos = next_i
   317                                           
   318      3037       1894.2      0.6      0.0              path.insert(best_pos, to_ins)
   319      3037        961.8      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   4613203    1159700.2      0.3      4.8              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   4610166     914571.4      0.2      3.8                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   4610166    1722929.5      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326      1967        436.1      0.2      0.0                      best_cost = np.inf
   327      1967        327.3      0.2      0.0                      posL, posR = -1, -1
   328    509736      80571.4      0.2      0.3                      for i2 in range(len(path)):
   329    507769     123479.9      0.2      0.5                          next_i = (i2 + 1) % len(path)
   330    507769     518801.3      1.0      2.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331    507769      94297.1      0.2      0.4                          if best_cost > insertion_cost:
   332     30809       6481.9      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333      1967        590.4      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   4610166    6120271.2      1.3     25.1                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      5631       6681.2      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      5631       2047.4      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      5631       1362.4      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   4610166    6375424.5      1.4     26.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343     11720      13841.3      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344     11720       5022.0      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      3037     347054.0    114.3      1.4              heapq.heapify(h)
   346                                           
   347         1         19.4     19.4      0.0          self.tour = path
   348         1       1870.2   1870.2      0.0          self.calculateCost()


Optimal 28772
_________________
fl3795
randomInsertion 1.2012058549820117
nearestInsertion 1.1635155384095488
cheapestInsertion 1.1728881675903164
nearestNeighbor 1.2804602891114583
farthestInsertion 1.1834216883845732
furthestInsertion 1.2032682938788724

[('fl3795', 1.2012058549820117, 1.1635155384095488, 1.1728881675903164, 1.2804602891114583, 1.1834216883845732, 1.2032682938788724)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 10.9395 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 100

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   100                                               @profile
   101                                               def randomInsertion(self):
   102         1          0.8      0.8      0.0          n = self.numCity
   103         1     582279.4 582279.4      5.3          distances = np.array(self.adj)
   104         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   105         1          0.9      0.9      0.0          in_path = {0}
   106         1        285.7    285.7      0.0          notInPath = [x for x in range(1, n)]
   107         1       3717.5   3717.5      0.0          random.shuffle(notInPath)
   108                                           
   109      3795       1234.8      0.3      0.0          while len(path) < n:
   110                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   111      3794        938.9      0.2      0.0              to_insert = notInPath.pop()
   112                                           
   113                                                       # Trova la posizione ottimale per inserire la città trovata
   114      3794        986.9      0.3      0.0              best_increase = np.inf
   115      3794        523.3      0.1      0.0              best_position = None
   116   7202909    1175665.4      0.2     10.7              for i in range(len(path)):
   117   7199115    1818887.1      0.3     16.6                  next_i = (i + 1) % len(path)
   118   7199115    5878781.8      0.8     53.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   119   7199115    1355665.8      0.2     12.4                  if increase < best_increase:
   120    391656      52696.1      0.1      0.5                      best_increase = increase
   121    391656      61361.5      0.2      0.6                      best_position = next_i
   122                                           
   123      3794       2715.0      0.7      0.0              path.insert(best_position, to_insert)
   124      3794       1465.2      0.4      0.0              in_path.add(to_insert)
   125                                           
   126         1          7.5      7.5      0.0          self.tour = path
   127         1       2259.9   2259.9      0.0          self.calculateCost()

Total time: 3.5909 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 129

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   129                                               @profile
   130                                               def nearestNeighbor(self):
   131         1         20.3     20.3      0.0          self.tour = [0]
   132         1          1.3      1.3      0.0          visited = set([0])
   133         1         49.3     49.3      0.0          notVisited = set(range(1, self.numCity))
   134      3795       1842.5      0.5      0.1          while len(self.tour) < self.numCity:
   135      3794        897.0      0.2      0.0              cost = np.inf
   136      3794        527.3      0.1      0.0              j = -1
   137   7202909    1133216.7      0.2     31.6              for j2 in notVisited:
   138   7199115    2431022.9      0.3     67.7                  if self.adj[self.tour[-1]][j2] < cost:
   139     44398      10602.4      0.2      0.3                      cost = self.adj[self.tour[-1]][j2]
   140     44398       6879.9      0.2      0.2                      j = j2
   141      3794       1579.8      0.4      0.0              self.tour.append(j)
   142      3794       1170.7      0.3      0.0              visited.add(j)
   143      3794       1038.0      0.3      0.0              notVisited.remove(j)
   144         1       2050.8   2050.8      0.1          self.calculateCost()

Total time: 15.6845 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                               @profile
   147                                               def nearestInsertion(self):
   148         1          0.8      0.8      0.0          n = self.numCity
   149         1     583988.2 583988.2      3.7          distances = np.array(self.adj)
   150         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   151         1          1.0      1.0      0.0          in_path = {0}
   152                                           
   153                                           
   154                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   155         1          0.3      0.3      0.0          h = []
   156      3795        564.0      0.1      0.0          for i in range(1, n):
   157      3794       3840.7      1.0      0.0              h.append((distances[0, i], i))
   158         1        242.0    242.0      0.0          heapq.heapify(h)
   159                                           
   160      3795       1546.6      0.4      0.0          while len(path) < n:
   161                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   162      3794       3229.0      0.9      0.0              _, to_insert = heapq.heappop(h)
   163                                           
   164                                                       # Trova la posizione ottimale per inserire la città trovata
   165      3794        940.5      0.2      0.0              best_increase = np.inf
   166      3794        687.0      0.2      0.0              best_position = None
   167   7202909    1161950.1      0.2      7.4              for i in range(len(path)):
   168   7199115    1834051.0      0.3     11.7                  next_i = (i + 1) % len(path)
   169   7199115    5502667.1      0.8     35.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   170   7199115    1353527.7      0.2      8.6                  if increase < best_increase:
   171    623776      87403.6      0.1      0.6                      best_increase = increase
   172    623776     122252.4      0.2      0.8                      best_position = i + 1
   173                                           
   174      3794       2572.0      0.7      0.0              path.insert(best_position, to_insert)
   175      3794       1121.3      0.3      0.0              in_path.add(to_insert)
   176                                           
   177                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   178   7199115    1549834.0      0.2      9.9              for i, (cost, node) in enumerate(h):
   179   7195321    2561669.7      0.4     16.3                  if node not in in_path and distances[to_insert, node] < cost:
   180   1139877     374336.9      0.3      2.4                      h[i] = (distances[to_insert, node], node)
   181      3794     535946.6    141.3      3.4              heapq.heapify(h)
   182                                           
   183         1         35.7     35.7      0.0          self.tour = path
   184         1       2140.8   2140.8      0.0          self.calculateCost()

Total time: 49.7082 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               @profile
   187                                               def cheapestInsertion(self):
   188         1          0.7      0.7      0.0          n = self.numCity
   189         1     581477.9 581477.9      1.2          adj = np.array(self.adj)
   190         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   191         1          1.1      1.1      0.0          in_path = {0}
   192                                           
   193                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   194         1          0.3      0.3      0.0          h = []
   195      3795        538.2      0.1      0.0          for i in range(1, n):
   196                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   197      3794       2515.0      0.7      0.0              cost = adj[0][i] + adj[i][0]
   198      3794       1149.4      0.3      0.0              h.append((cost, i, 0, 0))
   199         1        245.2    245.2      0.0          heapq.heapify(h)
   200                                           
   201      3795       1881.8      0.5      0.0          while len(path) < n:
   202                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   203      3794       3655.3      1.0      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   204                                           
   205                                                       # Trova la posizione ottimale per inserire la città trovata
   206      3794       1087.7      0.3      0.0              best_increase = np.inf
   207      3794        695.1      0.2      0.0              best_pos = None
   208   7202909    1141746.7      0.2      2.3              for i in range(len(path)):
   209   7199115    1910181.4      0.3      3.8                  next_i = (i + 1) % len(path)
   210   7199115    5686009.2      0.8     11.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   211   7199115    1388952.0      0.2      2.8                  if increase < best_increase:
   212    662505      96349.2      0.1      0.2                      best_increase = increase
   213    662505     111152.0      0.2      0.2                      best_pos = next_i
   214                                           
   215      3794       2943.4      0.8      0.0              path.insert(best_pos, to_ins)
   216      3794       1329.0      0.4      0.0              in_path.add(to_ins)
   217                                           
   218                                                       # A - B - C
   219                                           
   220                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   221   7199115    1759388.6      0.2      3.5              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   222                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   223   7195321    2860827.0      0.4      5.8                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   224      7859       1790.1      0.2      0.0                      best_cost = np.inf
   225      7859       1401.2      0.2      0.0                      posL, posR = -1, -1
   226   7371483    1209666.8      0.2      2.4                      for i2 in range(len(path)):
   227   7363624    1948142.4      0.3      3.9                          next_i = (i2 + 1) % len(path)
   228   7363624    7580362.7      1.0     15.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   229   7363624    1394475.8      0.2      2.8                          if best_cost > insertion_cost:
   230    686279     151470.6      0.2      0.3                              best_cost, posL, posR = insertion_cost, i2, next_i
   231      7859       2107.6      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   232                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   233                                                           # (best_pos - 1) -- node -- to_ins
   234   7195321    9705736.0      1.3     19.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   235    393479     474730.6      1.2      1.0                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   236    393479     152059.7      0.4      0.3                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   237                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   238                                                           # to_ins -- node -- (best_pos + 1) 
   239    393479     100223.9      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   240   7195321   10123018.9      1.4     20.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   241    452074     552358.1      1.2      1.1                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   242    452074     202129.2      0.4      0.4                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   243      3794     554107.3    146.0      1.1              heapq.heapify(h)
   244                                           
   245         1         27.6     27.6      0.0          self.tour = path
   246         1       2236.5   2236.5      0.0          self.calculateCost()

Total time: 16.9113 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 248

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   248                                               @profile
   249                                               def farthestInsertion(self):
   250         1          0.5      0.5      0.0          n = self.numCity
   251         1     582078.7 582078.7      3.4          distances = np.array(self.adj)
   252         1          0.8      0.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   253         1          1.1      1.1      0.0          in_path = {0}
   254                                           
   255                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   256         1          0.2      0.2      0.0          h = []
   257      3795        531.8      0.1      0.0          for i in range(1, n):
   258      3794       4130.6      1.1      0.0              h.append((-distances[0, i], i))
   259         1        250.2    250.2      0.0          heapq.heapify(h)
   260                                           
   261      3795       1518.1      0.4      0.0          while len(path) < n:
   262                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   263      3794       3325.0      0.9      0.0              _, to_insert = heapq.heappop(h)
   264                                           
   265                                                       # Trova la posizione ottimale per inserire la città trovata
   266      3794        943.1      0.2      0.0              best_increase = np.inf
   267      3794        569.2      0.2      0.0              best_position = None
   268   7202909    1114253.8      0.2      6.6              for i in range(len(path)):
   269   7199115    1831533.9      0.3     10.8                  next_i = (i + 1) % len(path)
   270   7199115    5512005.6      0.8     32.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   271   7199115    1323098.9      0.2      7.8                  if increase < best_increase:
   272    340283      44338.4      0.1      0.3                      best_increase = increase
   273    340283      63034.0      0.2      0.4                      best_position = i + 1
   274                                           
   275      3794       2477.1      0.7      0.0              path.insert(best_position, to_insert)
   276      3794       1141.5      0.3      0.0              in_path.add(to_insert)
   277                                           
   278                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   279   7199115    1545345.9      0.2      9.1              for i, (cost, node) in enumerate(h):
   280   7195321    1518525.4      0.2      9.0                  cost *= -1
   281                                                           # cerco comunque di minimizzare distances!
   282   7195321    2780395.0      0.4     16.4                  if node not in in_path and distances[to_insert, node] < cost:
   283     20972       7948.0      0.4      0.0                      h[i] = (-distances[to_insert, node], node)
   284      3794     571559.9    150.6      3.4              heapq.heapify(h)
   285                                           
   286         1         51.2     51.2      0.0          self.tour = path
   287         1       2233.3   2233.3      0.0          self.calculateCost()

Total time: 39.4772 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 289

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   289                                               @profile
   290                                               def furthestInsertion(self):
   291         1          0.6      0.6      0.0          n = self.numCity
   292         1     581378.6 581378.6      1.5          adj = np.array(self.adj)
   293         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   294         1          1.1      1.1      0.0          in_path = {0}
   295                                           
   296                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   297         1          0.2      0.2      0.0          h = []
   298      3795        538.0      0.1      0.0          for i in range(1, n):
   299                                                       #cost = adj[0][i] + adj[i][0] - adj[0][0]
   300      3794       2463.2      0.6      0.0              cost = adj[0][i] + adj[i][0]
   301      3794       1286.3      0.3      0.0              h.append((-cost, i, 0, 0))
   302         1        229.5    229.5      0.0          heapq.heapify(h)
   303                                           
   304      3795       1687.6      0.4      0.0          while len(path) < n:
   305                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   306      3794       3359.2      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   307                                           
   308                                                       # Trova la posizione ottimale per inserire la città trovata
   309      3794        980.6      0.3      0.0              best_increase = np.inf
   310      3794        603.8      0.2      0.0              best_pos = None
   311   7202909    1118527.6      0.2      2.8              for i in range(len(path)):
   312   7199115    1851613.1      0.3      4.7                  next_i = (i + 1) % len(path)
   313   7199115    5679032.8      0.8     14.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   314   7199115    1343660.0      0.2      3.4                  if increase < best_increase:
   315    497516      69255.3      0.1      0.2                      best_increase = increase
   316    497516      78441.5      0.2      0.2                      best_pos = next_i
   317                                           
   318      3794       2529.1      0.7      0.0              path.insert(best_pos, to_ins)
   319      3794       1177.4      0.3      0.0              in_path.add(to_ins)
   320                                           
   321                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   322   7199115    1850969.2      0.3      4.7              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   323   7195321    1453902.1      0.2      3.7                  cost *= -1
   324                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   325   7195321    2787705.2      0.4      7.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   326      2099        499.7      0.2      0.0                      best_cost = np.inf
   327      2099        396.4      0.2      0.0                      posL, posR = -1, -1
   328   1067955     170871.9      0.2      0.4                      for i2 in range(len(path)):
   329   1065856     271639.7      0.3      0.7                          next_i = (i2 + 1) % len(path)
   330   1065856    1119122.8      1.0      2.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   331   1065856     199913.3      0.2      0.5                          if best_cost > insertion_cost:
   332     84997      18708.8      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   333      2099        669.2      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   334                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   335                                                           # (best_pos - 1) -- node -- to_ins
   336   7195321    9934512.2      1.4     25.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   337      7958       9532.1      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   338      7958       2957.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   339                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   340                                                           # to_ins -- node -- (best_pos + 1) 
   341      7958       2013.3      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   342   7195321   10318098.3      1.4     26.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   343     17085      20763.1      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   344     17085       7324.7      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   345      3794     568616.2    149.9      1.4              heapq.heapify(h)
   346                                           
   347         1         29.6     29.6      0.0          self.tour = path
   348         1       2187.6   2187.6      0.0          self.calculateCost()

