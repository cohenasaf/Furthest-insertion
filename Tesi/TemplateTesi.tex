% Tesi D.S.I. - modello preso da
% Stanford University PhD thesis style -- modifications to the report style
\documentclass[a4paper,12pt]{report}
\usepackage[a4paper]{geometry}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{epsfig}
\usepackage[italian]{babel}
\usepackage{setspace}
\usepackage{tesi}
\usepackage[utf8]{inputenc}
\usepackage{algorithmicx}
\usepackage{pythonhighlight}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{tikz}
\usepackage{framed}
\usepackage{fancyvrb}
\usepackage{listings,lipsum}

\newenvironment{teor}{\begin{myteor}\sl}{\end{myteor}}
%
%
%			TITOLO: Furthest Insertion Algorithm 
%
\begin{document}
\title{Furthest Insertion Algorithm}
\author{Asaf COHEN}
\dept{Corso di Laurea in Informatica} 
\anno{2023-2024}
\matricola{975599}
\relatore{Prof. Giovanni RIGHINI}
%
%        \submitdate{month year in which submitted to GPO}
%		- date LaTeX'd if omitted
%	\copyrightyear{year degree conferred (next year if submitted in Dec.)}
%		- year LaTeX'd (or next year, in December) if omitted
%	\copyrighttrue or \copyrightfalse
%		- produce or don't produce a copyright page (false by default)
%	\figurespagetrue or \figurespagefalse
%		- produce or don't produce a List of Figures page
%		  (false by default)
%	\tablespagetrue or \tablespagefalse
%		- produce or don't produce a List of Tables page
%		  (false by default)
% 
%			DEDICA
%

\beforepreface

\clearpage
\null
\thispagestyle{empty}
\clearpage

\prefacesection{Ringraziamenti}
        {\hfill \Large {\sl dedicato a DA COMPLETARE\dots}}
% 
%			PREFAZIONE
%

\clearpage
\null
\thispagestyle{empty}
\clearpage

\prefacesection{Abstract}
Il Problema del Commesso Viaggiatore (TSP) rappresenta una delle sfide più interessanti e rilevanti nell'ambito dell'ottimizzazione combinatoria. Originariamente formulato negli anni '30, il TSP richiede di determinare il percorso più breve per visitare un insieme di città esattamente una volta, ritornando infine alla città di partenza. Nonostante la sua apparente semplicità concettuale, il TSP è noto per la sua complessità computazionale e la sua rilevanza pratica in una vasta gamma di settori, inclusi trasporti,  logistica, e progettazione di circuiti.

Il TSP è classificato come un problema NP-hard, il che significa che non esiste un algoritmo efficiente in grado di risolvere tutte le istanze del problema in tempo polinomiale. Di conseguenza, sono state sviluppate numerose euristiche e approcci approssimati per trovare soluzioni accettabili in un tempo ragionevole. Le euristiche sono strategie di ricerca che, pur non garantendo la soluzione ottima, sono in grado di produrre risultati soddisfacenti entro limiti temporali praticabili.

In questa tesi, esploreremo una specifica euristica per il TSP chiamata Furthest Insertion: l'obiettivo principale sarà quello di presentare, analizzare e valutare l'efficacia di questa euristica attraverso run su istanze presenti su TSP-LIB e confronti con altre tecniche note.

La scelta di concentrarsi su un'euristica per il TSP è motivata dalla necessità di affrontare problemi di dimensioni reali in contesti applicativi. Mentre le soluzioni esatte sono desiderabili per la loro precisione, spesso richiedono una potenza di calcolo eccessiva per problemi di grandi dimensioni. Le euristiche offrono un compromesso utile tra precisione e efficienza, consentendo di ottenere soluzioni praticabili che possono guidare decisioni reali.

Questa tesi sarà strutturata nel seguente modo: innanzitutto, forniremo una panoramica del TSP e della sua formulazione matematica. Successivamente, esamineremo le principali categorie di approcci risolutivi, concentrandoci in particolare sulle euristiche basate su inserzione. Presenteremo quindi la nuova euristica Furthest Insertion discutendo la sua implementazione e le scelte progettuali adottate. Infine, concluderemo con un'analisi dei risultati ottenuti, identificando i punti di forza e le limitazioni della nuova euristica.

\afterpreface
% 
% 
%			CAPITOLO 1: Introduzione
\chapter{Il Problema del Commesso Viaggiatore}
Il Problema del Commesso Viaggiatore (TSP) è una delle sfide più emblematiche e studiate nell'ambito della ricerca operativa e dell'ottimizzazione combinatoria. Originariamente formulato negli anni '30 da Karl Menger \cite{Menger}, il TSP richiede di determinare il percorso più breve per visitare un insieme di città esattamente una volta, tornando infine alla città di partenza. Nonostante la sua semplice descrizione concettuale, il TSP è noto per la sua complessità computazionale e la sua rilevanza pratica in una vasta gamma di settori.

Le applicazioni del TSP sono diffuse e impattano direttamente su molte attività quotidiane. Ad esempio, nel settore della logistica e della gestione delle catene di distribuzione, il TSP è utilizzato per ottimizzare le rotte dei veicoli di consegna, minimizzando i costi di carburante e il tempo impiegato. In ambito produttivo, il TSP viene impiegato per pianificare i percorsi di ispezione delle fabbriche o per ottimizzare il flusso di lavoro all'interno di un'azienda. Anche nei sistemi di navigazione satellitare e nelle applicazioni GPS, il TSP è alla base dell'ottimizzazione dei percorsi per ridurre il tempo di viaggio.

Storicamente, il TSP ha attratto l'attenzione di numerosi matematici e informatici in quanto è un problema semplice da formulare ma complesso da "risolvere". Il problema è stato formalizzato e reso noto grazie al lavoro di Hassler Whitney nel 1952\footnote[1]{https://www.math.uwaterloo.ca/tsp/uk/history.html} e successivamente nel 1954 da Merrill Flood. La dimostrazione della sua appartenenza alla classe di complessità NP-hard è stata fondamentale per stimolare lo sviluppo di tecniche approssimate e euristiche. Le sfide legate al TSP sono principalmente dovute alla sua natura combinatoria: per n città, il numero di possibili percorsi da valutare cresce in modo esponenziale con n, rendendo impraticabile un'analisi esaustiva per istanze di grandi dimensioni. Questa complessità ha spinto alla ricerca di approcci efficienti, come le euristiche, che non garantiscono la soluzione ottimale ma forniscono soluzioni accettabili in tempi ragionevoli.

\section{Il Problema del commesso viaggiatore}
Il problema del commesso viaggiatore (TSP) può essere sintetizzato molto semplicemente con la seguente domanda: "Date n città, qual è il percorso più breve che inizia e termina con la stessa città?". Il problema quindi presenta le caratteristiche tipiche di un problema su un grafo, dove il grafo è composto da $n$ vertici (le città) e dove gli archi indicano le distanze euclidee tra le città. La formulazione classica del TSP può essere descritta matematicamente attraverso la programmazione intera lineare. La seguente formulazione fa riferimento alla formulazione MTZ (Miller-Tucker-Zemlin) e alla formulazione DFJ (Dantzig-Fulkerson-Johnson) \cite{TSP formulation}.
\section{Formulazione del problema}
\textbf{Dati}: Consideriamo un insieme di $n$ città, ogni città $i$ (per $i = 1, 2, ..., n$) rappresenta un punto nello spazio euclideo, ogni città quindi ha coordinate $(x_i, y_i)$. Definiamo la matrice $c$, dove $c_{ij}$ indica la distanza euclidea tra le due città $i$ e $j$.
\\[1\baselineskip]
\textbf{Variabili}: La variabile $x_{ij}$ è una variabile binaria, quindi: $$ x_{ij} \in \{0, 1\} \qquad \forall i, j = 1, 2, 3, ..., n $$ La variabile $x$ assume valore 0 se l'arco che collega la città $i$ e $j$ non fa parte del path, 1 se ne fa parte.
\\[1\baselineskip] \textbf{Vincoli}: I vincoli sono i seguenti:
\begin{enumerate}
        \item Per ogni città $i$ deve essere presente un solo arco uscente corrispondente nel tour, quindi la somma delle variabili $x_{ij}$ deve essere uguale a 1. $$\sum_{j = 1}^{n} x_{ij} = 1 \qquad \forall i = 1, 2, 3, ..., n$$
        \item Per ogni città $j$ deve essere presente un solo arco entrante corrispondente nel tour, quindi la somma delle variabili $x_{ij}$ deve essere uguale a 1. $$\sum_{i = 1}^{n} x_{ij} = 1 \qquad \forall j = 1, 2, 3, ..., n$$
        \item Non devono essere presenti cicli all'interno del tour, quindi deve valere: $$ \sum_{i \in Q}{\sum_{j \in Q}{x_{ij} \le |Q| - 1}} \qquad \forall Q \subsetneq \{2, 3, ..., n\} $$
\end{enumerate}
\textbf{Funzione Obiettivo}: Si vuole minimizzare il costo totale del tour, quindi:
$$min \sum_{i = 1}^{n} \sum_{j = 1}^{n} c_{ij} x_{ij}$$
La seguente formulazione permette quindi di identificare la soluzione ottima.
\newline \null \newline È stato dimostrato che TSP è un problema NP-difficile \cite{TSP NP Completezza}, questo implica che attualmente non sono noti algoritmi con complessità polinomiale che risolvono il problema. Se esistesse un algoritmo con complessità polinomiale che risolve il TSP allora si potrebbe dimostrare che vale P = NP e quindi si risolverebbe uno dei più grandi problemi aperti nella teoria della complessità computazionale. 

\section{Metodi esatti per il TSP}
Esistono vari approcci nella ricerca della soluzione ottima \cite{Analysis of Brute Force}. Un primo approccio "naive" per il problema può essere l'approccio brute-force: consiste nell'enumerare tutti i possibili percorsi e successivamente selezionare il migliore. In questo caso è necessario analizzare $n!$ possibili percorsi (nel peggiore dei casi), per questo motivo tentare di risolvere una istanza TSP con un approccio brute-force implica una complessità computazionale pari a $O(n!)$ e quindi un tempo che risulta rapidamente inaccettabile. Di seguito una tabella che illustra il numero di percorsi da valutare con un approccio basato su ricerca esaustiva al variare del numero n.



\begin{center}
        \begin{tabular}{|c|c|}
                \hline
                \textbf{Numero città} & \textbf{Numero percorsi possibili} \\ % Intestazione in grassetto
                \hline % Linea orizzontale sopra della tabella
                4 & 24 \\
                \hline
                5 & 120 \\
                \hline
                6 & 720 \\
                \hline
                7 & 5,040 \\
                \hline
                8 & 40,320 \\
                \hline
                9 & 362,880 \\
                \hline
                10 & 3,628,800 \\
                \hline
                11 & 39,916,800 \\
                \hline
                12 & 479,001,600 \\
                \hline
                13 & 6,227,020,800 \\
                \hline
                14 & 87,178,291,200 \\
                \hline
                15 & 1,307,674,368,000 \\
                \hline
                16 & 20,922,789,888,000 \\
                \hline
                17 & 355,687,428,096,000 \\
                \hline
                18 & 6,402,373,705,728,000 \\
                \hline
                19 & 121,645,100,408,832,000 \\
                \hline
                20 & 2,432,902,008,176,640,000 \\
                \hline
                21 & 51,090,942,171,709,440,000 \\
                \hline
                22 & 1,124,000,727,777,607,680,000 \\
                \hline
                23 & 25,852,016,738,884,976,640,000 \\
                \hline
                24 & 620,448,401,733,239,439,360,000 \\
                \hline
                25 & 15,511,210,043,330,985,984,000,000 \\
                \hline
        \end{tabular}
        \newline
\end{center}
Si può notare come il numero cresce molto rapidamente, anche con istanze relativamente piccole (ad esempio 20 città). Questo approccio risulta quindi inutilizzabile nei problemi reali dove può essere necessario analizzare istanze con migliaia di città.
\newline \null \newline Esistono altri algoritmi esatti i quali consentono di ridurre il numero di possibili soluzioni (percorsi) da analizzare, ad esempio approcci Branch and Bound \cite{Branch and Bound}. La complessità computazionale nel caso peggiore resta esponenziale in quanto può essere necessario analizzare un numero esponenziale di percorsi e quindi non applicabile su problemi reali.
\newline \null \newline 
Oltre all'approccio brute force, esistono in letteratura diversi algoritmi \textbf{branch-and-bound}\footnote[1]{https://www.math.cmu.edu/~bkell/21257-2014f/tsp.pdf}\footnote[2]{https://apps.dtic.mil/sti/tr/pdf/ADA142318.pdf} che consentono di risolvere in problema in modo più efficiente. L'idea alla base consiste nel suddividere il problema originario in sottoproblemi (più semplici) i quali possono essere a loro volta scomposti in ulteriori sottoproblemi. Il termine "bound" indica il fatto che per ogni sottoproblema viene calcolato il limite inferiore $L_i$ (quindi la soluzione ottima non sarà mai migliore di questo limite inferiore) e si tiene conto della soluzione migliore trovata fino a quel punto $U$: quando $L_i$ è "peggiore" di $U$ allora è possibile scartare a priori l'intero sottoproblema in quanto è già stata trovata una soluzione migliore del limite inferiore del sottoproblema (questo processo prende il nome di "pruning"). Il termine "branch" invece fa riferimento al fatto che i sottoproblemi vengono a loro volta divisi in ulteriori sottoproblemi (come visto prima), l'algoritmo branch-and-bound procede esplorando l'albero dei sottoproblemi generati (detto anche albero branch-and-bound) e scartando i sottoproblemi (pruning) con il criterio visto prima. I vari algoritmi differiscono in base al criterio di branching e di esplorazione dell'albero branch-and-bound. \newline \null \newline
Lo stato dell'arte degli algoritmi esatti per il TSP non sono i generici branch-and-bound ma sono algoritmi \textbf{branch-and-cut}\cite{Branch and Cut}: Branch and Cut è un metodo di ottimizzazione combinatoria simile al branch and bound, ma con alcune differenze fondamentali. Entrambi gli algoritmi mirano a trovare la soluzione ottimale per un problema complesso, dividendolo in sottoproblemi più piccoli e scartando (pruning) i sottoproblemi che in ogni caso non possono portare ad una soluzione parziale migliore di quella già nota. Tuttavia, l'algoritmo Branch and Cut si distingue per l'utilizzo di vincoli di taglio (cutting planes). Di seguito viene illustrato un generico algoritmo branch-and-cut:
\newlist{legal}{enumerate}{10}
\setlist[legal]{label*=\arabic*.}

\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Aggiungi il problema iniziale $ILP$ alla lista dei problemi attivi $L$.
  \item Sia $x^* = null$ e $v^* = -\infty$
  \item Finché $L$ non è vuota:
  \begin{legal}
    \item Seleziona e rimuovi un problema da L
    \item Risolvi il rilassamento continuo di L
    \item Se il problema è inammissibile torna al punto 3 (ciclo while). Altrimenti sia $x$ la soluzione trovata e $v$ il valore della funzione obiettivo.
    \item Se $v \leq v^*$ torna al punto 3
    \item Se $x$ è intero, aggiorna $v^* \leftarrow v$, $x^* \leftarrow x$ e torna al punto 3.
    \item Cerca dei piani di taglio che sono violati da $x$, se sono presenti aggiungili al rilassamento continuo di ILP e torna al punto 3.2
    \item Dividi il problema in sottoproblemi, aggiungi i sottoproblemi alla lista dei problemi attivi $L$, torna al punto 3.
  \end{legal}
  \item Restituisci $x^*$


\end{legal}
\end{tcolorbox}
\hfill \break
Come già detto in precedenza, questo approccio è attualmente lo stato dell'arte per risolvere il TSP all'ottimo. In letteratura esistono varie implementazioni di algoritmi branch-and-cut per il TSP\cite{Branch and Cut Algoritmhs}, sono presenti anche all'interno di risolutori MILP come ad esempio CPLEX. Questo approccio risulta migliore rispetto all'approccio brute-force, ma resta comunque non applicabile su istanze TSP con migliaia di città.

\chapter{Euristiche per il TSP}
Come discusso nel capitolo 2, i metodi esatti consentono di ottenere soluzioni ottime per il problema del TSP, ma il tempo per ottenere queste soluzioni aumenta esponenzialmente all'aumentare del numero di città presenti nell'istanza. Per affrontare il TSP, sono stati sviluppati numerosi approcci euristici, ovvero metodi che, pur non garantendo la soluzione ottimale, offrono soluzioni di buona qualità in tempi ragionevoli. Le euristiche sono fondamentali per applicazioni pratiche dove la rapidità di calcolo è essenziale. In questo capitolo esploreremo diverse tecniche euristiche, come le euristiche costruttive, che costruiscono una soluzione passo dopo passo a partire da una soluzione parziale, vedremo in particolare sulle euristiche basate su inserzione (Furthest Insertion fa parte di questa categoria) e poi "improvement euristics" ovvero le euristiche basate su meccanismi che consentono di "migliorare" la soluzione parziale trovata modificando il tour.
\section{Nearest Neighbor} \label{sec:NN}
Nearest Neighbor è probabilmente l'euristica costruttiva più semplice per il TSP: si costruisce il tour selezionando sempre la città più vicina all'ultima appena aggiunta al tour. Appartiene alla categoria delle euristiche costruttive in quanto aggiunge via via nuove città al tour (soluzione parziale) senza modificare il tour costruito fino a quel punto. L'algoritmo è il seguente:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Seleziona un nodo arbitrario j, sia l = j e L = $\{1, 2, ..., n\} \setminus \{j\}$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Sia $j \in L$ tale che $c_{lj} = min\{c_{li} \  | \  i \in L\}$.
    \item Connetti l a j e rimuovi j da L, quindi $ L = L \setminus \{j\} $.
  \end{legal}
  \item Connetti l al primo nodo (era stato selezionato al punto 1) per formare un tour.
\end{legal}
\end{tcolorbox}
\hfill \break
Nearest Neighbor è una euristica con complessità temporale pari a $O(n^2)$ in quanto per ogni nodo nel tour (quindi n volte) è necessario cercare tra i restanti nodi, qual è il più vicino (al massimo n volte).

\section{Euristiche basate su Inserzione}
Le euristiche basate su inserzione appartengono alla categoria delle euristiche costruttive ma a differenza di Nearest Neighbor la soluzione viene costruita in un modo differente: si inizia da un piccolo tour (che include 2 o 1 città) il quale viene via via esteso includendo i nodi (città) non ancora aggiunti al tour. In questo tipo di euristiche la differenza fondamentale che le distingue sarà il criterio con il quale si aggiungono nuove città al tour e dove queste città devono essere inserite nel tour. Una qualunque euristica basata su inserzione quindi presenta la seguente struttura:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Seleziona una città o due città arbitrarie come tour iniziale $T$. Sia $L$ l'insieme delle città che sono fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $j \in L$ secondo un certo criterio.
    \item Inserisci $j$ nel tour in una determinata posizione.
    \item Rimuovi $j$ da L, quindi $L = L \setminus \{j\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break
Questo schema permette di ottenere un ciclo Hamiltoniano e quindi un percorso valido per il problema del TSP. Le varie euristiche andranno a definire un criterio di scelta del nodo j (punto 2.1) e un criterio di scelta della posizione di inserzione (punto 2.2).

\subsection{Nearest Insertion} \label{ssec:NI}
Nearest Insertion seleziona come nodo da inserire nel tour il nodo più vicino ad un qualunque nodo già inserito nel tour e lo inserisce nella posizione che minimizza il costo di inserimento. Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito dalla coppia delle città più vicine. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ che risulti il più vicino ad un nodo qualunque $j \in T$.
    \item Trova l'arco $(i, j)$ nel tour $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.  
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Nearest Insertion ha complessità computazionale pari a $O(n^2)$ in quanto ogni nodo (n iterazioni) deve essere inserito nel modo migliore possibile nel tour (fino a n iterazioni).

\subsection{Cheapest Insertion} \label{ssec:CI}
Cheapest Insertion opera in modo diverso da Nearest Insertion: il criterio di selezione non è più il nodo più vicino al tour, ma diventa il nodo che produce il minor aumento del costo del tour se inserito (quindi minimizza il costo di inserzione). Una volta selezionato, il nodo viene inserito nel modo migliore possibile, quindi minimizzando il costo di inserimento. Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
  \begin{legal}
    \item Sia $T$ il tour iniziale definito dalla coppia delle città più lontane. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
    \item Finché $L \neq \emptyset$:
    \begin{legal}
      \item Seleziona un nodo $r \in L$ e un arco $(i, j)$ in $T$ per cui $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}.
      \item Seleziona l'arco $(i, j)$ in $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.
      \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
    \end{legal}
  \end{legal}
  \end{tcolorbox}
\hfill \break Cheapest Insertion ha complessità computazionale pari a $O(n^2 log_2(n))$ in quanto è possibile implementare uno heap che tiene traccia dei nodi non ancora inseriti nel tour e dei relativi costi se inseriti nel modo migliore possibile.

\subsection{Farthest Insertion} \label{ssec:FaI}
Farthest Insertion opera in analogo a Nearest Insertion in quanto il criterio di selezione del nodo da inserire è basato sulla distanza dal tour, ma differenza di Nearest Insertion però viene scelto il nodo più lontano dal tour al posto del più vicino. Il passo di inserzione avviene invece allo stesso modo rispetto a Nearest Insertion: viene quindi scelta la posizione che minimizza il costo di inserzione. Vediamo l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito dalla coppia delle città più lontane. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ che risulti il più \underline{lontano} rispetto ad un nodo qualunque $j \in T$.
    \item Trova l'arco $(i, j)$ nel tour $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.  
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Farthest Insertion ha complessità computazionale pari a $O(n^2)$ in modo del tutto analogo a Nearest Insertion.

\subsection{Furthest Insertion} \label{ssec:FuI}
L'obbiettivo della tesi consiste nel proporre un nuovo algoritmo chiamato Furthest Insertion: allo stesso modo in cui Farthest Insertion opera in modo analogo a Nearest Insertion, Furthest Insertion opera in modo analogo a Cheapest Insertion. Il passo di selezione consiste nel selezionare il nodo che massimizza il costo di inserzione, in fase di inserimento però il nodo viene inserito in modo da minimizzare il costo di inserimento. Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito dalla coppia delle città più lontane. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ e un arco $(i, j)$ in $T$ per cui $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{massimo}.
    \item Seleziona l'arco $(i, j)$ in $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Furthest Insertion ha complessità computazionale pari a $O(n^2 log_2(n))$ in modo del tutto analogo a Cheapest Insertion.

\subsection{Random Insertion} \label{ssec:RI}
Random Insertion seleziona casualmente il nodo da inserire nel tour, successivamente però sceglie il punto di inserimento in modo da minimizzare il costo di inserimento (esattamente come per Nearest Insertion). Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito da una città casuale. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ casualmente.
    \item Seleziona l'arco $(i, j)$ in $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}.
    \item Inserisci $r$ tra $i$ e $j$.  
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Random Insertion ha complessità computazionale pari a $O(n^2)$ in quanto n volte viene selezionato un nodo casuale, dopodiché è necessario iterare n volte alla ricerca della posizione migliore dove inserire il nodo.

\section{Ricerca Locale}
Le euristiche basate su ricerca locale\cite{Local Search} sono euristiche che implementano un meccanismo che consente di migliorare un tour (anche parziale), il meccanismo può ad esempio scambiare due nodi nel tour (vedremo nel dettaglio una euristica in particolare), rimuovere un nodo e inserirlo in un punto del tour migliore oppure implementare meccanismi più sofisticati.

\subsection{Node Insertion}
Questa euristica permette di migliorare un tour rimuovendo un nodo e inserendolo nel tour nel modo migliore possibile. Di seguito la procedura:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour (anche parziale).
  \item Ripeti finché il tour $T$ resta invariato:
  \begin{legal}
    \item Per ogni nodo $i = 1, 2, ..., n$: è possibile ridurre la lunghezza del tour rimuovendo il nodo i da una posizione $p_1$ e inserendo il nodo $i$ in un'altra posizione $p_2$? Se si, aggiorna $T$ spostando il nodo $i$ da $p_1$ a $p_2$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break
La procedura richiede tempo $O(n^2)$ in quanto per ogni nodo (n volte) è necessario ispezionare il possibile scambio di posizione (n volte).

\subsection{Edge Insertion}
In modo analogo a Node Insertion, questa euristica permette di migliorare un tour rimuovendo un arco (a differenza del nodo di prima) e inserendolo nel tour nel modo migliore possibile. Di seguito la procedura:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour (anche parziale).
  \item Ripeti finché il tour $T$ resta invariato:
  \begin{legal}
    \item Per ogni nodo $i = 1, 2, ..., n$, considera l'arco che collega $i$ con il nodo successivo nel tour, sia $(i, j)$ questo arco: è possibile ridurre la lunghezza del tour rimuovendo l'arco $(i, j)$ da una posizione $p_1$ e inserendo $(i, j)$ in un'altra posizione $p_2$? Se si, aggiorna $T$ spostando l'arco da $p_1$ a $p_2$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break
La procedura richiede tempo $O(n^2)$ in modo del tutto analogo a Node Insertion.

\subsection{Euristica 2-Opt}
L'algoritmo 2-Opt\cite{2OPT} consente di eliminare due archi e di riconnetterli in un modo diverso, andando quindi a modificare il tour. Questa euristica deriva dall'osservazione empirica per cui due archi che si incrociano possono essere sempre riorganizzati in modo da non incrociarsi e questo produce sempre una riduzione della lunghezza totale del tour. La procedura consente di ridurre la lunghezza del tour riorganizzando una coppia di archi anche quando non si incrociano. Si nota che è sempre possibile ricombinarli in un unico modo diverso. Di seguito la procedura 2-Opt:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour (anche parziale).
  \item Ripeti finché il tour $T$ resta invariato:
  \begin{legal}
    \item Per ogni nodo $i = 1, 2, ..., n$, considera tutti gli scambi 2-Opt possibili con l'arco $(i, j)$ dove $j$ è il nodo successivo ad $i$ nel tour. Se è possibile ridurre la lunghezza del tour applicando lo scambio 2-Opt, aggiorna T.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break

\subsection{Euristica 3-Opt}
L'euristica 3-Opt è un'estensione dell'euristica vista precedentemente: al posto di eliminare due archi per ricombinarli in modo diverso, in questa euristica sono 3 gli archi che l'euristica rimuove e ricombina in modo diverso. A differenza di 2-Opt sono 8 i modi diversi in cui possono essere ricombinati questi archi\footnote{http://tsp-basics.blogspot.com/2017/03/3-opt-move.html} (includendo anche la configurazione in cui gli archi restano immutati). Vediamo l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
  \begin{legal}
    \item Sia $T$ il tour.
    \item Per ogni nodo $i \in V$, sia $N(i)$ un insieme di nodi.
    \item Ripeti finché il tour $T$ resta invariato:
    \begin{legal}
      \item Per ogni nodo $i = 1, 2, ..., n$: considera tutti gli scambi 3-Opt possibili che includa $i$ e un nodo nell'insieme $N(i)$. Se è possibile ridurre la lunghezza del tour in questo modo, aggiorna T.
    \end{legal}
  \end{legal}
\end{tcolorbox}
\hfill \break
La scelta di ridurre l'insieme dei nodi $V$ a $N(i)$ è necessario in quanto analizzare tutti i possibili scambi che includano 3 nodi implica un tempo $O(n^3)$. L'insieme $N(i)$ può essere generato a partire a partire dal nodo $i$ ad esempio selezionando i 10 nodi più vicini ad $i$.
      
\subsection{Euristica Lin-Kernighan}
L'algoritmo Lin-Kernighan (LK)\cite{LK} è una delle migliori euristiche per risolvere il TSP. Appartiene alla classe degli algoritmi di ricerca locale, che prendono come input un tour (ciclo hamiltoniano) e tentano di migliorarlo cercando nella sua vicinanza un tour più corto, e una volta trovato ripetono il processo da quel nuovo tour, fino a incontrare un minimo locale.
L'algoritmo LK è stato sviluppato da Serge Lin e Brian Kernighan nel 1971 ed è stato dimostrato essere molto efficace per risolvere istanze di TSP di medie e grandi dimensioni. È spesso utilizzato come componente di algoritmi ibridi per il TSP, combinandolo con altre tecniche di ricerca per ottenere risultati ancora migliori. Di seguito una descrizione ad alto livello dell'algoritmo:
\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
  \begin{legal}
    \item Sia $T$ il tour iniziale, può essere generato casualmente oppure tramite altre euristiche come Nearest Neighbor. Sia $S$ la soluzione migliore fino a questo momento.
    \item Ripeti finché il tour $T$ resta invariato (e quindi è stato trovato un minimo locale):
    \begin{legal}
      \item Applica l'algoritmo k-Opt. Inizialmente $k$ deve essere un valore piccolo (2 o 3), aumenta man mano il valore $k$.
    \end{legal}
    \item Una volta trovato un minimo locale, se è migliore di $S$ allora aggiorna $S$. Torna al punto 1 generando un tour diverso da quello di partenza, oppure l'algoritmo termina e S è la soluzione trovata.
  \end{legal}
\end{tcolorbox}
\hfill \break
L'euristica Lin-Kernighan è considerata una delle migliori euristiche per generare soluzioni ottime o quasi-ottime per il problema del TSP\cite{Helsgaun}.

\lstset{
  language=Python, 
  basicstyle=\ttfamily, 
  keywordstyle=\color{blue}, 
  commentstyle=\color{gray}, 
  stringstyle=\color{red}, 
  showstringspaces=false,
  numbers=left,                 % Aggiunge i numeri di riga a sinistra
  numberstyle=\tiny\color{gray}, % Stile per i numeri di riga
  stepnumber=1,                 % Numerare ogni riga
  numbersep=10pt                % Distanza tra i numeri di riga e il codice
}
\chapter{Implementazione delle euristiche}
Questo capitolo descrive l'implementazione di una classe Python chiamata "TSP" tramite la quale deve essere possibile:
\begin{legal}
  \item Poter generare istanze della classe TSP che rappresenti una particolare istanza del TSP, con la matrice di adiacenza e le altre strutture dati necessarie per il problema
  \item Poter ottenere una soluzione valida per il problema tramite l'invocazione di un metodo che implementa una euristica tra quelle descritte precedentemente
  \item Poter consentire di ottenere i dati relativi alla qualità delle soluzioni e tempi dell'euristica
\end{legal}
Per il progetto è stata scelta la libreria TSP-LIB\footnote{http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/} come fonte di istanze per il TSP in quanto in letteratura è ampiamente utilizzata per testare e confrontare algoritmi e euristiche progettate per risolvere il TSP. Nel progetto, le istanze sono state tutte collocate nella directory "ALL-TSP" dove sono presenti due tipi di file: "NOME.tsp" e "NOME.opt.tour" dove la prima contiene i dati relativi all'istanza chiamata "NOME", mentre la seconda contiene la soluzione ottima per quella istanza. Di seguito la struttura dei file di input:

\lstnewenvironment{myverbatim}[1][]{%
  \lstset{
    basicstyle=\ttfamily,
    frame=tb,
    #1
  }%
}{}

\begin{myverbatim}[title={berlin52.tsp}]
NAME: berlin52
TYPE: TSP
COMMENT: 52 locations in Berlin (Groetschel)
DIMENSION: 52
EDGE_WEIGHT_TYPE: EUC_2D
NODE_COORD_SECTION
1 565.0 575.0
2 25.0 185.0
3 345.0 750.0
4 945.0 685.0
5 845.0 655.0
6 880.0 660.0
7 25.0 230.0
8 525.0 1000.0
9 580.0 1175.0
10 650.0 1130.0
11 1605.0 620.0 
12 1220.0 580.0
13 1465.0 200.0
...
50 595.0 360.0
51 1340.0 725.0
52 1740.0 245.0
EOF
\end{myverbatim}
Dove, come specificato nella documentazione di TSP-LIB\footnote{http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp95.pdf}, gli elementi importanti sono:
\begin{legal}
  \item "NAME": ovvero il nome dell'istanza TSP
  \item "TYPE": ovvero il tipo di problema, nel nostro caso ci limitiamo alle istanze TSP simmetriche (in TSP LIB sono presenti anche istanze ATSP)
  \item "EDGE\_WEIGHT\_TYPE": ovvero il tipo di distanze tra i punti, ai fini del progetto per semplicità mi limito al caso euclideo in due dimensioni
  \item "NODE\_COORD\_SECTION": da questa sezione in poi sono presenti 3 numeri per ogni riga: numero del nodo (città), coordinata x e coordinata y: queste coordinate saranno utili per calcolare le distanze euclidee tra i nodi.
\end{legal}
Per ogni istanza TSP, non solo è presente il relativo file descritto sopra (quindi NOME.tsp), ma anche il file contenente la soluzione ottima "NOME.opt.tour". Di seguito un esempio sempre dall'istanza berlin52:
\begin{myverbatim}[title={berlin52.opt.tsp}]
NAME : berlin52.opt.tour
TYPE : TOUR
DIMENSION : 52
TOUR_SECTION
1
49
32
45
19
41
8
9
10
43
...
30
2
7
42
21
17
3
18
31
22
-1
EOF
\end{myverbatim}
In questa tipologia di file è presente la soluzione in forma di lista dei nodi che formano il tour migliore. È importante notare come i nodi sono numerati da 1 compreso fino a n compreso, nella implementazione della classe (e quindi nelle euristiche) ho deciso di trasporre gli indici nel range [0, n - 1] (compresi) in modo coerente con i la numerazione presente nei metodi standard delle liste presenti nel linguaggio Python (quindi ad esempio la città 3 in questo esempio corrisponderà in questa implementazione alla città 2).

\section{Implementazione del costruttore della classe}
Il costruttore della classe deve consentire di importare i dati relativi ad una istanza specifica del TSP contenuta nella cartella "TSP-ALL", di seguito l'implementazione:
\begin{python}
def __init__(self, name, ignoraOpt=False):
  self.ignoraOpt = ignoraOpt
  self.openTSP(name)
  self.name = name
  self.optimalSolution = soluzioneOttima[name]
\end{python}
Dove: \lstinline!self.openTSP()! è il metodo che effettivamente importa i dati dal file relativo, inoltre sono presenti gli attributi \lstinline!self.name! il quale semplicemente memorizza il nome dell'istanza TSP e l'attributo \lstinline!self.optimalSolution! che memorizza il valore della soluzione ottima dal file "NOME.opt.tour". \hfill \break
Di seguito l'analisi del metodo \lstinline!self.openTSP(name)!:
\begin{python}
def openTSP(self, name):
  # estraggo i dati delle coordinate euclidee
  f = open(f"ALL-TSP/{name}.tsp")
  self.numCity = -1
  i = 0
  data = False
  self.coord = []
  for line in f:
    if "EOF" in line:
      break
    if line == "":
      continue
    if data:
      line = line.replace("  ", " ")\
              .replace("  ", " ")\
              .replace("\n", "").strip()
      if "." in line.split(" ")[1]:
          self.coord.append([int(float(line.split(" ")[1])), \
                             int(float(line.split(" ")[2]))])
      else:
          self.coord.append([int(line.split(" ")[1]), \
                             int(line.split(" ")[2])])
    if "DIMENSION" in line:
      self.numCity = int(line.split(": ")[1])
    if "NODE_COORD_SECTION" in line:
      data = True
  f.close()
\end{python}
Questa prima parte del metodo permette di aprire il file relativo all'istanza TSP e importa nella lista \lstinline!self.coord! tutte le coppie $(x, y)$ che rappresentano le coordinate cartesiane dei punti.
\begin{python}
def openTSP(self, name):
  ...
  self.adj = [[0 for _ in range(self.numCity)] for _ in range(self.numCity)]
  for i in range(self.numCity):
    for j in range(i):
      if i == j:
        continue
      else:
        self.adj[i][j] = self.adj[j][i] = self.distance(self.coord[i], self.coord[j])
\end{python}
In questa seconda parte del metodo viene calcolata la matrice di adiacenza dell'istanza TSP e memorizzata nell'istanza \lstinline!self.adj! (il metodo \lstinline!self.distance! verrà descritto nella prossima sezione).
\begin{python}
def openTSP(self, name):
  ...
  if not self.ignoraOpt:
      # leggo il persorso ottimale
      f = open(f"ALL-TSP/{name}.opt.tour")
      self.optTour = [-1 for _ in range(self.numCity)]
      self.tour = [-1 for _ in range(self.numCity)]
      data = False
      i = 0
      for line in f:
        if "-1" in line:
          break
        if data:
          # considero i nodi del grafo a partire da 0 e non da 1 come su TSP LIB
          self.optTour[i] = int(line) - 1
          i += 1
        if "TOUR_SECTION" in line:
          data = True
      f.close()
  else:
    self.optTour = [-1 for _ in range(self.numCity)]
    self.tour = [-1 for _ in range(self.numCity)]
\end{python}
L'ultima parte del metodo consente di inizializzare le liste  \lstinline!self.optTour! e \lstinline!self.tour! dove la prima contiene la soluzione ottima contenuta nel file "NOME.opt.tour" e la seconda sarà invece utilizzata dalle euristiche costruttive per "costruire" man mano la soluzione.

\section{Implementazione di metodi ausiliari per le euristiche}
In questa sezione analizzo l'implementazione di metodi ausiliari e di supporto. Questi metodi fattorizzano il codice utilizzato frequentemente da diverse euristiche, migliorando la modularità, la leggibilità e la manutenibilità del codice.
\begin{python}
  def distance(self, a, b):
    return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)
\end{python}
Questo metodo (come visto prima) semplicemente consente di calcolare la distanza euclidea tra due punti a e b.
\begin{python}
def openRandomTSP(self, n):
  self.name = "random"
  self.numCity = n
  self.adj = [[0 for _ in range(self.numCity)] for _ in range(self.numCity)]
  for i in range(self.numCity):
    for j in range(i):
      if i == j:
        continue
      else:
        self.adj[i][j] = self.adj[j][i] = random.randint(0, 1000)
\end{python}
Questo metodo consente di generare una istanza casuale del TSP dato come parametro un numero intero n (il numero di città). Dato che il progetto si limita al TSP simmetrico, alla riga 10 si assegna lo stesso valore sia all'arco $(i, j)$ che all'arco $(j, i)$.
\begin{python}
def calculateCost(self):
  self.cost = 0
  for i in range(self.numCity - 1):
    self.cost += self.adj[self.tour[i]][self.tour[i + 1]]
  self.cost += self.adj[self.tour[self.numCity - 1]][self.tour[0]]
\end{python}
Il metodo \lstinline!calculateCost()! consente di assegnare all'attributo \lstinline!self.cost! il costo del tour, che si ottiene sommando i costi degli archi $(i, j)$ per ogni coppia di archi contenuti nel tour. Essendo un ciclo hamiltoniano, alla fine del ciclo for si aggiunge anche il costo per tornare al punto di partenza \lstinline!self.tour[0]!.
\begin{python}
def calculateOptimalCost(self):
  self.cost = 0
  for i in range(self.numCity - 1):
    self.cost += self.adj[self.optTour[i]][self.optTour[i + 1]]
  self.cost += self.adj[self.optTour[self.numCity - 1]][self.optTour[0]]
\end{python}
Il metodo \lstinline!calculateOptimalCost()! consente in modo del tutto analogo al metodo \lstinline!calculateCost()! di calcolare il costo del tour, con la differenza che si considera il tour ottimo (attributo \lstinline!self.optTour!) al posto del tour del metodo precedente.
\begin{python}
def verifyTour(self):
  for i in range(self.numCity):
    if not i in self.tour:
      print(f"ERRORE, manca {i}")
      return False
    if self.tour.count(i) != 1:
      print(f"ERRORE, il numero {i} risulta esserci {self.tour.count(i)} volte")
      return False
  return True
\end{python}
Il metodo \lstinline!verifyTour()! consente di testare la correttezza del tour trovato dall'euristica, è quindi pensato per essere verificato (tramite un \lstinline!assert!). Il metodo si limita a verificare che ogni nodo deve essere presente nel tour esattamente una volta sola, il metodo chiaramente non garantisce la presenza di altri errori nell'implementazione dell'euristica.

\section{Implementazione delle euristiche}
In questo capitolo, descriveremo l'implementazione delle euristiche per la risoluzione del TSP, in particolare verranno implementate le euristiche costruttive presentate nei capitoli 2.1 e 2.2.
\subsection{Nearest Neighbor}
L'euristica \nameref{sec:NN} (NN) costruisce un tour partendo da una città e, iterativamente, aggiungendo la città non visitata più vicina fino a quando tutte le città non sono state visitate. Di seguito viene riportato il codice per questa euristica.
\begin{python}
def nearestNeighbor(self):
  self.tour = [0]
  visited = set([0])
  notVisited = set(range(1, self.numCity))
  while len(self.tour) < self.numCity:
    cost = np.inf
    j = -1
    for j2 in notVisited:
      if self.adj[self.tour[-1]][j2] < cost:
        cost = self.adj[self.tour[-1]][j2]
        j = j2
    self.tour.append(j)
    visited.add(j)
    notVisited.remove(j)
  self.calculateCost()
\end{python}
Per semplicità ho scelto la prima città (nodo 0) come città iniziale, dopodiché finché sono presenti nodi da aggiungere al tour, si cerca un nodo j non ancora visitato che sia il più vicino possibile all'ultimo nodo aggiunto al tour (\lstinline!self.tour[-1]!), inoltre sono presenti gli insiemi (set) visited e nonVisited che tengono traccia dei nodi presenti o non presenti nel tour. Alla fine viene calcolato il costo del tour trovato tramite il metodo \lstinline!self.calculateCost()!.
\subsection{Nearest Insertion}
Nelle prossime sezioni verrà discussa l'implementazione delle euristiche costruttive basate su inserzione, a partire da \nameref{ssec:NI}.
\begin{python}
def nearestInsertion(self):
  n = self.numCity
  distances = np.array(self.adj)
  path = [0, 0]

  minDist = np.inf
  for i in range(n):
    for j in range(0, i):
      if distances[i][j] < minDist:
        path[0], path[1] = i, j
        minDist = distances[i][j]
  in_path = {path[0], path[1]}
\end{python}
Inizialmente l'euristica inizializza il tour con la coppia di città più vicine presenti nell'istanza TSP, viene quindi cercato l'arco $(i, j)$ con costo più basso e inizializzato il path (posizione 0 e 1) con questi due nodi.
\begin{python}
def nearestInsertion(self):
  ...
  h = []
  for i in set(range(n)) - in_path:
    h.append((min(distances[path[0], i], distances[path[1], i]), i))
  heapq.heapify(h)
\end{python}
Successivamente vengono inizializzate le distanze minime e le città più vicine per ogni città non nel percorso. Dato che nearest insertion dovrà determinare il nodo fuori dal ciclo con distanza minore rispetto ad un nodo qualunque nel ciclo, ho deciso di utilizzare uno heap tramite il modulo \lstinline!heapq! con il quale sarà possibile tenere traccia dei nodi fuori dal ciclo e la loro distanza minima con il tour.
\begin{python}
def nearestInsertion(self):
  ...
  while len(path) < n:
    _, to_insert = heapq.heappop(h)

    best_increase = np.inf
    best_position = None
    for i in range(len(path)):
      next_i = (i + 1) % len(path)
      increase = distances[path[i], to_insert] +\
                 distances[to_insert, path[next_i]] - \
                 distances[path[i], path[next_i]]
      if increase < best_increase:
        best_increase = increase
        best_position = i + 1

    path.insert(best_position, to_insert)
    in_path.add(to_insert)

    for i, (cost, node) in enumerate(h):
      if node not in in_path and distances[to_insert, node] < cost:
        h[i] = (distances[to_insert, node], node)
    heapq.heapify(h)

  self.tour = path
  self.calculateCost()
\end{python}
Questo è il ciclo principale dell'euristica: prima di tutto tramite l'operazione \lstinline!heappop! viene estratto il nodo \lstinline!to_insert! come nodo candidato da inserire nel ciclo (in quanto ha distanza minima dal tour), successivamente viene effettuata una ricerca nel tour della posizione di inserimento migliore possibile. La posizione migliore deve minimizzare $c_{ir} + c_{rj} - c_{ij}$, quindi la variabile \lstinline!increase! definita alla riga 10. La scelta di memorizzare nella variabile \lstinline!best_position! il valore \lstinline!i + 1! e non \lstinline!i! è motivata dal fatto che il metodo \lstinline!insert(pos, n)! (con parametro pos e n) delle liste python sposta in avanti tutti gli elementi dalla posizione pos compresa per fare spazio alla variabile da inserire (n), di conseguenza una volta trovata la posizione migliore (tra le posizioni i e i+1), sarà necessario indicare la posizione i+1 per ottenere l'inserimento del nuovo arco tra la posizione i e la posizione i + 1. Successivamente (dalla riga 20) viene aggiornato lo heap in quanto alla riga 17 viene modificato il path mentre lo heap fa ancora riferimento al path prima dell'inserimento. L'aggiornamento procede come segue: si cerca un arco tra i nodi fuori dal tour (\lstinline!node!) e il nodo appena aggiunto al tour (\lstinline!to_insert!): nel caso in cui è presente un costo minore rispetto a quello presente nello heap (relativo al nodo chiamato \lstinline!node!) allora è necessario aggiornare lo heap con la nuova distanza. Successivamente è necessario effettuare l'operazione \lstinline!heapq.heapify(h)! in quanto l'aggiornamento dello heap potrebbe aver modificato la struttura dello heap. Alla fine dell'implementazione di Nearest Insertion è presente (come prima) l'aggiornamento della variabile self.tour (che memorizza il tour finale) e viene eseguito il metodo \lstinline!self.calculateCost()! come per le altre euristiche per ottenere il costo del percorso nella variabile  \lstinline!self.cost! come visto precedentemente nel capitolo dei metodi ausiliari.

\subsection{Cheapest Insertion}
In questa sezione discutiamo l'impelementazione di \nameref{ssec:CI} che, come abbiamo visto nel secondo capitolo, seleziona i nodi in modo da minimizzare il costo di inserimento (al posto di selezionare i nodi più vicini al tour come visto con nearest insertion). Di seguito l'implementazione:
\begin{python}
def cheapestInsertion(self):
  n = self.numCity
  adj = np.array(self.adj)
  distances = np.array(self.adj)
  path = [0, 0]

  minDist = np.inf
  for i in range(n):
    for j in range(0, i):
        if distances[i][j] < minDist:
          path[0], path[1] = i, j
          minDist = distances[i][j]
  in_path = {path[0], path[1]}
\end{python}
La parte iniziale dell'implementazione è identica a Nearest Insertion: viene inizializzato il tour con la coppia di nodi più vicini presenti nell'istanza.
\begin{python}
def cheapestInsertion(self):
  ...
  h = []
  for i in set(range(n)) - in_path:
    cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
    h.append((cost, i, path[0], path[1]))
  heapq.heapify(h)
\end{python}
Successivamente viene inizializzato uno heap in modo analogo a Nearest Insertion con una differenza: la chiave associata ad ogni nodo non è più la distanza minima con il tour ma il costo di inserimento (se inserito nel modo migliore possibile). In questo caso il costo di inserimento è semplice da ottenere in quanto nel tour sono presenti solo 2 nodi: dati gli unici due nodi presenti nel tour $a$ e $b$, il costo di inserimento del nodo $i$ sarà $c_{ai} + c_{ib} - c_{ab}$. Lo heap userà come valore chiave il costo (prima variabile della tupla) permettendo quindi di estrarre il nodo \lstinline!i! con costo minore. Nello heap vengono memorizzate anche i due nodi tra i quali dovrebbe avvenire l'inserimento (\lstinline!path[0]! e \lstinline!path[1]!) in quanto sono informazioni che saranno utili nella seconda parte dell'impelmentazione dell'euristica.
\begin{python}
def cheapestInsertion(self):
  ...
  while len(path) < n:
    (_, to_ins, _, _) = heapq.heappop(h)

    best_increase = np.inf
    best_pos = None
    for i in range(len(path)):
      next_i = (i + 1) % len(path)
      increase = adj[path[i], to_ins] + \
                 adj[to_ins, path[next_i]] - \
                 adj[path[i], path[next_i]]
      if increase < best_increase:
        best_increase = increase
        best_pos = next_i
    path.insert(best_pos, to_ins)
    in_path.add(to_ins)
    ...
\end{python}
Questo è il ciclo for principale dell'euristica: viene selezionato dallo heap il nodo \lstinline!to_ins! ovvero il nodo che minimizza il costo di inserimento se inserito nel modo migliore possibile; successivamente (dalla riga 6 alla 17) viene effettuata una ricerca del punto di inserimento nel path, in modo da minimizzare il costo di inserimento, ovvero $c_{ir} + c_{rj} - c_{ij}$, la posizione dove inserire il nuovo nodo sarà \lstinline!best_pos! ovvero la posizione \lstinline!next_i! dove si minimizza l'inserimento. Importante notare come la variabile \lstinline!next_i! (alla riga 9) rappresenta il nodo successivo ad \lstinline!i! nel tour, con l'accortezza che la posizione successiva a \lstinline!len(path)! è 0, in quanto la lista tour deve rappresentare una lista cicla (la posizione successiva all'ultima è la prima).
\begin{python}
def cheapestInsertion(self):
  ...
  while len(path) < n:
    ...
    for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
      if node not in in_path and nodeLeft == \
         path[(best_pos - 1) % len(path)] and \
         nodeRight == path[(best_pos + 1) % len(path)]:
        best_cost = np.inf
        posL, posR = -1, -1
        for i2 in range(len(path)):
          next_i = (i2 + 1) % len(path)
          insertion_cost = adj[path[i2]][node] + \
                           adj[node][path[next_i]] - \
                           adj[path[i2]][path[next_i]]
          if best_cost > insertion_cost:
            best_cost, posL, posR = insertion_cost, i2, next_i
        h[i] = (best_cost, node, path[posL], path[posR])

      if node not in in_path and \
        adj[path[(best_pos - 1) % len(path)]][node] + \
        adj[node][to_ins] - \
          adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
        new_cost = adj[path[(best_pos - 1) % len(path)]][node] + \
                   adj[node][to_ins] - \
                   adj[path[(best_pos - 1) % len(path)]][to_ins]
        h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)

          best_pos = (best_pos + 1) % (len(path))
      if node not in in_path and \
            adj[to_ins][node] + \
            adj[node][path[(best_pos + 1) % (len(path))]] - \
            adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
        new_cost = adj[to_ins][node] + \
                   adj[node][path[(best_pos + 1) % (len(path))]] - \
                   adj[to_ins][path[(best_pos + 1) % (len(path))]]
        h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
    heapq.heapify(h)

  self.tour = path
  self.calculateCost()
\end{python}
Dalla riga 19 in poi avviene l'aggiornamento dello heap (in modo analogo a quanto visto con \nameref{ssec:NI}): dato che l'inserimento del nuovo nodo nel tour ha generato una modifica del tour (e quindi la cancellazione di un arco e l'inserimento di nuovi due archi) è necessario verificare che i valori presenti nello heap siano ancora rappresentativi del nuovo tour e, in caso contrario, aggiornare lo heap. Per ogni elemento nello heap, dati i valori \lstinline!node! (nodo da inserire), \lstinline!nodeLeft! e \lstinline!nodeRight! (nodi tra i quali andava inserito \lstinline!node!), i casi da considerare sono:
\begin{legal}
  \item Nel caso in cui \lstinline!nodeLeft! e \lstinline!nodeRight! corrispondono esattamente ai due nodi tra i quali è stato inserito il nodo \lstinline!to_ins! (nella prima parte del ciclo principale dell'algoritmo), allora è necessario ricalcolare per il nodo \lstinline!node! il costo e il punto di inserimento migliore, in quanto il vecchio arco è stato cancellato. (Riga 6-18).
  \item In ogni altro caso il vecchio arco (tra \lstinline!nodeLeft! e \lstinline!nodeRight!) è rimasto intatto, come gli altri archi. A questo punto è necessario semplicemente verificare che i due nuovi archi generati dopo l'inserimento (quindi gli archi \lstinline!path[best_pos - 1]! - \lstinline!node! e \lstinline!node! - \lstinline!path[best_pos + 1]!) possano essere un caso di inserimento con costo minore rispetto a quello presente nello heap (riga 20-37).
\end{legal}
Inoltre è importante notare come l'accesso agli elementi del tour avviene \lstinline!% len(tour)! in quanto il tour è un "ciclo".
Successivamente (come per le altre euristiche), è necessario ripristinare la struttura dello heap con il metodo \lstinline!heapq.heapify(h)! e alla fine memorizzare il path finale nell'attributo \lstinline!self.tour! e calcolare il costo della soluzione trovata.

\subsection{Farthest Insertion}
In questa sezione discutiamo l'implementazione di \nameref{ssec:FaI}. L'implementazione di questa euristica condivide molto del codice già discusso nella implementazione di Nearest Insertion, sono però presenti delle piccole modifiche che consentono di selezionare il nodo più lontano al posto del nodo più vicino (al tour), di seguito l'implementazione:
\begin{python}
  def farthestInsertion(self):
    n = self.numCity
    distances = np.array(self.adj)
    path = [0, 0]
  
    maxDist = 0
      for i in range(n):
        for j in range(0, i):
          if distances[i][j] > maxDist:
            path[0], path[1] = i, j
            maxDist = distances[i][j]
      in_path = {path[0], path[1]}
  \end{python}
  L'euristica inizializza il tour con la coppia di città più lontane (a differenza della coppia di città più vicine nel caso di Nearest Insertion) presenti nell'istanza TSP, viene quindi cercato l'arco $(i, j)$ con costo più alto e inizializzato il path (posizione 0 e 1) con questi due nodi.
  \begin{python}
  def farthestInsertion(self):
    ...
    h = []
    for i in set(range(n)) - in_path:
      h.append((-min(distances[path[0], i], distances[path[1], i]), i))
    heapq.heapify(h)
  \end{python}
In modo del tutto analogo a nearest insertion, viene inizializzato uno heap il quale conterrà il costo di inserimento se il nodo viene inserito nel modo migliore possibile. Dato che il metodo heappop all'interno del modulo \lstinline!heapq! restituisce l'elemento più piccolo (quindi il nostro heap h opera come un min-heap) e dato che per l'euristica farthest insertion è necessario prelevare il nodo con il costo maggiore (e non minore), ogni distanza inserita nello heap (primo elemento di ogni tupla) verrà inserita con valore negativo: con questa semplice modifica il minHeap min-heap si comporterà come un max-heap e restituirà (tramite il metodo \lstinline!heapq.heappop(h)!) il nodo con distanza maggiore dal tour. Per questo motivo il codice è identico a nearest insertion, con la differenza che alla riga 5 è presente un segno meno all'interno della tupla $(distance, node)$.
  \begin{python}
  def farthestInsertion(self):
    ...
    while len(path) < n:
      _, to_insert = heapq.heappop(h)
  
      best_increase = np.inf
      best_position = None
      for i in range(len(path)):
        next_i = (i + 1) % len(path)
        increase = distances[path[i], to_insert] +\
                   distances[to_insert, path[next_i]] - \
                   distances[path[i], path[next_i]]
        if increase < best_increase:
          best_increase = increase
          best_position = i + 1
  
      path.insert(best_position, to_insert)
      in_path.add(to_insert)
  
      for i, (cost, node) in enumerate(h):
        cost *= -1
        if node not in in_path and \
           distances[to_insert, node] < cost:
          h[i] = (-distances[to_insert, node], node)
      heapq.heapify(h)
  
    self.tour = path
    self.calculateCost()
  \end{python}
Questo è il ciclo principale dell'euristica: il codice è totalmente identico a quanto visto con nearest insertion, con le seguenti piccole (ma importanti) differenze:
\begin{legal}
  \item Alla riga 21 il costo viene moltiplicato per -1 in modo da riottenere una distanza positiva: in questo modo la ricerca di una nuova distanza minima può avvenire tramite la condizione \lstinline!distances[to_insert, node] < cost!
  \item Alla riga 24 la nuova distanza trovata (migliore, ovvero minore di cost) deve essere riconvertita come una distanza negativa in modo da mantenere lo heap funzionante come max-heap.
\end{legal}
In conclusione è presente l'istruzione \lstinline!heapq.heapify(h)! che consente di ripristinare la struttura dello heap e le ultime istruzioni come per le altre euristiche (memorizzazione del tour trovato e calcolo del costo).

\subsection{Furthest Insertion}
In questa sezione discutiamo l'implementazione di \nameref{ssec:FuI} ovvero la nuova euristica proposta in questa tesi. Nella precedente sezione abbiamo visto come farthest insertion condivide molto del codice di nearest insertion con delle piccole modifiche che consentono di selezionare il nodo più lontano al posto del nodo più vicino. Allo stesso modo furthest insertion condivide molto del codice di cheapest insertion, verranno di seguito presentate le piccole modifiche che consentono di selezionare il nodo con costo di inserimento massimo (se comunque inserito nel modo migliore possibile), di seguito l'implementazione:
\begin{python}
def furthestInsertion(self):
  n = self.numCity
  adj = np.array(self.adj)
  distances = np.array(self.adj)
  path = [0, 0]

  maxDist = 0
  for i in range(n):
    for j in range(0, i):
      if distances[i][j] > maxDist:
        path[0], path[1] = i, j
        maxDist = distances[i][j]
  in_path = {path[0], path[1]}
\end{python}
Inizialmente l'euristica determina la coppia di nodi più lontani (in modo analogo a farthest insertion).
\begin{python}
def furthestInsertion(self):
  ...
  h = []
  for i in set(range(n)) - in_path:
    cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
    h.append((-cost, i, path[0], path[1]))
  heapq.heapify(h)
\end{python}
In modo del tutto analogo a farthest insertion viene inizializzato lo heap con costi negativi in modo da poter successivamente selezionare le città con costo di inserimento più alto, per questo motivo il costo nella tupla aggiunta allo heap presenta un segno negativo (riga 6).
\begin{python}
def furthestInsertion(self):
  ...
  while len(path) < n:
    (_, to_ins, _, _) = heapq.heappop(h)

    best_increase = np.inf
    best_pos = None
    for i in range(len(path)):
      next_i = (i + 1) % len(path)
      increase = adj[path[i], to_ins] + \
                 adj[to_ins, path[next_i]] - \
                 adj[path[i], path[next_i]]
      if increase < best_increase:
        best_increase = increase
        best_pos = next_i

    path.insert(best_pos, to_ins)
    in_path.add(to_ins)
    ...
\end{python}
Questo è il ciclo for principale dell'euristica: viene selezionato dallo heap il nodo \lstinline!to_ins! ovvero il nodo che massimizza il costo di inserimento se inserito nel modo migliore possibile; successivamente (dalla riga 6 alla 17) viene effettuata una ricerca del punto di inserimento nel path, in modo da minimizzare il costo di inserimento (in modo identico a cheapest insertion).
\begin{python}
def furthestInsertion(self):
  ...
  while len(path) < n:
    ...
    for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
      cost *= -1
      if node not in in_path and \
         nodeLeft == path[(best_pos - 1) % len(path)] and \
         nodeRight == path[(best_pos + 1) % len(path)]:
          best_cost = np.inf
          posL, posR = -1, -1
          for i2 in range(len(path)):
              next_i = (i2 + 1) % len(path)
              insertion_cost = adj[path[i2]][node] + \
                               adj[node][path[next_i]] - \
                               adj[path[i2]][path[next_i]]
              if best_cost > insertion_cost:
                  best_cost, posL, posR = insertion_cost, i2, next_i
          h[i] = (-best_cost, node, path[posL], path[posR])
      if node not in in_path and \
            adj[path[(best_pos - 1) % len(path)]][node] + \
            adj[node][to_ins] - \
            adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
          new_cost = -(adj[path[(best_pos - 1) % len(path)]][node]+\
                       adj[node][to_ins] - \
                      adj[path[(best_pos - 1) % len(path)]][to_ins])
          h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
          best_pos = (best_pos + 1) % (len(path))
      if node not in in_path and \
             adj[to_ins][node] + \
             adj[node][path[(best_pos + 1) % (len(path))]] - \
             adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
          new_cost = -(adj[to_ins][node] + \
                adj[node][path[(best_pos + 1) % (len(path))]] - \
                adj[to_ins][path[(best_pos + 1) % (len(path))]])
          h[i] = (new_cost, node, to_ins, \
                  path[(best_pos + 1) % (len(path))])
  heapq.heapify(h)

self.tour = path
self.calculateCost()
\end{python}
Dalla riga 5 in poi avviene l'aggiornamento dello heap in modo del tutto analogo a cheapest insertion. Le modifiche per tenere aggiornato lo heap con costi negativi sono le seguenti:
\begin{legal}
  \item Riga 6: è presente l'istruzione \lstinline!cost *= -1! in modo da riportare il costo negativo presente nello heap in un costo positivo, questo sarà utile successivamente (righe 23 e 30) dove il nuovo costo deve essere confrontato con il vecchio costo.
  \item Righe 19, 24 e 31: i nuovi costi devono essere inserito con costo negativo nello heap, per questo motivo le variabili \lstinline!new_cost! vengono moltiplicate per -1.
\end{legal}
La restante parte dell'implementazione è del tutto identica a cheapest insertion.

\subsection{Random Insertion}
In questo capitolo verrà discussa l'implementazione di \nameref{ssec:RI}. Vedremo come di fatto è molto più semplice rispetto alle implementazioni viste prima in quanto bisogna:
\begin{legal}
  \item Selezionare casualmente un nodo fuori dal tour
  \item Inserirlo nel modo migliore possibile
\end{legal}
Di seguito il metodo:
\begin{python}
def randomInsertion(self):
  n = self.numCity
  distances = np.array(self.adj)
  path = [0]
  in_path = {0}
  notInPath = [x for x in range(1, n)]
  random.shuffle(notInPath)
\end{python}
L'euristica inizialmente sceglie come primo nodo arbitrario il nodo 0. Successivamente 
per quanto riguarda il primo punto discusso prima (scegliere casualmente il nodo da inserire), sono presenti due strade possibili:
\begin{legal}
  \item Inizializzare una lista \lstinline![1, 2, ..., n]! tramite il metodo \lstinline!range(1 ,n)! e poi nel ciclo principale dell'euristica selezionare casualmente un nodo dalla lista per poi rimuoverlo tramite il metodo \lstinline!notInPath.remove(i)! (dove i è l'elemento da rimuovere) o tramite istruzione \lstinline!del notInPath[pos]! dove pos è la posizione dell'elemento da rimuovere.
  \item Inizializzare una lista \lstinline![1, 2, ..., n]! tramite il metodo \lstinline!range(1 ,n)!, mescolare la lista tramite metodo \lstinline!random.shuffle(notInPath)! e poi procedere con la selezione del nodo casuale tramite \lstinline!notInPath.pop()!.
\end{legal}
Da un punto di vista della complessità temporale, ho scelto la seconda strada in quanto rimuovere un elemento dalla lista (tramite \lstinline!del! oppure \lstinline!remove!) richiede un tempo $O(n)$ (dove n è la lunghezza della lista), mentre il metodo \lstinline!l.pop()! ha complessità temporale $O(1)$\footnote{https://wiki.python.org/moin/TimeComplexity}. Per questo motivo (contando il ciclo principale dell'euristica) il primo metodo richiederebbe in un tempo $O(n^2)$ (n iterazioni per il ciclo principale, O(n) per l'istruzione \lstinline!remove! o \lstinline!del!), mentre il secondo metodo richiederebbe un tempo $O(n)$ (n iterazioni per il ciclo principale e poi solo $O(1)$ per il metodo \lstinline!notInPath.pop()!). Inoltre l'implementazione del metodo \lstinline!random.shuffle()!\footnote{https://hg.python.org/cpython/file/2e8b28dbc395/Lib/random.py alla riga 276} utilizza il l'algoritmo Fisher-Yates shuffle\cite{knuthart}, ovvero un algoritmo che opera in tempo $O(n)$.
\begin{python}
def randomInsertion(self):
  ...
  while len(path) < n:
    to_insert = notInPath.pop()
    best_increase = np.inf
    best_position = None
    for i in range(len(path)):
      next_i = (i + 1) % len(path)
      increase = distances[path[i], to_insert] + \
                 distances[to_insert, path[next_i]] - \
                 distances[path[i], path[next_i]]
      if increase < best_increase:
        best_increase = increase
        best_position = next_i

    path.insert(best_position, to_insert)
    in_path.add(to_insert)

  self.tour = path
  self.calculateCost()
\end{python}
Come discusso precedentemente, il ciclo principale dell'algoritmo procede estraendo il nodo casuale (riga 4), successivamente viene effettuata una ricerca della posizione migliore dove inserire il nodo casuale. Voglio sottolineare come questo metodo non sia "completamente casuale", ma solo la parte della selezione del nodo fuori dal tuor è casuale, mentre la parte relativa all'inserimento all'interno del tour opera scegliendo il punto di inserzione che minimizzi il costo di inserimento. \newline
In conclusione sono presenti le stesse istruzioni viste nelle altre euristiche (calcolo del costo).

\subsection{Random Insertion versione 2}
Per completezza, ho implementato anche una versione di random insertion dove non solo la scelta del nodo da inserire nel tour avviene casualmente, ma anche il punto di inserzione viene scelto casualmente, di seguito l'implementazione:
\begin{python}
def randomInsertion2(self):
    tour = []
    notInTour = [x for x in range(self.numCity)]
    random.shuffle(notInTour)
    for i in notInTour:
      tour.insert(random.randint(0, len(tour) - 1), i)
    self.tour = tour
    self.calculateCost()
\end{python}
In questa versione dell'algoritmo, la prima parte è identica alla prima versione di random insertion (scelta casuale del nodo tramite una lista \lstinline!notInTour! mescolata casualmente), mentre la seconda (ciclo principale) effettua un inserimento nel tour tramite istruzione \lstinline|tour.insert(pos)| dove la posizione (pos) viene scelta casualmente tramite il metodo \lstinline|random.randint()|.

\subsection{Euristiche con inizializzazione casuale}
Le euristiche viste nelle sezioni precedenti prevedono come inizializzazione del tour la coppia delle città più vicine per cheapest insertion e nearest insertion mentre prevedono la coppia delle città più lontane per farthest insertion e furthest insertion. Nel successivo capitolo verrà analizzata anche la robustezza delle euristiche implementate rispetto all'inizializzazione, per questo motivo nella classe TSP sono presenti 4 varianti delle euristiche descritte nelle sezioni precedenti dove le due città iniziali vengono scelte casualmente. Le 4 euristiche prendono il nome di NOMEInsertionRandomStart dove al posto di "NOME" è presente il nome dell'euristica (nearest, cheapest ...). Di seguito la descrizione della parte diversa:
\begin{python}
    def nearestInsertionRandomStart(self):
      n = self.numCity
      distances = np.array(self.adj)
      path = [random.randint(0, n - 1), random.randint(0, n - 1)]
      while path[0] == path[1]:
        path = [random.randint(0, n - 1), random.randint(0, n - 1)]
      in_path = {path[0], path[1]}
      ...
\end{python}
In questo caso è stato selezionato nearestInsertionRandomStart a titolo di esempio (nelle altre 4 implementazioni il codice è lo stesso): vengono scelte due città casuali come prime due città nel tour. Successivamente (righe 5-6) è necessario ripetere il processo nel caso in cui le due città scelte corrispondano alla stessa città. Una volta selezionati i primi due nodi casualmente, l'euristica può continuare normalmente come visto prima.

 
%
%			BIBLIOGRAFIA
%

\begin{thebibliography}{00}
\bibitem{Menger}
Traveling Salesman Problem, F. Greco, IntechOpen, 2008.
\bibitem{TSP formulation}
M. Velednitsky, Short Combinatorial Proof that the DFJ Polytope is contained in
the MTZ Polytope for the Asymmetric Traveling Salesman Problem, UC Berkeley, 2018.
%
\bibitem{Analysis of Brute Force}
Analysis of Brute Force and Branch \& Bound Algorithms to solve the Traveling
Salesperson Problem (TSP), Informatics Department, Engineering Faculty, Widyatama University, 2021.
%
\bibitem{Branch and Bound}
T. G. Crainic, B. Le Cun, C. Roucairol, Parallel Branch-and-Bound Algorithms, Département de management et technologie École des Sciences de la Gestion Université du Québec à Montréal and CIRRELT, Canada
\bibitem{Branch and Cut Algoritmhs}
Yuan Yuan, Diego Cattaruzza, Maxime Ogier, Frederic Semet. A branch-and-cut algorithm for the generalized traveling salesman problem with time windows. European Journal of Operational Research, 2020, 286 (3)
%
\bibitem{TSP NP Completezza}
R. Karp, Complexity of the Traveling Salesman Problem
%
\bibitem{Reinelt}
G. Reinelt, The Traveling Salesman: Computational Solution for TSP Applications, Heidelberg, Springer-Verlag
\bibitem{Branch and Cut}
J.E. Mitchell, Branch-and-cut algorithms for combinatorial
optimization problems, in Handbook of applied optimization, P.M.
Pardalos and M.G.C. Resende eds., Oxford University Press, 2000
\bibitem{Local Search}
Olaf Mersmann, Bernd Bischl, Jakob Bossek, Heike Trautmann, Markus Wagner, Frank Neumann, Local Search and the Traveling Salesman Problem: A Feature-Based Characterization of Problem Hardness, Statistics Faculty, TU Dortmund University, Germany
\bibitem{2OPT}
Matthias Englert, Heiko Röglin, Berthold Vöcking, Worst Case and Probabilistic Analysis 
of the 2-Opt Algorithm for the TSP, Dept. of Computer Science, RWTH Aachen University
\bibitem{LK}
S. Lin, B. W. Kernighan, An Effective Heuristic Algorithm for the Traveling-
Salesman Problem, Bell Telephone Laboratories, Incorporated, Murray Hill, N.J., 1971
\bibitem{Helsgaun}
K. Helsgaun, An effective implementation of the Lin-Kernighan traveling
salesman heuristic, Department of Computer Science, Roskilde Universit, 13 April 1999
\bibitem{knuthart}
Donald E. Knuth, The Art of Computer Programming: Volume 2 (Seminumerical Algorithms),Addison-Wesley Professional, 1997, Capitolo 3


%\bibitem{gotti91}
%M. Gotti, I linguaggi specialistici, Firenze, La Nuova Italia, 1991.
\end{thebibliography}
% 
\end{document}


 
