% Tesi D.S.I. - modello preso da
% Stanford University PhD thesis style -- modifications to the report style
\documentclass[a4paper,12pt]{report}
\usepackage[a4paper]{geometry}
\usepackage{amssymb,amsmath,amsthm}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{epsfig}
\usepackage[italian]{babel}
\usepackage{setspace}
\usepackage{tesi}
\usepackage[utf8]{inputenc}
\usepackage{algorithmicx}
\usepackage{pythonhighlight}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{tcolorbox}
\usepackage{listings}

\newenvironment{teor}{\begin{myteor}\sl}{\end{myteor}}
%
%
%			TITOLO: Furthest Insertion Algorithm 
%
\begin{document}
\title{Furthest Insertion Algorithm}
\author{Asaf COHEN}
\dept{Corso di Laurea in Informatica} 
\anno{2023-2024}
\matricola{975599}
\relatore{Prof. Giovanni RIGHINI}
%
%        \submitdate{month year in which submitted to GPO}
%		- date LaTeX'd if omitted
%	\copyrightyear{year degree conferred (next year if submitted in Dec.)}
%		- year LaTeX'd (or next year, in December) if omitted
%	\copyrighttrue or \copyrightfalse
%		- produce or don't produce a copyright page (false by default)
%	\figurespagetrue or \figurespagefalse
%		- produce or don't produce a List of Figures page
%		  (false by default)
%	\tablespagetrue or \tablespagefalse
%		- produce or don't produce a List of Tables page
%		  (false by default)
% 
%			DEDICA
%

\beforepreface

\clearpage
\null
\thispagestyle{empty}
\clearpage

\prefacesection{Ringraziamenti}
        {\hfill \Large {\sl dedicato a DA COMPLETARE\dots}}
% 
%			PREFAZIONE
%

\clearpage
\null
\thispagestyle{empty}
\clearpage

\prefacesection{Abstract}
Il Problema del Commesso Viaggiatore (TSP) rappresenta una delle sfide più interessanti e rilevanti nell'ambito dell'ottimizzazione combinatoria. Originariamente formulato negli anni '30, il TSP richiede di determinare il percorso più breve per visitare un insieme di città esattamente una volta, ritornando infine alla città di partenza. Nonostante la sua apparente semplicità concettuale, il TSP è noto per la sua complessità computazionale e la sua rilevanza pratica in una vasta gamma di settori, inclusi trasporti,  logistica, e progettazione di circuiti.

Il TSP è classificato come un problema NP-hard, il che significa che non esiste un algoritmo efficiente in grado di risolvere tutte le istanze del problema in tempo polinomiale. Di conseguenza, sono state sviluppate numerose euristiche e approcci approssimati per trovare soluzioni accettabili in un tempo ragionevole. Le euristiche sono strategie di ricerca che, pur non garantendo la soluzione ottima, sono in grado di produrre risultati soddisfacenti entro limiti temporali praticabili.

In questa tesi, esploreremo una specifica euristica per il TSP chiamata Furthest Insertion: l'obiettivo principale sarà quello di presentare, analizzare e valutare l'efficacia di questa euristica attraverso run su istanze presenti su TSP-LIB e confronti con altre tecniche note.

La scelta di concentrarsi su un'euristica per il TSP è motivata dalla necessità di affrontare problemi di dimensioni reali in contesti applicativi. Mentre le soluzioni esatte sono desiderabili per la loro precisione, spesso richiedono una potenza di calcolo eccessiva per problemi di grandi dimensioni. Le euristiche offrono un compromesso utile tra precisione e efficienza, consentendo di ottenere soluzioni praticabili che possono guidare decisioni reali.

Questa tesi sarà strutturata nel seguente modo: innanzitutto, forniremo una panoramica del TSP e della sua formulazione matematica. Successivamente, esamineremo le principali categorie di approcci risolutivi, concentrandoci in particolare sulle euristiche basate su inserzione. Presenteremo quindi la nuova euristica Furthest Insertion discutendo la sua implementazione e le scelte progettuali adottate. Infine, concluderemo con un'analisi dei risultati ottenuti, identificando i punti di forza e le limitazioni della nuova euristica.

\afterpreface
% 
% 
%			CAPITOLO 1: Introduzione
\chapter{Il Problema del Commesso Viaggiatore}
Il Problema del Commesso Viaggiatore (TSP) è una delle sfide più emblematiche e studiate nell'ambito della ricerca operativa e dell'ottimizzazione combinatoria. Originariamente formulato negli anni '30 da Karl Menger \cite{Menger}, il TSP richiede di determinare il percorso più breve per visitare un insieme di città esattamente una volta, tornando infine alla città di partenza. Nonostante la sua semplice descrizione concettuale, il TSP è noto per la sua complessità computazionale e la sua rilevanza pratica in una vasta gamma di settori.

Le applicazioni del TSP sono diffuse e impattano direttamente su molte attività quotidiane. Ad esempio, nel settore della logistica e della gestione delle catene di distribuzione, il TSP è utilizzato per ottimizzare le rotte dei veicoli di consegna, minimizzando i costi di carburante e il tempo impiegato. In ambito produttivo, il TSP viene impiegato per pianificare i percorsi di ispezione delle fabbriche o per ottimizzare il flusso di lavoro all'interno di un'azienda. Anche nei sistemi di navigazione satellitare e nelle applicazioni GPS, il TSP è alla base dell'ottimizzazione dei percorsi per ridurre il tempo di viaggio.

Storicamente, il TSP ha attratto l'attenzione di numerosi matematici e informatici in quanto è un problema semplice da formulare ma complesso da "risolvere". Il problema è stato formalizzato e reso noto grazie al lavoro di Hassler Whitney nel 1952\footnote[1]{https://www.math.uwaterloo.ca/tsp/uk/history.html} e successivamente nel 1954 da Merrill Flood. La dimostrazione della sua appartenenza alla classe di complessità NP-hard è stata fondamentale per stimolare lo sviluppo di tecniche approssimate e euristiche. Le sfide legate al TSP sono principalmente dovute alla sua natura combinatoria: per n città, il numero di possibili percorsi da valutare cresce in modo esponenziale con n, rendendo impraticabile un'analisi esaustiva per istanze di grandi dimensioni. Questa complessità ha spinto alla ricerca di approcci efficienti, come le euristiche, che non garantiscono la soluzione ottimale ma forniscono soluzioni accettabili in tempi ragionevoli.

\section{Il Problema del commesso viaggiatore}
Il problema del commesso viaggiatore (TSP) può essere sintetizzato molto semplicemente con la seguente domanda: "Date n città, qual è il percorso più breve che inizia e termina con la stessa città?". Il problema quindi presenta le caratteristiche tipiche di un problema su un grafo, dove il grafo è composto da $n$ vertici (le città) e dove gli archi indicano le distanze euclidee tra le città. La formulazione classica del TSP può essere descritta matematicamente attraverso la programmazione intera lineare. La seguente formulazione fa riferimento alla formulazione MTZ (Miller-Tucker-Zemlin) e alla formulazione DFJ (Dantzig-Fulkerson-Johnson) \cite{TSP formulation}.
\section{Formulazione del problema}
\textbf{Dati}: Consideriamo un insieme di $n$ città, ogni città $i$ (per $i = 1, 2, ..., n$) rappresenta un punto nello spazio euclideo, ogni città quindi ha coordinate $(x_i, y_i)$. Definiamo la matrice $c$, dove $c_{ij}$ indica la distanza euclidea tra le due città $i$ e $j$.
\\[1\baselineskip]
\textbf{Variabili}: La variabile $x_{ij}$ è una variabile binaria, quindi: $$ x_{ij} \in \{0, 1\} \qquad \forall i, j = 1, 2, 3, ..., n $$ La variabile $x$ assume valore 0 se l'arco che collega la città $i$ e $j$ non fa parte del path, 1 se ne fa parte.
\\[1\baselineskip] \textbf{Vincoli}: I vincoli sono i seguenti:
\begin{enumerate}
        \item Per ogni città $i$ deve essere presente un solo arco uscente corrispondente nel tour, quindi la somma delle variabili $x_{ij}$ deve essere uguale a 1. $$\sum_{j = 1}^{n} x_{ij} = 1 \qquad \forall i = 1, 2, 3, ..., n$$
        \item Per ogni città $j$ deve essere presente un solo arco entrante corrispondente nel tour, quindi la somma delle variabili $x_{ij}$ deve essere uguale a 1. $$\sum_{i = 1}^{n} x_{ij} = 1 \qquad \forall j = 1, 2, 3, ..., n$$
        \item Non devono essere presenti cicli all'interno del tour, quindi deve valere: $$ \sum_{i \in Q}{\sum_{j \in Q}{x_{ij} \le |Q| - 1}} \qquad \forall Q \subsetneq \{2, 3, ..., n\} $$
\end{enumerate}
\textbf{Funzione Obiettivo}: Si vuole minimizzare il costo totale del tour, quindi:
$$min \sum_{i = 1}^{n} \sum_{j = 1}^{n} c_{ij} x_{ij}$$
La seguente formulazione permette quindi di identificare la soluzione ottima.
\newline \null \newline È stato dimostrato che TSP è un problema NP-difficile \cite{TSP NP Completezza}, questo implica che attualmente non sono noti algoritmi con complessità polinomiale che risolvono il problema. Se esistesse un algoritmo con complessità polinomiale che risolve il TSP allora si potrebbe dimostrare che vale P = NP e quindi si risolverebbe uno dei più grandi problemi aperti nella teoria della complessità computazionale.

\section{Metodi esatti per il TSP}
Esistono vari approcci nella ricerca della soluzione ottima \cite{Analysis of Brute Force}. Un primo approccio "naive" per il problema può essere l'approccio brute-force: consiste nell'enumerare tutti i possibili percorsi e successivamente selezionare il migliore. In questo caso è necessario analizzare $n!$ possibili percorsi (nel peggiore dei casi), per questo motivo tentare di risolvere una istanza TSP con un approccio brute-force implica una complessità computazionale pari a $O(n!)$ e quindi un tempo che risulta rapidamente inaccettabile. Di seguito una tabella che illustra il numero di percorsi da valutare con un approccio basato su ricerca esaustiva al variare del numero n.



\begin{center}
        \begin{tabular}{|c|c|}
                \hline
                \textbf{Numero città} & \textbf{Numero percorsi possibili} \\ % Intestazione in grassetto
                \hline % Linea orizzontale sopra della tabella
                4 & 24 \\
                \hline
                5 & 120 \\
                \hline
                6 & 720 \\
                \hline
                7 & 5,040 \\
                \hline
                8 & 40,320 \\
                \hline
                9 & 362,880 \\
                \hline
                10 & 3,628,800 \\
                \hline
                11 & 39,916,800 \\
                \hline
                12 & 479,001,600 \\
                \hline
                13 & 6,227,020,800 \\
                \hline
                14 & 87,178,291,200 \\
                \hline
                15 & 1,307,674,368,000 \\
                \hline
                16 & 20,922,789,888,000 \\
                \hline
                17 & 355,687,428,096,000 \\
                \hline
                18 & 6,402,373,705,728,000 \\
                \hline
                19 & 121,645,100,408,832,000 \\
                \hline
                20 & 2,432,902,008,176,640,000 \\
                \hline
                21 & 51,090,942,171,709,440,000 \\
                \hline
                22 & 1,124,000,727,777,607,680,000 \\
                \hline
                23 & 25,852,016,738,884,976,640,000 \\
                \hline
                24 & 620,448,401,733,239,439,360,000 \\
                \hline
                25 & 15,511,210,043,330,985,984,000,000 \\
                \hline
        \end{tabular}
        \newline
\end{center}
Si può notare come il numero cresce molto rapidamente, anche con istanze relativamente piccole (ad esempio 20 città). Questo approccio risulta quindi inutilizzabile nei problemi reali dove può essere necessario analizzare istanze con migliaia di città.
\newline \null \newline Esistono altri algoritmi esatti i quali consentono di ridurre il numero di possibili soluzioni (percorsi) da analizzare, ad esempio approcci Branch and Bound \cite{Branch and Bound}. La complessità computazionale nel caso peggiore resta esponenziale in quanto può essere necessario analizzare un numero esponenziale di percorsi e quindi non applicabile su problemi reali.
\newline \null \newline 
Oltre all'approccio brute force, esistono in letteratura diversi algoritmi \textbf{branch-and-bound}\footnote[1]{https://www.math.cmu.edu/~bkell/21257-2014f/tsp.pdf}\footnote[2]{https://apps.dtic.mil/sti/tr/pdf/ADA142318.pdf} che consentono di risolvere in problema in modo più efficiente. L'idea alla base consiste nel suddividere il problema originario in sottoproblemi (più semplici) i quali possono essere a loro volta scomposti in ulteriori sottoproblemi. Il termine "bound" indica il fatto che per ogni sottoproblema viene calcolato il limite inferiore $L_i$ (quindi la soluzione ottima non sarà mai migliore di questo limite inferiore) e si tiene conto della soluzione migliore trovata fino a quel punto $U$: quando $L_i$ è "peggiore" di $U$ allora è possibile scartare a priori l'intero sottoproblema in quanto è già stata trovata una soluzione migliore del limite inferiore del sottoproblema (questo processo prende il nome di "pruning"). Il termine "branch" invece fa riferimento al fatto che i sottoproblemi vengono a loro volta divisi in ulteriori sottoproblemi (come visto prima), l'algoritmo branch-and-bound procede esplorando l'albero dei sottoproblemi generati (detto anche albero branch-and-bound) e scartando i sottoproblemi (pruning) con il criterio visto prima. I vari algoritmi differiscono in base al criterio di branching e di esplorazione dell'albero branch-and-bound. \newline \null \newline
Lo stato dell'arte degli algoritmi esatti per il TSP non sono i generici branch-and-bound ma sono algoritmi \textbf{branch-and-cut}\cite{Branch and Cut}: Branch and Cut è un metodo di ottimizzazione combinatoria simile al branch and bound, ma con alcune differenze fondamentali. Entrambi gli algoritmi mirano a trovare la soluzione ottimale per un problema complesso, dividendolo in sottoproblemi più piccoli e scartando (pruning) i sottoproblemi che in ogni caso non possono portare ad una soluzione parziale migliore di quella già nota. Tuttavia, l'algoritmo Branch and Cut si distingue per l'utilizzo di vincoli di taglio (cutting planes). Di seguito viene illustrato un generico algoritmo branch-and-cut:
\newlist{legal}{enumerate}{10}
\setlist[legal]{label*=\arabic*.}

\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Aggiungi il problema iniziale $ILP$ alla lista dei problemi attivi $L$.
  \item Sia $x^* = null$ e $v^* = -\infty$
  \item Finché $L$ non è vuota:
  \begin{legal}
    \item Seleziona e rimuovi un problema da L
    \item Risolvi il rilassamento continuo di L
    \item Se il problema è inammissibile torna al punto 3 (ciclo while). Altrimenti sia $x$ la soluzione trovata e $v$ il valore della funzione obiettivo.
    \item Se $v \leq v^*$ torna al punto 3
    \item Se $x$ è intero, aggiorna $v^* \leftarrow v$, $x^* \leftarrow x$ e torna al punto 3.
    \item Cerca dei piani di taglio che sono violati da $x$, se sono presenti aggiungili al rilassamento continuo di ILP e torna al punto 3.2
    \item Dividi il problema in sottoproblemi, aggiungi i sottoproblemi alla lista dei problemi attivi $L$, torna al punto 3.
  \end{legal}
  \item Restituisci $x^*$


\end{legal}
\end{tcolorbox}
\hfill \break
Come già detto in precedenza, questo approccio è attualmente lo stato dell'arte per risolvere il TSP all'ottimo. In letteratura esistono varie implementazioni di algoritmi branch-and-cut per il TSP\cite{Branch and Cut Algoritmhs}, sono presenti anche all'interno di risolutori MILP come ad esempio CPLEX. Questo approccio risulta migliore rispetto all'approccio brute-force, ma resta comunque non applicabile su istanze TSP con migliaia di città.

\chapter{Euristiche per il TSP}
Come discusso nel capitolo 2, i metodi esatti consentono di ottenere soluzioni ottime per il problema del TSP, ma il tempo per ottenere queste soluzioni aumenta esponenzialmente all'aumentare del numero di città presenti nell'istanza. Per affrontare il TSP, sono stati sviluppati numerosi approcci euristici, ovvero metodi che, pur non garantendo la soluzione ottimale, offrono soluzioni di buona qualità in tempi ragionevoli. Le euristiche sono fondamentali per applicazioni pratiche dove la rapidità di calcolo è essenziale. In questo capitolo esploreremo diverse tecniche euristiche, come le euristiche costruttive, che costruiscono una soluzione passo dopo passo a partire da una soluzione parziale, vedremo in particolare sulle euristiche basate su inserzione (Furthest Insertion fa parte di questa categoria) e poi "improvement euristics" ovvero le euristiche basate su meccanismi che consentono di "migliorare" la soluzione parziale trovata modificando il tour.
\section{Nearest Neighbor}
Nearest Neighbor è probabilmente l'euristica costruttiva più semplice per il TSP: si costruisce il tour selezionando sempre la città più vicina all'ultima appena aggiunta al tour. Appartiene alla categoria delle euristiche costruttive in quanto aggiunge via via nuove città al tour (soluzione parziale) senza modificare il tour costruito fino a quel punto. L'algoritmo è il seguente:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Seleziona un nodo arbitrario j, sia l = j e L = $\{1, 2, ..., n\} \setminus \{j\}$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Sia $j \in L$ tale che $c_{lj} = min\{c_{li} \  | \  i \in L\}$.
    \item Connetti l a j e rimuovi j da L, quindi $ L = L \setminus \{j\} $.
  \end{legal}
  \item Connetti l al primo nodo (era stato selezionato al punto 1) per formare un tour.
\end{legal}
\end{tcolorbox}
\hfill \break
Nearest Neighbor è una euristica con complessità temporale pari a $O(n^2)$ in quanto per ogni nodo nel tour (quindi n volte) è necessario cercare tra i restanti nodi, qual è il più vicino (al massimo n volte).

\section{Euristiche basate su Inserzione}
Le euristiche basate su inserzione appartengono alla categoria delle euristiche costruttive ma a differenza di Nearest Neighbor la soluzione viene costruita in un modo differente: si inizia da un piccolo tour (che include 2 o 1 città) il quale viene via via esteso includendo i nodi (città) non ancora aggiunti al tour. In questo tipo di euristiche la differenza fondamentale che le distingue sarà il criterio con il quale si aggiungono nuove città al tour e dove queste città devono essere inserite nel tour. Una qualunque euristica basata su inserzione quindi presenta la seguente struttura:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Seleziona una città o due città arbitrarie come tour iniziale $T$. Sia $L$ l'insieme delle città che sono fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $j \in L$ secondo un certo criterio.
    \item Inserisci $j$ nel tour in una determinata posizione.
    \item Rimuovi $j$ da L, quindi $L = L \setminus \{j\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break
Questo schema permette di ottenere un ciclo Hamiltoniano e quindi un percorso valido per il problema del TSP. Le varie euristiche andranno a definire un criterio di scelta del nodo j (punto 2.1) e un criterio di scelta della posizione di inserzione (punto 2.2).

\subsection{Nearest Insertion}
Nearest Insertion seleziona come nodo da inserire nel tour il nodo più vicino ad un qualunque nodo già inserito nel tour e lo inserisce nella posizione che minimizza il costo di inserimento. Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito dalla coppia delle città più vicine. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ che risulti il più vicino ad un nodo qualunque $j \in T$.
    \item Trova l'arco $(i, j)$ nel tour $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.  
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Nearest Insertion ha complessità computazionale pari a $O(n^2)$ in quanto ogni nodo (n iterazioni) deve essere inserito nel modo migliore possibile nel tour (fino a n iterazioni).

\subsection{Cheapest Insertion}
Cheapest Insertion opera in modo diverso da Nearest Insertion: il criterio di selezione non è più il nodo più vicino al tour, ma diventa il nodo che produce il minor aumento del costo del tour se inserito (quindi minimizza il costo di inserzione). Una volta selezionato, il nodo viene inserito nel modo migliore possibile, quindi minimizzando il costo di inserimento. Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
  \begin{legal}
    \item Sia $T$ il tour iniziale definito dalla coppia delle città più lontane. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
    \item Finché $L \neq \emptyset$:
    \begin{legal}
      \item Seleziona un nodo $r \in L$ e un arco $(i, j)$ in $T$ per cui $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}.
      \item Seleziona l'arco $(i, j)$ in $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.
      \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
    \end{legal}
  \end{legal}
  \end{tcolorbox}
\hfill \break Cheapest Insertion ha complessità computazionale pari a $O(n^2 log_2(n))$ in quanto è possibile implementare uno heap che tiene traccia dei nodi non ancora inseriti nel tour e dei relativi costi se inseriti nel modo migliore possibile.

\subsection{Farthest Insertion}
Farthest Insertion opera in analogo a Nearest Insertion in quanto il criterio di selezione del nodo da inserire è basato sulla distanza dal tour, ma differenza di Nearest Insertion però viene scelto il nodo più lontano dal tour al posto del più vicino. Il passo di inserzione avviene invece allo stesso modo rispetto a Nearest Insertion: viene quindi scelta la posizione che minimizza il costo di inserzione. Vediamo l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito dalla coppia delle città più lontane. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ che risulti il più \underline{lontano} rispetto ad un nodo qualunque $j \in T$.
    \item Trova l'arco $(i, j)$ nel tour $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.  
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Farthest Insertion ha complessità computazionale pari a $O(n^2)$ in modo del tutto analogo a Nearest Insertion.

\subsection{Furthest Insertion}
L'obbiettivo della tesi consiste nel proporre un nuovo algoritmo chiamato Furthest Insertion: allo stesso modo in cui Farthest Insertion opera in modo analogo a Nearest Insertion, Furthest Insertion opera in modo analogo a Cheapest Insertion. Il passo di selezione consiste nel selezionare il nodo che massimizza il costo di inserzione, in fase di inserimento però il nodo viene inserito in modo da minimizzare il costo di inserimento. Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito dalla coppia delle città più lontane. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ e un arco $(i, j)$ in $T$ per cui $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{massimo}.
    \item Seleziona l'arco $(i, j)$ in $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}. Inserisci $r$ tra $i$ e $j$.
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Furthest Insertion ha complessità computazionale pari a $O(n^2 log_2(n))$ in modo del tutto analogo a Cheapest Insertion.

\subsection{Random Insertion}
Random Insertion seleziona casualmente il nodo da inserire nel tour, successivamente però sceglie il punto di inserimento in modo da minimizzare il costo di inserimento (esattamente come per Nearest Insertion). Di seguito l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour iniziale definito da una città casuale. Sia $L$ l'insieme delle città fuori dal tour, quindi: $L = \{1, 2, ..., n\} \setminus T$.
  \item Finché $L \neq \emptyset$:
  \begin{legal}
    \item Seleziona un nodo $r \in L$ casualmente.
    \item Seleziona l'arco $(i, j)$ in $T$ tale che $c_{ir} + c_{rj} - c_{ij}$ risulti \underline{minimo}.
    \item Inserisci $r$ tra $i$ e $j$.  
    \item Rimuovi $r$ da L, quindi $L = L \setminus \{r\}$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break Random Insertion ha complessità computazionale pari a $O(n^2)$ in quanto n volte viene selezionato un nodo casuale, dopodiché è necessario iterare n volte alla ricerca della posizione migliore dove inserire il nodo.

\section{Ricerca Locale}
Le euristiche basate su ricerca locale\cite{Local Search} sono euristiche che implementano un meccanismo che consente di migliorare un tour (anche parziale), il meccanismo può ad esempio scambiare due nodi nel tour (vedremo nel dettaglio una euristica in particolare), rimuovere un nodo e inserirlo in un punto del tour migliore oppure implementare meccanismi più sofisticati.

\subsection{Node Insertion}
Questa euristica permette di migliorare un tour rimuovendo un nodo e inserendolo nel tour nel modo migliore possibile. Di seguito la procedura:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour (anche parziale).
  \item Ripeti finché il tour $T$ resta invariato:
  \begin{legal}
    \item Per ogni nodo $i = 1, 2, ..., n$: è possibile ridurre la lunghezza del tour rimuovendo il nodo i da una posizione $p_1$ e inserendo il nodo $i$ in un'altra posizione $p_2$? Se si, aggiorna $T$ spostando il nodo $i$ da $p_1$ a $p_2$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break
La procedura richiede tempo $O(n^2)$ in quanto per ogni nodo (n volte) è necessario ispezionare il possibile scambio di posizione (n volte).

\subsection{Edge Insertion}
In modo analogo a Node Insertion, questa euristica permette di migliorare un tour rimuovendo un arco (a differenza del nodo di prima) e inserendolo nel tour nel modo migliore possibile. Di seguito la procedura:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour (anche parziale).
  \item Ripeti finché il tour $T$ resta invariato:
  \begin{legal}
    \item Per ogni nodo $i = 1, 2, ..., n$, considera l'arco che collega $i$ con il nodo successivo nel tour, sia $(i, j)$ questo arco: è possibile ridurre la lunghezza del tour rimuovendo l'arco $(i, j)$ da una posizione $p_1$ e inserendo $(i, j)$ in un'altra posizione $p_2$? Se si, aggiorna $T$ spostando l'arco da $p_1$ a $p_2$.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break
La procedura richiede tempo $O(n^2)$ in modo del tutto analogo a Node Insertion.

\subsection{Euristica 2-Opt}
L'algoritmo 2-Opt\cite{2OPT} consente di eliminare due archi e di riconnetterli in un modo diverso, andando quindi a modificare il tour. Questa euristica deriva dall'osservazione empirica per cui due archi che si incrociano possono essere sempre riorganizzati in modo da non incrociarsi e questo produce sempre una riduzione della lunghezza totale del tour. La procedura consente di ridurre la lunghezza del tour riorganizzando una coppia di archi anche quando non si incrociano. Si nota che è sempre possibile ricombinarli in un unico modo diverso. Di seguito la procedura 2-Opt:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
\begin{legal}
  \item Sia $T$ il tour (anche parziale).
  \item Ripeti finché il tour $T$ resta invariato:
  \begin{legal}
    \item Per ogni nodo $i = 1, 2, ..., n$, considera tutti gli scambi 2-Opt possibili con l'arco $(i, j)$ dove $j$ è il nodo successivo ad $i$ nel tour. Se è possibile ridurre la lunghezza del tour applicando lo scambio 2-Opt, aggiorna T.
  \end{legal}
\end{legal}
\end{tcolorbox}
\hfill \break

\subsection{Euristica 3-Opt}
L'euristica 3-Opt è un'estensione dell'euristica vista precedentemente: al posto di eliminare due archi per ricombinarli in modo diverso, in questa euristica sono 3 gli archi che l'euristica rimuove e ricombina in modo diverso. A differenza di 2-Opt sono 8 i modi diversi in cui possono essere ricombinati questi archi\footnote{http://tsp-basics.blogspot.com/2017/03/3-opt-move.html} (includendo anche la configurazione in cui gli archi restano immutati). Vediamo l'algoritmo:

\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
  \begin{legal}
    \item Sia $T$ il tour.
    \item Per ogni nodo $i \in V$, sia $N(i)$ un insieme di nodi.
    \item Ripeti finché il tour $T$ resta invariato:
    \begin{legal}
      \item Per ogni nodo $i = 1, 2, ..., n$: considera tutti gli scambi 3-Opt possibili che includa $i$ e un nodo nell'insieme $N(i)$. Se è possibile ridurre la lunghezza del tour in questo modo, aggiorna T.
    \end{legal}
  \end{legal}
\end{tcolorbox}
\hfill \break
La scelta di ridurre l'insieme dei nodi $V$ a $N(i)$ è necessario in quanto analizzare tutti i possibili scambi che includano 3 nodi implica un tempo $O(n^3)$. L'insieme $N(i)$ può essere generato a partire a partire dal nodo $i$ ad esempio selezionando i 10 nodi più vicini ad $i$.
      
\subsection{Euristica Lin-Kernighan}
L'algoritmo Lin-Kernighan (LK)\cite{LK} è una delle migliori euristiche per risolvere il TSP. Appartiene alla classe degli algoritmi di ricerca locale, che prendono come input un tour (ciclo hamiltoniano) e tentano di migliorarlo cercando nella sua vicinanza un tour più corto, e una volta trovato ripetono il processo da quel nuovo tour, fino a incontrare un minimo locale.
L'algoritmo LK è stato sviluppato da Serge Lin e Brian Kernighan nel 1971 ed è stato dimostrato essere molto efficace per risolvere istanze di TSP di medie e grandi dimensioni. È spesso utilizzato come componente di algoritmi ibridi per il TSP, combinandolo con altre tecniche di ricerca per ottenere risultati ancora migliori. Di seguito una descrizione ad alto livello dell'algoritmo:
\setlist[legal]{label*=\arabic*.}
\begin{tcolorbox}[colframe=black,colback=white,boxrule=0.5pt, sharp corners]
  \begin{legal}
    \item Sia $T$ il tour iniziale, può essere generato casualmente oppure tramite altre euristiche come Nearest Neighbor. Sia $S$ la soluzione migliore fino a questo momento.
    \item Ripeti finché il tour $T$ resta invariato (e quindi è stato trovato un minimo locale):
    \begin{legal}
      \item Applica l'algoritmo k-Opt. Inizialmente $k$ deve essere un valore piccolo (2 o 3), aumenta man mano il valore $k$.
    \end{legal}
    \item Una volta trovato un minimo locale, se è migliore di $S$ allora aggiorna $S$. Torna al punto 1 generando un tour diverso da quello di partenza, oppure l'algoritmo termina e S è la soluzione trovata.
  \end{legal}
\end{tcolorbox}
\hfill \break
L'euristica Lin-Kernighan è considerata una delle migliori euristiche per generare soluzioni ottime o quasi-ottime per il problema del TSP\cite{Helsgaun}.

\lstset{
  language=Python, 
  basicstyle=\ttfamily, 
  keywordstyle=\color{blue}, 
  commentstyle=\color{gray}, 
  stringstyle=\color{red}, 
  showstringspaces=false,
  numbers=left,                 % Aggiunge i numeri di riga a sinistra
  numberstyle=\tiny\color{gray}, % Stile per i numeri di riga
  stepnumber=1,                 % Numerare ogni riga
  numbersep=10pt                % Distanza tra i numeri di riga e il codice
}
\chapter{Implementazione delle euristiche}
Questo capitolo descrive l'implementazione di una classe Python chiamata "TSP" la quale deve:
\begin{legal}
  \item Poter consentire di importare istanze del TSP nelle strutture dati necessarie
  \item Implementare le principali euristiche viste nel capitolo 2
  \item Poter consentire di ottenere i dati relativi alla qualità delle soluzioni e tempi dell'euristica
\end{legal}
Per il progetto è stata scelta la libreria TSP-LIB\footnote{http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/} come fonte di istanze per il TSP in quanto in letteratura è ampiamente utilizzata per testare e confrontare algoritmi e euristiche progettate per risolvere il TSP. Nel progetto, le istanze sono state tutte collocate nella directory "ALL-TSP" dove sono presenti due tipi di file: "NOME.tsp" e "NOME.opt.tour" dove la prima contiene i dati relativi all'istanza chiamata "NOME", mentre la seconda contiene la soluzione ottima per quella istanza.

\section{Implementazione del costruttore della classe}
Il costruttore della classe deve consentire di importare i dati relativi ad una istanza specifica del TSP contenuta nella cartella "TSP-ALL", di seguito l'implementazione:
\begin{python}
def __init__(self, name, ignoraOpt=False):
  self.ignoraOpt = ignoraOpt
  self.openTSP(name)
  self.name = name
  self.optimalSolution = soluzioneOttima[name]
\end{python}
Dove: \lstinline!self.openTSP()! è il metodo che effettivamente importa i dati dal file relativo, inoltre sono presenti gli attributi \lstinline!self.name! il quale semplicemente memorizza il nome dell'istanza TSP e l'attributo \lstinline!self.optimalSolution! che memorizza il valore della soluzione ottima dal file "NOME.opt.tour". \hfill \break
Di seguito l'analisi del metodo \lstinline!self.openTSP(name)!:
\begin{python}
def openTSP(self, name):
  # estraggo i dati delle coordinate euclidee
  f = open(f"ALL-TSP/{name}.tsp")
  self.numCity = -1
  i = 0
  data = False
  self.coord = []
  for line in f:
    if "EOF" in line:
      break
    if line == "":
      continue
    if data:
      line = line.replace("  ", " ").replace("  ", " ").replace("\n", "").strip()
      if "." in line.split(" ")[1]:
          self.coord.append([int(float(line.split(" ")[1])), int(float(line.split(" ")[2]))])
      else:
          self.coord.append([int(line.split(" ")[1]), int(line.split(" ")[2])])
    if "DIMENSION" in line:
      self.numCity = int(line.split(": ")[1])
    if "NODE_COORD_SECTION" in line:
      data = True
  f.close()
\end{python}
Questa prima parte del metodo permette di aprire il file relativo all'istanza TSP e importa nella lista \lstinline!self.coord! tutte le coppie $(x, y)$ che rappresentano le coordinate cartesiane dei punti.
\begin{python}
def openTSP(self, name):
  ...
  self.adj = [[0 for _ in range(self.numCity)] for _ in range(self.numCity)]
  for i in range(self.numCity):
    for j in range(i):
      if i == j:
        continue
      else:
        self.adj[i][j] = self.adj[j][i] = self.distance(self.coord[i], self.coord[j])
\end{python}
In questa seconda parte del metodo viene calcolata la matrice di adiacenza dell'istanza TSP e memorizzata nell'istanza \lstinline!self.adj! (il metodo \lstinline!self.distance! verrà descritto nella prossima sezione).
\begin{python}
def openTSP(self, name):
  ...
  if not self.ignoraOpt:
      # leggo il persorso ottimale
      f = open(f"ALL-TSP/{name}.opt.tour")
      self.optTour = [-1 for _ in range(self.numCity)]
      self.tour = [-1 for _ in range(self.numCity)]
      data = False
      i = 0
      for line in f:
        if "-1" in line:
          break
        if data:
          # considero i nodi del grafo a partire da 0 e non da 1 come su TSP LIB
          self.optTour[i] = int(line) - 1
          i += 1
        if "TOUR_SECTION" in line:
          data = True
      f.close()
  else:
    self.optTour = [-1 for _ in range(self.numCity)]
    self.tour = [-1 for _ in range(self.numCity)]
\end{python}
L'ultima parte del metodo consente di inizializzare le liste  \lstinline!self.optTour! e \lstinline!self.tour! dove la prima contiene la soluzione ottima contenuta nel file "NOME.opt.tour" e la seconda sarà invece utilizzata dalle euristiche costruttive per "costruire" man mano la soluzione.

\section{Implementazione di metodi ausiliari per le euristiche}
In questa sezione analizzo l'implementazione di metodi ausiliari e di supporto. Questi metodi fattorizzano il codice utilizzato frequentemente da diverse euristiche, migliorando la modularità, la leggibilità e la manutenibilità del codice.
\begin{python}
  def distance(self, a, b):
    return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)
\end{python}
Questo metodo (come visto prima) semplicemente consente di calcolare la distanza euclidea tra due punti a e b.
\begin{python}
def openRandomTSP(self, n):
  self.name = "random"
  self.numCity = n
  self.adj = [[0 for _ in range(self.numCity)] for _ in range(self.numCity)]
  for i in range(self.numCity):
    for j in range(i):
      if i == j:
        continue
      else:
        self.adj[i][j] = self.adj[j][i] = random.randint(0, 1000)
\end{python}
Questo metodo consente di generare una istanza casuale del TSP dato come parametro un numero intero n (il numero di città). Dato che il progetto si limita al TSP simmetrico, alla riga 10 si assegna lo stesso valore sia all'arco $(i, j)$ che all'arco $(j, i)$.
\begin{python}
def calculateCost(self):
  self.cost = 0
  for i in range(self.numCity - 1):
    self.cost += self.adj[self.tour[i]][self.tour[i + 1]]
  self.cost += self.adj[self.tour[self.numCity - 1]][self.tour[0]]
\end{python}
Il metodo \lstinline!calculateCost()! consente di assegnare all'attributo \lstinline!self.cost! il costo del tour, che si ottiene sommando i costi degli archi $(i, j)$ per ogni coppia di archi contenuti nel tour. Essendo un ciclo hamiltoniano, alla fine del ciclo for si aggiunge anche il costo per tornare al punto di partenza \lstinline!self.tour[0]!.
\begin{python}
def calculateOptimalCost(self):
  self.cost = 0
  for i in range(self.numCity - 1):
    self.cost += self.adj[self.optTour[i]][self.optTour[i + 1]]
  self.cost += self.adj[self.optTour[self.numCity - 1]][self.optTour[0]]
\end{python}
Il metodo \lstinline!calculateOptimalCost()! consente in modo del tutto analogo al metodo \lstinline!calculateCost()! di calcolare il costo del tour, con la differenza che si considera il tour ottimo (attributo \lstinline!self.optTour!) al posto del tour del metodo precedente.
\begin{python}
def verifyTour(self):
  for i in range(self.numCity):
    if not i in self.tour:
      print(f"ERRORE, manca {i}")
      return False
    if self.tour.count(i) != 1:
      print(f"ERRORE, il numero {i} risulta esserci {self.tour.count(i)} volte")
      return False
  return True
\end{python}
Il metodo \lstinline!verifyTour()! consente di testare la correttezza del tour trovato dall'euristica, è quindi pensato per essere verificato (tramite un \lstinline!assert!). Il metodo si limita a verificare che ogni nodo deve essere presente nel tour esattamente una volta sola, il metodo chiaramente non garantisce la presenza di altri errori nell'implementazione dell'euristica.

\section{Implementazione delle euristiche}
In questo capitolo, descriveremo l'implementazione delle euristiche per la risoluzione del TSP, in particolare verranno implementate le euristiche costruttive presentate nei capitoli 2.1 e 2.2.
\subsection{Nearest Neighbor}
L'euristica del Nearest Neighbor (NN) costruisce un tour partendo da una città e, iterativamente, aggiungendo la città non visitata più vicina fino a quando tutte le città non sono state visitate. Di seguito viene riportato il codice per questa euristica.
\begin{python}
def nearestNeighbor(self):
  self.tour = [0]
  visited = set([0])
  notVisited = set(range(1, self.numCity))
  while len(self.tour) < self.numCity:
    cost = np.inf
    j = -1
    for j2 in notVisited:
      if self.adj[self.tour[-1]][j2] < cost:
        cost = self.adj[self.tour[-1]][j2]
        j = j2
    self.tour.append(j)
    visited.add(j)
    notVisited.remove(j)
  self.calculateCost()
\end{python}
Per semplicità ho scelto la prima città (nodo 0) come città iniziale, dopodiché finché sono presenti nodi da aggiungere al tour, si cerca un nodo j non ancora visitato che sia il più vicino possibile all'ultimo nodo aggiunto al tour (\lstinline!self.tour[-1]!), inoltre sono presenti gli insiemi (set) visited e nonVisited che tengono traccia dei nodi presenti o non presenti nel tour. Alla fine viene calcolato il costo del tour trovato tramite il metodo \lstinline!self.calculateCost()!.
%
%			BIBLIOGRAFIA
%

\begin{thebibliography}{00}
\bibitem{Menger}
Traveling Salesman Problem, F. Greco, IntechOpen, 2008.
\bibitem{TSP formulation}
M. Velednitsky, Short Combinatorial Proof that the DFJ Polytope is contained in
the MTZ Polytope for the Asymmetric Traveling Salesman Problem, UC Berkeley, 2018.
%
\bibitem{Analysis of Brute Force}
Analysis of Brute Force and Branch \& Bound Algorithms to solve the Traveling
Salesperson Problem (TSP), Informatics Department, Engineering Faculty, Widyatama University, 2021.
%
\bibitem{Branch and Bound}
T. G. Crainic, B. Le Cun, C. Roucairol, Parallel Branch-and-Bound Algorithms, Département de management et technologie École des Sciences de la Gestion Université du Québec à Montréal and CIRRELT, Canada
\bibitem{Branch and Cut Algoritmhs}
Yuan Yuan, Diego Cattaruzza, Maxime Ogier, Frederic Semet. A branch-and-cut algorithm for the generalized traveling salesman problem with time windows. European Journal of Operational Research, 2020, 286 (3)
%
\bibitem{TSP NP Completezza}
R. Karp, Complexity of the Traveling Salesman Problem
%
\bibitem{Reinelt}
G. Reinelt, The Traveling Salesman: Computational Solution for TSP Applications, Heidelberg, Springer-Verlag
\bibitem{Branch and Cut}
J.E. Mitchell, Branch-and-cut algorithms for combinatorial
optimization problems, in Handbook of applied optimization, P.M.
Pardalos and M.G.C. Resende eds., Oxford University Press, 2000
\bibitem{Local Search}
Olaf Mersmann, Bernd Bischl, Jakob Bossek, Heike Trautmann, Markus Wagner, Frank Neumann, Local Search and the Traveling Salesman Problem: A Feature-Based Characterization of Problem Hardness, Statistics Faculty, TU Dortmund University, Germany
\bibitem{2OPT}
Matthias Englert, Heiko Röglin, Berthold Vöcking, Worst Case and Probabilistic Analysis 
of the 2-Opt Algorithm for the TSP, Dept. of Computer Science, RWTH Aachen University
\bibitem{LK}
S. Lin, B. W. Kernighan, An Effective Heuristic Algorithm for the Traveling-
Salesman Problem, Bell Telephone Laboratories, Incorporated, Murray Hill, N.J., 1971
\bibitem{Helsgaun}
K. Helsgaun, An effective implementation of the Lin-Kernighan traveling
salesman heuristic, Department of Computer Science, Roskilde Universit, 13 April 1999

%\bibitem{gotti91}
%M. Gotti, I linguaggi specialistici, Firenze, La Nuova Italia, 1991.
\end{thebibliography}
% 
\end{document}


 
