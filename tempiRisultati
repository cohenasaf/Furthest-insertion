
Optimal 15780
_________________
d198
randomInsertion 1.067667472674878
nearestInsertion 1.1374895391025315
cheapestInsertion 1.1271832051629462
nearestNeighbor 1.2180456604337535
farthestInsertion 1.1164503836032085
furthestInsertion 1.0814534582735476

[('d198', 1.067667472674878, 1.1374895391025315, 1.1271832051629462, 1.2180456604337535, 1.1164503836032085, 1.0814534582735476)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.0299517 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.8      0.8      0.0          n = self.numCity
   115         1       1833.4   1833.4      6.1          distances = np.array(self.adj)
   116         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.5      0.5      0.0          in_path = {0}
   118         1         15.3     15.3      0.1          notInPath = [x for x in range(1, n)]
   119         1        204.4    204.4      0.7          random.shuffle(notInPath)
   120                                           
   121       198         54.2      0.3      0.2          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       197         41.8      0.2      0.1              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       197         37.8      0.2      0.1              best_increase = np.inf
   127       197         28.1      0.1      0.1              best_position = None
   128     19700       3177.1      0.2     10.6              for i in range(len(path)):
   129     19503       4610.1      0.2     15.4                  next_i = (i + 1) % len(path)
   130     19503      15014.3      0.8     50.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     19503       3716.7      0.2     12.4                  if increase < best_increase:
   132      3467        489.2      0.1      1.6                      best_increase = increase
   133      3467        536.6      0.2      1.8                      best_position = next_i
   134                                           
   135       197         63.7      0.3      0.2              path.insert(best_position, to_insert)
   136       197         51.4      0.3      0.2              in_path.add(to_insert)
   137                                           
   138         1          0.8      0.8      0.0          self.tour = path
   139         1         75.1     75.1      0.3          self.calculateCost()

Total time: 0.00965608 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          1.0      1.0      0.0          self.tour = [0]
   144         1          1.5      1.5      0.0          visited = set([0])
   145         1          3.2      3.2      0.0          notVisited = set(range(1, self.numCity))
   146       198         61.8      0.3      0.6          while len(self.tour) < self.numCity:
   147       197         34.9      0.2      0.4              cost = np.inf
   148       197         25.5      0.1      0.3              j = -1
   149     19700       3089.0      0.2     32.0              for j2 in notVisited:
   150     19503       5716.7      0.3     59.2                  if self.adj[self.tour[-1]][j2] < cost:
   151      1347        308.5      0.2      3.2                      cost = self.adj[self.tour[-1]][j2]
   152      1347        195.5      0.1      2.0                      j = j2
   153       197         53.7      0.3      0.6              self.tour.append(j)
   154       197         43.8      0.2      0.5              visited.add(j)
   155       197         44.0      0.2      0.5              notVisited.remove(j)
   156         1         76.8     76.8      0.8          self.calculateCost()

Total time: 0.0532096 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.5      0.5      0.0          n = self.numCity
   162         1       1029.6   1029.6      1.9          distances = np.array(self.adj)
   163         1          0.4      0.4      0.0          path = [0, 0]
   164                                           
   165         1          0.4      0.4      0.0          minDist = np.inf
   166       199         25.7      0.1      0.0          for i in range(n):
   167     19701       3052.8      0.2      5.7              for j in range(0, i):
   168     19503       7628.6      0.4     14.3                  if distances[i][j] < minDist:
   169         6          1.5      0.2      0.0                      path[0], path[1] = i, j
   170         6          2.4      0.4      0.0                      minDist = distances[i][j]
   171         1          0.6      0.6      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.3      0.3      0.0          h = []
   176       197         38.6      0.2      0.1          for i in set(range(n)) - in_path:
   177       196        279.4      1.4      0.5              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         12.8     12.8      0.0          heapq.heapify(h)
   179                                           
   180       197         53.3      0.3      0.1          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182       196        104.7      0.5      0.2              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185       196         37.9      0.2      0.1              best_increase = np.inf
   186       196         26.3      0.1      0.0              best_position = None
   187     19698       3016.3      0.2      5.7              for i in range(len(path)):
   188     19502       4586.5      0.2      8.6                  next_i = (i + 1) % len(path)
   189     19502      14564.0      0.7     27.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190     19502       3790.9      0.2      7.1                  if increase < best_increase:
   191      3531        492.9      0.1      0.9                      best_increase = increase
   192      3531        658.6      0.2      1.2                      best_position = i + 1
   193                                           
   194       196         65.6      0.3      0.1              path.insert(best_position, to_insert)
   195       196         45.6      0.2      0.1              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198     19306       4144.1      0.2      7.8              for i, (cost, node) in enumerate(h):
   199     19110       6756.3      0.4     12.7                  if node not in in_path and distances[to_insert, node] < cost:
   200      4407       1380.8      0.3      2.6                      h[i] = (distances[to_insert, node], node)
   201       196       1306.2      6.7      2.5              heapq.heapify(h)
   202                                           
   203         1          0.7      0.7      0.0          self.tour = path
   204         1        105.3    105.3      0.2          self.calculateCost()

Total time: 0.126145 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.3      0.3      0.0          n = self.numCity
   209         1        958.6    958.6      0.8          adj = np.array(self.adj)
   210         1       1037.0   1037.0      0.8          distances = np.array(self.adj)
   211         1          0.3      0.3      0.0          path = [0, 0]
   212                                           
   213         1          0.3      0.3      0.0          minDist = np.inf
   214       199         26.8      0.1      0.0          for i in range(n):
   215     19701       3099.7      0.2      2.5              for j in range(0, i):
   216     19503       7448.2      0.4      5.9                  if distances[i][j] < minDist:
   217         6          1.4      0.2      0.0                      path[0], path[1] = i, j
   218         6          2.3      0.4      0.0                      minDist = distances[i][j]
   219         1          0.5      0.5      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.2      0.2      0.0          h = []
   222       197         38.1      0.2      0.0          for i in set(range(n)) - in_path:
   223       196        174.9      0.9      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224       196         74.6      0.4      0.1              h.append((cost, i, path[0], path[1]))
   225         1         11.9     11.9      0.0          heapq.heapify(h)
   226                                           
   227       197         66.9      0.3      0.1          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229       196        136.3      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232       196         57.9      0.3      0.0              best_increase = np.inf
   233       196         29.8      0.2      0.0              best_pos = None
   234     19698       3208.8      0.2      2.5              for i in range(len(path)):
   235     19502       4683.3      0.2      3.7                  next_i = (i + 1) % len(path)
   236     19502      15304.6      0.8     12.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237     19502       3776.8      0.2      3.0                  if increase < best_increase:
   238      3650        535.2      0.1      0.4                      best_increase = increase
   239      3650        594.2      0.2      0.5                      best_pos = next_i
   240                                           
   241       196         88.5      0.5      0.1              path.insert(best_pos, to_ins)
   242       196         50.9      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247     19306       4587.3      0.2      3.6              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249     19110       7689.3      0.4      6.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       171         32.4      0.2      0.0                      best_cost = np.inf
   251       171         27.0      0.2      0.0                      posL, posR = -1, -1
   252      2204        388.7      0.2      0.3                      for i2 in range(len(path)):
   253      2033        488.8      0.2      0.4                          next_i = (i2 + 1) % len(path)
   254      2033       2301.7      1.1      1.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255      2033        394.0      0.2      0.3                          if best_cost > insertion_cost:
   256       694        169.8      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       171         41.3      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260     19110      25528.6      1.3     20.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261      3845       4647.4      1.2      3.7                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262      3845       1520.3      0.4      1.2                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265      3845       1016.6      0.3      0.8                      best_pos = (best_pos + 1) % (len(path))
   266     19110      26751.6      1.4     21.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267      4491       5536.1      1.2      4.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268      4491       2114.5      0.5      1.7                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269       196       1391.6      7.1      1.1              heapq.heapify(h)
   270                                           
   271         1          2.2      2.2      0.0          self.tour = path
   272         1        107.0    107.0      0.1          self.calculateCost()

Total time: 0.0550625 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.5      0.5      0.0          n = self.numCity
   277         1       1000.4   1000.4      1.8          distances = np.array(self.adj)
   278         1          0.4      0.4      0.0          path = [0, 0]
   279                                           
   280         1          0.1      0.1      0.0          maxDist = 0
   281       199         26.4      0.1      0.0          for i in range(n):
   282     19701       3003.8      0.2      5.5              for j in range(0, i):
   283     19503       7342.6      0.4     13.3                  if distances[i][j] > maxDist:
   284        53         12.2      0.2      0.0                      path[0], path[1] = i, j
   285        53         19.1      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.2      1.2      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.2      0.2      0.0          h = []
   291       197         33.5      0.2      0.1          for i in set(range(n)) - in_path:
   292       196        134.4      0.7      0.2              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         13.0     13.0      0.0          heapq.heapify(h)
   294                                           
   295       197         56.5      0.3      0.1          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297       196        103.7      0.5      0.2              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300       196         37.7      0.2      0.1              best_increase = np.inf
   301       196         25.8      0.1      0.0              best_position = None
   302     19698       3046.3      0.2      5.5              for i in range(len(path)):
   303     19502       4726.8      0.2      8.6                  next_i = (i + 1) % len(path)
   304     19502      14725.0      0.8     26.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305     19502       3580.8      0.2      6.5                  if increase < best_increase:
   306      3707        478.7      0.1      0.9                      best_increase = increase
   307      3707        678.8      0.2      1.2                      best_position = i + 1
   308                                           
   309       196         59.9      0.3      0.1              path.insert(best_position, to_insert)
   310       196         44.1      0.2      0.1              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313     19306       3705.4      0.2      6.7              for i, (cost, node) in enumerate(h):
   314     19110       3855.4      0.2      7.0                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316     19110       6985.2      0.4     12.7                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318       196       1287.8      6.6      2.3              heapq.heapify(h)
   319                                           
   320         1          0.7      0.7      0.0          self.tour = path
   321         1         75.7     75.7      0.1          self.calculateCost()

Total time: 0.109812 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.3      0.3      0.0          n = self.numCity
   326         1        993.0    993.0      0.9          adj = np.array(self.adj)
   327         1       1033.4   1033.4      0.9          distances = np.array(self.adj)
   328         1          0.3      0.3      0.0          path = [0, 0]
   329                                           
   330         1          0.1      0.1      0.0          maxDist = 0
   331       199         26.9      0.1      0.0          for i in range(n):
   332     19701       3037.3      0.2      2.8              for j in range(0, i):
   333     19503       7449.2      0.4      6.8                  if distances[i][j] > maxDist:
   334        53         11.0      0.2      0.0                      path[0], path[1] = i, j
   335        53         19.1      0.4      0.0                      maxDist = distances[i][j]
   336         1          0.7      0.7      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.3      0.3      0.0          h = []
   339       197         32.8      0.2      0.0          for i in set(range(n)) - in_path:
   340       196        173.5      0.9      0.2              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341       196         73.4      0.4      0.1              h.append((-cost, i, path[0], path[1]))
   342         1         11.4     11.4      0.0          heapq.heapify(h)
   343                                           
   344       197         62.5      0.3      0.1          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346       196        113.9      0.6      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349       196         38.3      0.2      0.0              best_increase = np.inf
   350       196         25.7      0.1      0.0              best_pos = None
   351     19698       3137.6      0.2      2.9              for i in range(len(path)):
   352     19502       4766.4      0.2      4.3                  next_i = (i + 1) % len(path)
   353     19502      14755.7      0.8     13.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354     19502       3604.3      0.2      3.3                  if increase < best_increase:
   355      2291        309.0      0.1      0.3                      best_increase = increase
   356      2291        339.1      0.1      0.3                      best_pos = next_i
   357                                           
   358       196         63.1      0.3      0.1              path.insert(best_pos, to_ins)
   359       196         45.6      0.2      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362     19306       4352.0      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363     19110       3734.9      0.2      3.4                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365     19110       6804.3      0.4      6.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366        43          8.6      0.2      0.0                      best_cost = np.inf
   367        43          7.4      0.2      0.0                      posL, posR = -1, -1
   368      2444        382.3      0.2      0.3                      for i2 in range(len(path)):
   369      2401        602.3      0.3      0.5                          next_i = (i2 + 1) % len(path)
   370      2401       2335.7      1.0      2.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371      2401        442.9      0.2      0.4                          if best_cost > insertion_cost:
   372       323         67.3      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   373        43         12.8      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376     19110      23546.2      1.2     21.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377        59         68.7      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378        59         21.8      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381        59         14.5      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382     19110      25277.7      1.3     23.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383       384        437.4      1.1      0.4                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384       384        186.8      0.5      0.2                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385       196       1301.0      6.6      1.2              heapq.heapify(h)
   386                                           
   387         1          0.6      0.6      0.0          self.tour = path
   388         1         82.5     82.5      0.1          self.calculateCost()


Optimal 42029
_________________
lin318
randomInsertion 1.0816829108769233
nearestInsertion 1.2443578764303442
cheapestInsertion 1.2224883844694991
nearestNeighbor 1.2856260385277645
farthestInsertion 1.2338716316761469
furthestInsertion 1.1255439965244145

[('lin318', 1.0816829108769233, 1.2443578764303442, 1.2224883844694991, 1.2856260385277645, 1.2338716316761469, 1.1255439965244145)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.0729571 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.6      0.6      0.0          n = self.numCity
   115         1       2712.5   2712.5      3.7          distances = np.array(self.adj)
   116         1          0.4      0.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.4      0.4      0.0          in_path = {0}
   118         1         22.3     22.3      0.0          notInPath = [x for x in range(1, n)]
   119         1        303.7    303.7      0.4          random.shuffle(notInPath)
   120                                           
   121       318         83.0      0.3      0.1          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       317         63.8      0.2      0.1              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       317         65.3      0.2      0.1              best_increase = np.inf
   127       317         44.1      0.1      0.1              best_position = None
   128     50720       8096.8      0.2     11.1              for i in range(len(path)):
   129     50403      12492.9      0.2     17.1                  next_i = (i + 1) % len(path)
   130     50403      37503.7      0.7     51.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     50403       9853.2      0.2     13.5                  if increase < best_increase:
   132      4774        640.5      0.1      0.9                      best_increase = increase
   133      4774        751.3      0.2      1.0                      best_position = next_i
   134                                           
   135       317        112.5      0.4      0.2              path.insert(best_position, to_insert)
   136       317         86.0      0.3      0.1              in_path.add(to_insert)
   137                                           
   138         1          1.0      1.0      0.0          self.tour = path
   139         1        123.1    123.1      0.2          self.calculateCost()

Total time: 0.0248607 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          1.3      1.3      0.0          self.tour = [0]
   144         1          0.9      0.9      0.0          visited = set([0])
   145         1          5.6      5.6      0.0          notVisited = set(range(1, self.numCity))
   146       318        109.1      0.3      0.4          while len(self.tour) < self.numCity:
   147       317         70.9      0.2      0.3              cost = np.inf
   148       317         40.2      0.1      0.2              j = -1
   149     50720       8072.0      0.2     32.5              for j2 in notVisited:
   150     50403      15242.6      0.3     61.3                  if self.adj[self.tour[-1]][j2] < cost:
   151      2415        611.7      0.3      2.5                      cost = self.adj[self.tour[-1]][j2]
   152      2415        331.5      0.1      1.3                      j = j2
   153       317         95.6      0.3      0.4              self.tour.append(j)
   154       317         86.4      0.3      0.3              visited.add(j)
   155       317         72.4      0.2      0.3              notVisited.remove(j)
   156         1        120.5    120.5      0.5          self.calculateCost()

Total time: 0.133309 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.5      0.5      0.0          n = self.numCity
   162         1       2812.3   2812.3      2.1          distances = np.array(self.adj)
   163         1          0.4      0.4      0.0          path = [0, 0]
   164                                           
   165         1          0.3      0.3      0.0          minDist = np.inf
   166       319         43.4      0.1      0.0          for i in range(n):
   167     50721       7886.1      0.2      5.9              for j in range(0, i):
   168     50403      18308.2      0.4     13.7                  if distances[i][j] < minDist:
   169         1          0.4      0.4      0.0                      path[0], path[1] = i, j
   170         1          0.4      0.4      0.0                      minDist = distances[i][j]
   171         1          0.6      0.6      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.2      0.2      0.0          h = []
   176       317         68.9      0.2      0.1          for i in set(range(n)) - in_path:
   177       316        213.3      0.7      0.2              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         22.0     22.0      0.0          heapq.heapify(h)
   179                                           
   180       317         87.7      0.3      0.1          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182       316        180.7      0.6      0.1              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185       316         62.4      0.2      0.0              best_increase = np.inf
   186       316         40.9      0.1      0.0              best_position = None
   187     50718       7436.9      0.1      5.6              for i in range(len(path)):
   188     50402      11308.2      0.2      8.5                  next_i = (i + 1) % len(path)
   189     50402      38176.3      0.8     28.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190     50402       9254.1      0.2      6.9                  if increase < best_increase:
   191      6539        925.1      0.1      0.7                      best_increase = increase
   192      6539       1141.7      0.2      0.9                      best_position = i + 1
   193                                           
   194       316        116.9      0.4      0.1              path.insert(best_position, to_insert)
   195       316         73.9      0.2      0.1              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198     50086      10517.9      0.2      7.9              for i, (cost, node) in enumerate(h):
   199     49770      17189.0      0.3     12.9                  if node not in in_path and distances[to_insert, node] < cost:
   200     12310       3963.1      0.3      3.0                      h[i] = (distances[to_insert, node], node)
   201       316       3338.4     10.6      2.5              heapq.heapify(h)
   202                                           
   203         1          1.8      1.8      0.0          self.tour = path
   204         1        137.4    137.4      0.1          self.calculateCost()

Total time: 0.293518 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.4      0.4      0.0          n = self.numCity
   209         1       2660.5   2660.5      0.9          adj = np.array(self.adj)
   210         1       2710.8   2710.8      0.9          distances = np.array(self.adj)
   211         1          0.4      0.4      0.0          path = [0, 0]
   212                                           
   213         1          0.3      0.3      0.0          minDist = np.inf
   214       319         43.3      0.1      0.0          for i in range(n):
   215     50721       7747.6      0.2      2.6              for j in range(0, i):
   216     50403      17880.8      0.4      6.1                  if distances[i][j] < minDist:
   217         1          0.4      0.4      0.0                      path[0], path[1] = i, j
   218         1          0.4      0.4      0.0                      minDist = distances[i][j]
   219         1          0.6      0.6      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.3      0.3      0.0          h = []
   222       317         72.9      0.2      0.0          for i in set(range(n)) - in_path:
   223       316        287.8      0.9      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224       316        274.0      0.9      0.1              h.append((cost, i, path[0], path[1]))
   225         1         21.5     21.5      0.0          heapq.heapify(h)
   226                                           
   227       317        108.8      0.3      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229       316        214.3      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232       316         68.4      0.2      0.0              best_increase = np.inf
   233       316         47.8      0.2      0.0              best_pos = None
   234     50718       7745.5      0.2      2.6              for i in range(len(path)):
   235     50402      11730.8      0.2      4.0                  next_i = (i + 1) % len(path)
   236     50402      37890.7      0.8     12.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237     50402       9392.9      0.2      3.2                  if increase < best_increase:
   238      6834        932.5      0.1      0.3                      best_increase = increase
   239      6834       1003.7      0.1      0.3                      best_pos = next_i
   240                                           
   241       316        123.2      0.4      0.0              path.insert(best_pos, to_ins)
   242       316         77.1      0.2      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247     50086      11927.0      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249     49770      18006.0      0.4      6.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       246         46.9      0.2      0.0                      best_cost = np.inf
   251       246         40.0      0.2      0.0                      posL, posR = -1, -1
   252      7078       1167.7      0.2      0.4                      for i2 in range(len(path)):
   253      6832       1548.1      0.2      0.5                          next_i = (i2 + 1) % len(path)
   254      6832       6149.8      0.9      2.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255      6832       1281.0      0.2      0.4                          if best_cost > insertion_cost:
   256      1260        297.6      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       246         56.8      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260     49770      59091.3      1.2     20.1                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261      8122       8571.5      1.1      2.9                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262      8122       2908.9      0.4      1.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265      8122       1904.6      0.2      0.6                      best_pos = (best_pos + 1) % (len(path))
   266     49770      61550.3      1.2     21.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267      9519      10293.6      1.1      3.5                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268      9519       3936.9      0.4      1.3                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269       316       3530.3     11.2      1.2              heapq.heapify(h)
   270                                           
   271         1          2.2      2.2      0.0          self.tour = path
   272         1        170.0    170.0      0.1          self.calculateCost()

Total time: 0.138258 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.4      0.4      0.0          n = self.numCity
   277         1       2552.0   2552.0      1.8          distances = np.array(self.adj)
   278         1          0.4      0.4      0.0          path = [0, 0]
   279                                           
   280         1          0.1      0.1      0.0          maxDist = 0
   281       319         43.0      0.1      0.0          for i in range(n):
   282     50721       7577.2      0.1      5.5              for j in range(0, i):
   283     50403      17820.6      0.4     12.9                  if distances[i][j] > maxDist:
   284        60         12.3      0.2      0.0                      path[0], path[1] = i, j
   285        60         19.1      0.3      0.0                      maxDist = distances[i][j]
   286         1          1.0      1.0      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.4      0.4      0.0          h = []
   291       317         54.4      0.2      0.0          for i in set(range(n)) - in_path:
   292       316        210.0      0.7      0.2              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         20.1     20.1      0.0          heapq.heapify(h)
   294                                           
   295       317        104.5      0.3      0.1          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297       316        178.7      0.6      0.1              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300       316         66.5      0.2      0.0              best_increase = np.inf
   301       316         43.3      0.1      0.0              best_position = None
   302     50718       7574.4      0.1      5.5              for i in range(len(path)):
   303     50402      11316.2      0.2      8.2                  next_i = (i + 1) % len(path)
   304     50402      37960.3      0.8     27.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305     50402       9228.9      0.2      6.7                  if increase < best_increase:
   306      5086        624.9      0.1      0.5                      best_increase = increase
   307      5086        928.2      0.2      0.7                      best_position = i + 1
   308                                           
   309       316        102.0      0.3      0.1              path.insert(best_position, to_insert)
   310       316         71.7      0.2      0.1              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313     50086       9652.3      0.2      7.0              for i, (cost, node) in enumerate(h):
   314     49770      10351.7      0.2      7.5                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316     49770      18292.4      0.4     13.2                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318       316       3315.7     10.5      2.4              heapq.heapify(h)
   319                                           
   320         1          1.8      1.8      0.0          self.tour = path
   321         1        133.1    133.1      0.1          self.calculateCost()

Total time: 0.274271 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.3      0.3      0.0          n = self.numCity
   326         1       2586.2   2586.2      0.9          adj = np.array(self.adj)
   327         1       2765.4   2765.4      1.0          distances = np.array(self.adj)
   328         1          0.7      0.7      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331       319         43.1      0.1      0.0          for i in range(n):
   332     50721       7533.4      0.1      2.7              for j in range(0, i):
   333     50403      17449.3      0.3      6.4                  if distances[i][j] > maxDist:
   334        60         12.1      0.2      0.0                      path[0], path[1] = i, j
   335        60         19.4      0.3      0.0                      maxDist = distances[i][j]
   336         1          0.6      0.6      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339       317         53.8      0.2      0.0          for i in set(range(n)) - in_path:
   340       316        285.1      0.9      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341       316        115.3      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         18.0     18.0      0.0          heapq.heapify(h)
   343                                           
   344       317         97.7      0.3      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346       316        198.3      0.6      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349       316         71.8      0.2      0.0              best_increase = np.inf
   350       316         46.1      0.1      0.0              best_pos = None
   351     50718       7789.1      0.2      2.8              for i in range(len(path)):
   352     50402      11707.0      0.2      4.3                  next_i = (i + 1) % len(path)
   353     50402      38971.2      0.8     14.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354     50402       9607.4      0.2      3.5                  if increase < best_increase:
   355      5313        750.5      0.1      0.3                      best_increase = increase
   356      5313        820.8      0.2      0.3                      best_pos = next_i
   357                                           
   358       316        112.8      0.4      0.0              path.insert(best_pos, to_ins)
   359       316         81.7      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362     50086      11355.1      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363     49770       9759.6      0.2      3.6                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365     49770      17776.5      0.4      6.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366        71         14.3      0.2      0.0                      best_cost = np.inf
   367        71         12.4      0.2      0.0                      posL, posR = -1, -1
   368      6461       1003.9      0.2      0.4                      for i2 in range(len(path)):
   369      6390       1505.7      0.2      0.5                          next_i = (i2 + 1) % len(path)
   370      6390       5942.9      0.9      2.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371      6390       1227.0      0.2      0.4                          if best_cost > insertion_cost:
   372       853        176.4      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   373        71         22.4      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376     49770      58921.3      1.2     21.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       111        121.3      1.1      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       111         42.4      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       111         26.7      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382     49770      60728.4      1.2     22.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383       583        663.3      1.1      0.2                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384       583        251.9      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385       316       3405.5     10.8      1.2              heapq.heapify(h)
   386                                           
   387         1          1.9      1.9      0.0          self.tour = path
   388         1        173.9    173.9      0.1          self.calculateCost()


Optimal 11861
_________________
fl417
randomInsertion 1.1263122808880637
nearestInsertion 1.2042708823114376
cheapestInsertion 1.2050816519728043
nearestNeighbor 1.2807590521365082
farthestInsertion 1.2411545355684825
furthestInsertion 1.0418845452886807

[('fl417', 1.1263122808880637, 1.2042708823114376, 1.2050816519728043, 1.2807590521365082, 1.2411545355684825, 1.0418845452886807)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.127877 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.7      0.7      0.0          n = self.numCity
   115         1       5222.6   5222.6      4.1          distances = np.array(self.adj)
   116         1          0.7      0.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          0.6      0.6      0.0          in_path = {0}
   118         1         38.8     38.8      0.0          notInPath = [x for x in range(1, n)]
   119         1        409.7    409.7      0.3          random.shuffle(notInPath)
   120                                           
   121       417        113.7      0.3      0.1          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       416         86.5      0.2      0.1              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       416         88.2      0.2      0.1              best_increase = np.inf
   127       416         56.5      0.1      0.0              best_position = None
   128     87152      14105.7      0.2     11.0              for i in range(len(path)):
   129     86736      20871.1      0.2     16.3                  next_i = (i + 1) % len(path)
   130     86736      66822.6      0.8     52.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     86736      17469.3      0.2     13.7                  if increase < best_increase:
   132      7031        965.4      0.1      0.8                      best_increase = increase
   133      7031       1137.3      0.2      0.9                      best_position = next_i
   134                                           
   135       416        139.3      0.3      0.1              path.insert(best_position, to_insert)
   136       416        122.1      0.3      0.1              in_path.add(to_insert)
   137                                           
   138         1          2.2      2.2      0.0          self.tour = path
   139         1        224.3    224.3      0.2          self.calculateCost()

Total time: 0.0431946 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          1.9      1.9      0.0          self.tour = [0]
   144         1          1.1      1.1      0.0          visited = set([0])
   145         1          8.2      8.2      0.0          notVisited = set(range(1, self.numCity))
   146       417        145.5      0.3      0.3          while len(self.tour) < self.numCity:
   147       416         79.9      0.2      0.2              cost = np.inf
   148       416         73.4      0.2      0.2              j = -1
   149     87152      14172.9      0.2     32.8              for j2 in notVisited:
   150     86736      27005.0      0.3     62.5                  if self.adj[self.tour[-1]][j2] < cost:
   151      2673        665.3      0.2      1.5                      cost = self.adj[self.tour[-1]][j2]
   152      2673        396.3      0.1      0.9                      j = j2
   153       416        115.5      0.3      0.3              self.tour.append(j)
   154       416         97.5      0.2      0.2              visited.add(j)
   155       416         96.6      0.2      0.2              notVisited.remove(j)
   156         1        335.5    335.5      0.8          self.calculateCost()

Total time: 0.239472 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.6      0.6      0.0          n = self.numCity
   162         1       5802.1   5802.1      2.4          distances = np.array(self.adj)
   163         1          0.7      0.7      0.0          path = [0, 0]
   164                                           
   165         1          0.8      0.8      0.0          minDist = np.inf
   166       418         60.9      0.1      0.0          for i in range(n):
   167     87153      13720.0      0.2      5.7              for j in range(0, i):
   168     86736      32321.7      0.4     13.5                  if distances[i][j] < minDist:
   169         5          1.6      0.3      0.0                      path[0], path[1] = i, j
   170         5          2.0      0.4      0.0                      minDist = distances[i][j]
   171         1          1.1      1.1      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.6      0.6      0.0          h = []
   176       416         93.2      0.2      0.0          for i in set(range(n)) - in_path:
   177       415       1057.0      2.5      0.4              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         28.4     28.4      0.0          heapq.heapify(h)
   179                                           
   180       416        135.2      0.3      0.1          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182       415        287.9      0.7      0.1              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185       415        101.4      0.2      0.0              best_increase = np.inf
   186       415         60.8      0.1      0.0              best_position = None
   187     87150      14049.7      0.2      5.9              for i in range(len(path)):
   188     86735      21098.2      0.2      8.8                  next_i = (i + 1) % len(path)
   189     86735      69822.6      0.8     29.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190     86735      17332.2      0.2      7.2                  if increase < best_increase:
   191      8337       1260.9      0.2      0.5                      best_increase = increase
   192      8337       1602.3      0.2      0.7                      best_position = i + 1
   193                                           
   194       415        158.0      0.4      0.1              path.insert(best_position, to_insert)
   195       415        113.7      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198     86320      18934.0      0.2      7.9              for i, (cost, node) in enumerate(h):
   199     85905      30506.9      0.4     12.7                  if node not in in_path and distances[to_insert, node] < cost:
   200     13854       4710.3      0.3      2.0                      h[i] = (distances[to_insert, node], node)
   201       415       5957.5     14.4      2.5              heapq.heapify(h)
   202                                           
   203         1          3.8      3.8      0.0          self.tour = path
   204         1        246.2    246.2      0.1          self.calculateCost()

Total time: 0.517806 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.4      0.4      0.0          n = self.numCity
   209         1       6653.0   6653.0      1.3          adj = np.array(self.adj)
   210         1       5512.3   5512.3      1.1          distances = np.array(self.adj)
   211         1          1.3      1.3      0.0          path = [0, 0]
   212                                           
   213         1          0.9      0.9      0.0          minDist = np.inf
   214       418         65.9      0.2      0.0          for i in range(n):
   215     87153      14282.4      0.2      2.8              for j in range(0, i):
   216     86736      33508.5      0.4      6.5                  if distances[i][j] < minDist:
   217         5          2.0      0.4      0.0                      path[0], path[1] = i, j
   218         5          2.0      0.4      0.0                      minDist = distances[i][j]
   219         1          2.6      2.6      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.7      0.7      0.0          h = []
   222       416        115.6      0.3      0.0          for i in set(range(n)) - in_path:
   223       415        575.4      1.4      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224       415        214.3      0.5      0.0              h.append((cost, i, path[0], path[1]))
   225         1         30.3     30.3      0.0          heapq.heapify(h)
   226                                           
   227       416        160.3      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229       415        303.8      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232       415        102.4      0.2      0.0              best_increase = np.inf
   233       415         65.9      0.2      0.0              best_pos = None
   234     87150      14299.5      0.2      2.8              for i in range(len(path)):
   235     86735      21523.7      0.2      4.2                  next_i = (i + 1) % len(path)
   236     86735      67857.4      0.8     13.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237     86735      17369.8      0.2      3.4                  if increase < best_increase:
   238      8072       1207.2      0.1      0.2                      best_increase = increase
   239      8072       1312.7      0.2      0.3                      best_pos = next_i
   240                                           
   241       415        159.4      0.4      0.0              path.insert(best_pos, to_ins)
   242       415        114.1      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247     86320      20723.3      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249     85905      31876.9      0.4      6.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       323         65.8      0.2      0.0                      best_cost = np.inf
   251       323         53.9      0.2      0.0                      posL, posR = -1, -1
   252      9464       1608.4      0.2      0.3                      for i2 in range(len(path)):
   253      9141       2229.8      0.2      0.4                          next_i = (i2 + 1) % len(path)
   254      9141       8950.4      1.0      1.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255      9141       1806.6      0.2      0.3                          if best_cost > insertion_cost:
   256      2048        450.6      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       323         80.8      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260     85905     108709.4      1.3     21.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261      8920      10483.7      1.2      2.0                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262      8920       3445.2      0.4      0.7                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265      8920       2216.7      0.2      0.4                      best_pos = (best_pos + 1) % (len(path))
   266     85905     114741.0      1.3     22.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     11254      13480.5      1.2      2.6                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     11254       5123.8      0.5      1.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269       415       6086.1     14.7      1.2              heapq.heapify(h)
   270                                           
   271         1          3.5      3.5      0.0          self.tour = path
   272         1        225.8    225.8      0.0          self.calculateCost()

Total time: 0.254522 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1       5434.2   5434.2      2.1          distances = np.array(self.adj)
   278         1          0.7      0.7      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281       418         77.6      0.2      0.0          for i in range(n):
   282     87153      13865.5      0.2      5.4              for j in range(0, i):
   283     86736      33374.7      0.4     13.1                  if distances[i][j] > maxDist:
   284        72         17.8      0.2      0.0                      path[0], path[1] = i, j
   285        72         26.3      0.4      0.0                      maxDist = distances[i][j]
   286         1          2.0      2.0      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          1.2      1.2      0.0          h = []
   291       416         99.7      0.2      0.0          for i in set(range(n)) - in_path:
   292       415        334.9      0.8      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         25.3     25.3      0.0          heapq.heapify(h)
   294                                           
   295       416        146.3      0.4      0.1          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297       415        272.5      0.7      0.1              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300       415         98.1      0.2      0.0              best_increase = np.inf
   301       415         61.0      0.1      0.0              best_position = None
   302     87150      13879.2      0.2      5.5              for i in range(len(path)):
   303     86735      21218.8      0.2      8.3                  next_i = (i + 1) % len(path)
   304     86735      68767.6      0.8     27.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305     86735      16860.6      0.2      6.6                  if increase < best_increase:
   306      6228        845.8      0.1      0.3                      best_increase = increase
   307      6228       1176.4      0.2      0.5                      best_position = i + 1
   308                                           
   309       415        166.7      0.4      0.1              path.insert(best_position, to_insert)
   310       415        117.1      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313     86320      18491.3      0.2      7.3              for i, (cost, node) in enumerate(h):
   314     85905      19705.3      0.2      7.7                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316     85905      32974.2      0.4     13.0                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318       415       6251.0     15.1      2.5              heapq.heapify(h)
   319                                           
   320         1          3.6      3.6      0.0          self.tour = path
   321         1        226.0    226.0      0.1          self.calculateCost()

Total time: 0.498409 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.4      0.4      0.0          n = self.numCity
   326         1       5397.7   5397.7      1.1          adj = np.array(self.adj)
   327         1       4806.4   4806.4      1.0          distances = np.array(self.adj)
   328         1          0.5      0.5      0.0          path = [0, 0]
   329                                           
   330         1          0.4      0.4      0.0          maxDist = 0
   331       418         59.1      0.1      0.0          for i in range(n):
   332     87153      13529.7      0.2      2.7              for j in range(0, i):
   333     86736      31963.4      0.4      6.4                  if distances[i][j] > maxDist:
   334        72         17.9      0.2      0.0                      path[0], path[1] = i, j
   335        72         25.7      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.0      1.0      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339       416         73.8      0.2      0.0          for i in set(range(n)) - in_path:
   340       415        393.7      0.9      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341       415        150.8      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         24.5     24.5      0.0          heapq.heapify(h)
   343                                           
   344       416        146.4      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346       415        306.9      0.7      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349       415        113.2      0.3      0.0              best_increase = np.inf
   350       415         56.8      0.1      0.0              best_pos = None
   351     87150      13495.2      0.2      2.7              for i in range(len(path)):
   352     86735      20805.4      0.2      4.2                  next_i = (i + 1) % len(path)
   353     86735      70723.3      0.8     14.2                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354     86735      16911.1      0.2      3.4                  if increase < best_increase:
   355     11393       1672.3      0.1      0.3                      best_increase = increase
   356     11393       1768.9      0.2      0.4                      best_pos = next_i
   357                                           
   358       415        187.9      0.5      0.0              path.insert(best_pos, to_ins)
   359       415        115.3      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362     86320      19979.9      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363     85905      18663.4      0.2      3.7                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365     85905      30771.4      0.4      6.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       187         41.1      0.2      0.0                      best_cost = np.inf
   367       187         31.4      0.2      0.0                      posL, posR = -1, -1
   368     12017       1929.7      0.2      0.4                      for i2 in range(len(path)):
   369     11830       2941.3      0.2      0.6                          next_i = (i2 + 1) % len(path)
   370     11830      11399.8      1.0      2.3                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     11830       2268.9      0.2      0.5                          if best_cost > insertion_cost:
   372      1955        428.3      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       187         61.3      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376     85905     106471.8      1.2     21.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       405        475.0      1.2      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       405        157.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       405        102.2      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382     85905     112239.2      1.3     22.5                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383       873       1039.7      1.2      0.2                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384       873        391.6      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385       415       6021.3     14.5      1.2              heapq.heapify(h)
   386                                           
   387         1          4.2      4.2      0.0          self.tour = path
   388         1        241.9    241.9      0.0          self.calculateCost()


Optimal 50778
_________________
pcb442
randomInsertion 1.1630337596922482
nearestInsertion 1.1982723362653798
cheapestInsertion 1.2235170902404655
nearestNeighbor 1.2206870545691801
farthestInsertion 1.2059058608362656
furthestInsertion 1.1844957749777212

[('pcb442', 1.1630337596922482, 1.1982723362653798, 1.2235170902404655, 1.2206870545691801, 1.2059058608362656, 1.1844957749777212)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.17695 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.9      0.9      0.0          n = self.numCity
   115         1       7014.4   7014.4      4.0          distances = np.array(self.adj)
   116         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.3      1.3      0.0          in_path = {0}
   118         1         39.9     39.9      0.0          notInPath = [x for x in range(1, n)]
   119         1        438.9    438.9      0.2          random.shuffle(notInPath)
   120                                           
   121       442        181.5      0.4      0.1          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       441        138.2      0.3      0.1              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       441        162.0      0.4      0.1              best_increase = np.inf
   127       441         67.4      0.2      0.0              best_position = None
   128     97902      18271.5      0.2     10.3              for i in range(len(path)):
   129     97461      28992.0      0.3     16.4                  next_i = (i + 1) % len(path)
   130     97461      95520.2      1.0     54.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131     97461      22298.9      0.2     12.6                  if increase < best_increase:
   132      9352       1413.3      0.2      0.8                      best_increase = increase
   133      9352       1671.2      0.2      0.9                      best_position = next_i
   134                                           
   135       441        267.4      0.6      0.2              path.insert(best_position, to_insert)
   136       441        206.4      0.5      0.1              in_path.add(to_insert)
   137                                           
   138         1          3.1      3.1      0.0          self.tour = path
   139         1        260.8    260.8      0.1          self.calculateCost()

Total time: 0.0542014 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          3.0      3.0      0.0          self.tour = [0]
   144         1          2.0      2.0      0.0          visited = set([0])
   145         1          8.4      8.4      0.0          notVisited = set(range(1, self.numCity))
   146       442        232.2      0.5      0.4          while len(self.tour) < self.numCity:
   147       441        141.6      0.3      0.3              cost = np.inf
   148       441         61.9      0.1      0.1              j = -1
   149     97902      17057.6      0.2     31.5              for j2 in notVisited:
   150     97461      33159.6      0.3     61.2                  if self.adj[self.tour[-1]][j2] < cost:
   151      6469       1692.4      0.3      3.1                      cost = self.adj[self.tour[-1]][j2]
   152      6469        975.8      0.2      1.8                      j = j2
   153       441        202.0      0.5      0.4              self.tour.append(j)
   154       441        160.3      0.4      0.3              visited.add(j)
   155       441        133.5      0.3      0.2              notVisited.remove(j)
   156         1        371.1    371.1      0.7          self.calculateCost()

Total time: 0.276596 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          1.1      1.1      0.0          n = self.numCity
   162         1       6813.4   6813.4      2.5          distances = np.array(self.adj)
   163         1          1.3      1.3      0.0          path = [0, 0]
   164                                           
   165         1          1.6      1.6      0.0          minDist = np.inf
   166       443         65.2      0.1      0.0          for i in range(n):
   167     97903      15594.2      0.2      5.6              for j in range(0, i):
   168     97461      41022.2      0.4     14.8                  if distances[i][j] < minDist:
   169         4          3.6      0.9      0.0                      path[0], path[1] = i, j
   170         4          1.8      0.5      0.0                      minDist = distances[i][j]
   171         1          2.6      2.6      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.9      0.9      0.0          h = []
   176       441        106.5      0.2      0.0          for i in set(range(n)) - in_path:
   177       440       1407.5      3.2      0.5              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         30.6     30.6      0.0          heapq.heapify(h)
   179                                           
   180       441        191.3      0.4      0.1          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182       440        309.9      0.7      0.1              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185       440        111.1      0.3      0.0              best_increase = np.inf
   186       440         67.4      0.2      0.0              best_position = None
   187     97900      15487.5      0.2      5.6              for i in range(len(path)):
   188     97460      24282.0      0.2      8.8                  next_i = (i + 1) % len(path)
   189     97460      78880.0      0.8     28.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190     97460      18751.4      0.2      6.8                  if increase < best_increase:
   191     14093       2018.4      0.1      0.7                      best_increase = increase
   192     14093       2721.6      0.2      1.0                      best_position = i + 1
   193                                           
   194       440        198.3      0.5      0.1              path.insert(best_position, to_insert)
   195       440        142.5      0.3      0.1              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198     97020      20832.2      0.2      7.5              for i, (cost, node) in enumerate(h):
   199     96580      34400.2      0.4     12.4                  if node not in in_path and distances[to_insert, node] < cost:
   200     17203       5832.9      0.3      2.1                      h[i] = (distances[to_insert, node], node)
   201       440       7060.0     16.0      2.6              heapq.heapify(h)
   202                                           
   203         1          4.3      4.3      0.0          self.tour = path
   204         1        252.2    252.2      0.1          self.calculateCost()

Total time: 0.622226 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.4      0.4      0.0          n = self.numCity
   209         1       6711.3   6711.3      1.1          adj = np.array(self.adj)
   210         1       5829.2   5829.2      0.9          distances = np.array(self.adj)
   211         1          0.8      0.8      0.0          path = [0, 0]
   212                                           
   213         1          1.2      1.2      0.0          minDist = np.inf
   214       443         69.0      0.2      0.0          for i in range(n):
   215     97903      15540.8      0.2      2.5              for j in range(0, i):
   216     97461      40426.0      0.4      6.5                  if distances[i][j] < minDist:
   217         4          3.2      0.8      0.0                      path[0], path[1] = i, j
   218         4          1.7      0.4      0.0                      minDist = distances[i][j]
   219         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222       441        106.7      0.2      0.0          for i in set(range(n)) - in_path:
   223       440        496.3      1.1      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224       440        179.0      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         30.4     30.4      0.0          heapq.heapify(h)
   226                                           
   227       441        192.9      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229       440        362.8      0.8      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232       440        146.4      0.3      0.0              best_increase = np.inf
   233       440         66.3      0.2      0.0              best_pos = None
   234     97900      15921.2      0.2      2.6              for i in range(len(path)):
   235     97460      24647.3      0.3      4.0                  next_i = (i + 1) % len(path)
   236     97460      81759.6      0.8     13.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237     97460      18884.5      0.2      3.0                  if increase < best_increase:
   238     13497       2002.2      0.1      0.3                      best_increase = increase
   239     13497       2097.5      0.2      0.3                      best_pos = next_i
   240                                           
   241       440        269.8      0.6      0.0              path.insert(best_pos, to_ins)
   242       440        138.8      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247     97020      24253.0      0.2      3.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249     96580      37636.8      0.4      6.0                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       125         51.4      0.4      0.0                      best_cost = np.inf
   251       125         25.1      0.2      0.0                      posL, posR = -1, -1
   252      8766       1416.8      0.2      0.2                      for i2 in range(len(path)):
   253      8641       2163.1      0.3      0.3                          next_i = (i2 + 1) % len(path)
   254      8641       9121.7      1.1      1.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255      8641       1740.0      0.2      0.3                          if best_cost > insertion_cost:
   256      1794        423.7      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       125         35.6      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260     96580     132602.0      1.4     21.3                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     13950      17304.5      1.2      2.8                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     13950       5523.1      0.4      0.9                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     13950       3495.2      0.3      0.6                      best_pos = (best_pos + 1) % (len(path))
   266     96580     136869.6      1.4     22.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     15059      19099.5      1.3      3.1                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     15059       6874.3      0.5      1.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269       440       7437.3     16.9      1.2              heapq.heapify(h)
   270                                           
   271         1          4.5      4.5      0.0          self.tour = path
   272         1        261.5    261.5      0.0          self.calculateCost()

Total time: 0.303211 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          1.1      1.1      0.0          n = self.numCity
   277         1       7231.1   7231.1      2.4          distances = np.array(self.adj)
   278         1          1.8      1.8      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281       443         68.2      0.2      0.0          for i in range(n):
   282     97903      15788.5      0.2      5.2              for j in range(0, i):
   283     97461      40906.7      0.4     13.5                  if distances[i][j] > maxDist:
   284        67         22.8      0.3      0.0                      path[0], path[1] = i, j
   285        67         26.7      0.4      0.0                      maxDist = distances[i][j]
   286         1          2.6      2.6      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.8      0.8      0.0          h = []
   291       441         97.3      0.2      0.0          for i in set(range(n)) - in_path:
   292       440        344.6      0.8      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         30.0     30.0      0.0          heapq.heapify(h)
   294                                           
   295       441        186.5      0.4      0.1          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297       440        311.5      0.7      0.1              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300       440        130.5      0.3      0.0              best_increase = np.inf
   301       440         72.9      0.2      0.0              best_position = None
   302     97900      16004.7      0.2      5.3              for i in range(len(path)):
   303     97460      25012.4      0.3      8.2                  next_i = (i + 1) % len(path)
   304     97460      85606.7      0.9     28.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305     97460      19349.9      0.2      6.4                  if increase < best_increase:
   306      9499       1277.1      0.1      0.4                      best_increase = increase
   307      9499       1893.4      0.2      0.6                      best_position = i + 1
   308                                           
   309       440        238.8      0.5      0.1              path.insert(best_position, to_insert)
   310       440        144.0      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313     97020      20905.8      0.2      6.9              for i, (cost, node) in enumerate(h):
   314     96580      21236.8      0.2      7.0                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316     96580      39038.5      0.4     12.9                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318       440       7018.2     16.0      2.3              heapq.heapify(h)
   319                                           
   320         1          4.8      4.8      0.0          self.tour = path
   321         1        255.6    255.6      0.1          self.calculateCost()

Total time: 0.657175 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          1.0      1.0      0.0          n = self.numCity
   326         1       7182.0   7182.0      1.1          adj = np.array(self.adj)
   327         1       7400.9   7400.9      1.1          distances = np.array(self.adj)
   328         1          1.3      1.3      0.0          path = [0, 0]
   329                                           
   330         1          0.4      0.4      0.0          maxDist = 0
   331       443         72.0      0.2      0.0          for i in range(n):
   332     97903      16410.2      0.2      2.5              for j in range(0, i):
   333     97461      41683.8      0.4      6.3                  if distances[i][j] > maxDist:
   334        67         22.9      0.3      0.0                      path[0], path[1] = i, j
   335        67         28.9      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          1.1      1.1      0.0          h = []
   339       441         96.4      0.2      0.0          for i in set(range(n)) - in_path:
   340       440        510.6      1.2      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341       440        184.4      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         33.7     33.7      0.0          heapq.heapify(h)
   343                                           
   344       441        240.6      0.5      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346       440        525.1      1.2      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349       440        243.1      0.6      0.0              best_increase = np.inf
   350       440         97.5      0.2      0.0              best_pos = None
   351     97900      17038.9      0.2      2.6              for i in range(len(path)):
   352     97460      25724.1      0.3      3.9                  next_i = (i + 1) % len(path)
   353     97460      89388.0      0.9     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354     97460      20366.9      0.2      3.1                  if increase < best_increase:
   355     10685       1621.5      0.2      0.2                      best_increase = increase
   356     10685       1797.2      0.2      0.3                      best_pos = next_i
   357                                           
   358       440        446.2      1.0      0.1              path.insert(best_pos, to_ins)
   359       440        248.0      0.6      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362     97020      29921.1      0.3      4.6              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363     96580      22710.5      0.2      3.5                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365     96580      40574.6      0.4      6.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       133         74.4      0.6      0.0                      best_cost = np.inf
   367       133         31.2      0.2      0.0                      posL, posR = -1, -1
   368     14330       2638.0      0.2      0.4                      for i2 in range(len(path)):
   369     14197       3897.2      0.3      0.6                          next_i = (i2 + 1) % len(path)
   370     14197      17518.3      1.2      2.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     14197       3196.1      0.2      0.5                          if best_cost > insertion_cost:
   372      2307        601.5      0.3      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       133         95.6      0.7      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376     96580     143865.0      1.5     21.9                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       172        256.1      1.5      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       172         87.6      0.5      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       172         49.3      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382     96580     149529.5      1.5     22.8                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383       809       1311.7      1.6      0.2                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384       809        483.3      0.6      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385       440       8706.9     19.8      1.3              heapq.heapify(h)
   386                                           
   387         1          4.3      4.3      0.0          self.tour = path
   388         1        255.3    255.3      0.0          self.calculateCost()


Optimal 36905
_________________
u574
randomInsertion 1.1180024644633089
nearestInsertion 1.2306364485504377
cheapestInsertion 1.2239056898049405
nearestNeighbor 1.3837703550046516
farthestInsertion 1.2155519904386647
furthestInsertion 1.1286280954647265

[('u574', 1.1180024644633089, 1.2306364485504377, 1.2239056898049405, 1.3837703550046516, 1.2155519904386647, 1.1286280954647265)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.268693 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.8      0.8      0.0          n = self.numCity
   115         1      13623.9  13623.9      5.1          distances = np.array(self.adj)
   116         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1         61.4     61.4      0.0          notInPath = [x for x in range(1, n)]
   119         1        633.5    633.5      0.2          random.shuffle(notInPath)
   120                                           
   121       574        205.0      0.4      0.1          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       573        157.1      0.3      0.1              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       573        164.9      0.3      0.1              best_increase = np.inf
   127       573         82.8      0.1      0.0              best_position = None
   128    165024      27714.5      0.2     10.3              for i in range(len(path)):
   129    164451      43352.8      0.3     16.1                  next_i = (i + 1) % len(path)
   130    164451     143072.7      0.9     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    164451      33901.4      0.2     12.6                  if increase < best_increase:
   132     15312       2250.1      0.1      0.8                      best_increase = increase
   133     15312       2580.4      0.2      1.0                      best_position = next_i
   134                                           
   135       573        315.3      0.6      0.1              path.insert(best_position, to_insert)
   136       573        235.3      0.4      0.1              in_path.add(to_insert)
   137                                           
   138         1          3.2      3.2      0.0          self.tour = path
   139         1        334.8    334.8      0.1          self.calculateCost()

Total time: 0.0835605 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          2.5      2.5      0.0          self.tour = [0]
   144         1          1.3      1.3      0.0          visited = set([0])
   145         1          9.4      9.4      0.0          notVisited = set(range(1, self.numCity))
   146       574        226.4      0.4      0.3          while len(self.tour) < self.numCity:
   147       573        115.5      0.2      0.1              cost = np.inf
   148       573         80.1      0.1      0.1              j = -1
   149    165024      26271.6      0.2     31.4              for j2 in notVisited:
   150    164451      52186.7      0.3     62.5                  if self.adj[self.tour[-1]][j2] < cost:
   151      9871       2395.8      0.2      2.9                      cost = self.adj[self.tour[-1]][j2]
   152      9871       1518.0      0.2      1.8                      j = j2
   153       573        173.0      0.3      0.2              self.tour.append(j)
   154       573        140.3      0.2      0.2              visited.add(j)
   155       573        137.8      0.2      0.2              notVisited.remove(j)
   156         1        302.0    302.0      0.4          self.calculateCost()

Total time: 0.474755 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          1.0      1.0      0.0          n = self.numCity
   162         1      12865.2  12865.2      2.7          distances = np.array(self.adj)
   163         1          1.4      1.4      0.0          path = [0, 0]
   164                                           
   165         1          1.5      1.5      0.0          minDist = np.inf
   166       575         96.5      0.2      0.0          for i in range(n):
   167    165025      28266.4      0.2      6.0              for j in range(0, i):
   168    164451      69800.6      0.4     14.7                  if distances[i][j] < minDist:
   169         5          4.2      0.8      0.0                      path[0], path[1] = i, j
   170         5          2.2      0.4      0.0                      minDist = distances[i][j]
   171         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          1.5      1.5      0.0          h = []
   176       573        137.1      0.2      0.0          for i in set(range(n)) - in_path:
   177       572       2775.8      4.9      0.6              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         34.7     34.7      0.0          heapq.heapify(h)
   179                                           
   180       573        216.7      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182       572        404.2      0.7      0.1              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185       572        153.9      0.3      0.0              best_increase = np.inf
   186       572        101.1      0.2      0.0              best_position = None
   187    165022      28064.5      0.2      5.9              for i in range(len(path)):
   188    164450      43460.5      0.3      9.2                  next_i = (i + 1) % len(path)
   189    164450     134158.8      0.8     28.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    164450      33472.6      0.2      7.1                  if increase < best_increase:
   191     17153       2357.2      0.1      0.5                      best_increase = increase
   192     17153       3465.6      0.2      0.7                      best_position = i + 1
   193                                           
   194       572        245.8      0.4      0.1              path.insert(best_position, to_insert)
   195       572        166.0      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    163878      35716.7      0.2      7.5              for i, (cost, node) in enumerate(h):
   199    163306      59438.0      0.4     12.5                  if node not in in_path and distances[to_insert, node] < cost:
   200     21042       7519.5      0.4      1.6                      h[i] = (distances[to_insert, node], node)
   201       572      11493.6     20.1      2.4              heapq.heapify(h)
   202                                           
   203         1          5.4      5.4      0.0          self.tour = path
   204         1        325.3    325.3      0.1          self.calculateCost()

Total time: 1.00059 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1      10550.1  10550.1      1.1          adj = np.array(self.adj)
   210         1       9776.8   9776.8      1.0          distances = np.array(self.adj)
   211         1          1.0      1.0      0.0          path = [0, 0]
   212                                           
   213         1          0.9      0.9      0.0          minDist = np.inf
   214       575         87.1      0.2      0.0          for i in range(n):
   215    165025      25943.2      0.2      2.6              for j in range(0, i):
   216    164451      66862.1      0.4      6.7                  if distances[i][j] < minDist:
   217         5          4.0      0.8      0.0                      path[0], path[1] = i, j
   218         5          2.1      0.4      0.0                      minDist = distances[i][j]
   219         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.7      0.7      0.0          h = []
   222       573        134.8      0.2      0.0          for i in set(range(n)) - in_path:
   223       572        606.2      1.1      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224       572        234.0      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         32.9     32.9      0.0          heapq.heapify(h)
   226                                           
   227       573        254.4      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229       572        412.4      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232       572        167.5      0.3      0.0              best_increase = np.inf
   233       572         95.4      0.2      0.0              best_pos = None
   234    165022      26332.7      0.2      2.6              for i in range(len(path)):
   235    164450      42000.0      0.3      4.2                  next_i = (i + 1) % len(path)
   236    164450     135074.2      0.8     13.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    164450      32361.7      0.2      3.2                  if increase < best_increase:
   238     17439       2490.5      0.1      0.2                      best_increase = increase
   239     17439       2724.4      0.2      0.3                      best_pos = next_i
   240                                           
   241       572        261.2      0.5      0.0              path.insert(best_pos, to_ins)
   242       572        157.4      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    163878      38832.4      0.2      3.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    163306      63920.7      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       519        122.5      0.2      0.0                      best_cost = np.inf
   251       519         83.9      0.2      0.0                      posL, posR = -1, -1
   252     15443       2609.3      0.2      0.3                      for i2 in range(len(path)):
   253     14924       3849.8      0.3      0.4                          next_i = (i2 + 1) % len(path)
   254     14924      15366.1      1.0      1.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255     14924       2988.1      0.2      0.3                          if best_cost > insertion_cost:
   256      2720        604.4      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       519        126.3      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    163306     217554.6      1.3     21.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     15643      19013.9      1.2      1.9                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     15643       5951.3      0.4      0.6                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     15643       3940.8      0.3      0.4                      best_pos = (best_pos + 1) % (len(path))
   266    163306     226771.5      1.4     22.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     17947      22208.4      1.2      2.2                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     17947       8111.1      0.5      0.8                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269       572      11630.3     20.3      1.2              heapq.heapify(h)
   270                                           
   271         1          4.0      4.0      0.0          self.tour = path
   272         1        328.1    328.1      0.0          self.calculateCost()

Total time: 0.485449 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1      10589.6  10589.6      2.2          distances = np.array(self.adj)
   278         1          1.3      1.3      0.0          path = [0, 0]
   279                                           
   280         1          0.6      0.6      0.0          maxDist = 0
   281       575         89.7      0.2      0.0          for i in range(n):
   282    165025      25877.0      0.2      5.3              for j in range(0, i):
   283    164451      67343.0      0.4     13.9                  if distances[i][j] > maxDist:
   284        82         19.9      0.2      0.0                      path[0], path[1] = i, j
   285        82         31.2      0.4      0.0                      maxDist = distances[i][j]
   286         1          2.5      2.5      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.6      0.6      0.0          h = []
   291       573        106.2      0.2      0.0          for i in set(range(n)) - in_path:
   292       572        392.2      0.7      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         35.5     35.5      0.0          heapq.heapify(h)
   294                                           
   295       573        236.8      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297       572        378.0      0.7      0.1              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300       572        138.0      0.2      0.0              best_increase = np.inf
   301       572         87.5      0.2      0.0              best_position = None
   302    165022      26743.0      0.2      5.5              for i in range(len(path)):
   303    164450      42335.4      0.3      8.7                  next_i = (i + 1) % len(path)
   304    164450     131654.3      0.8     27.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    164450      32049.3      0.2      6.6                  if increase < best_increase:
   306     13859       1892.9      0.1      0.4                      best_increase = increase
   307     13859       2691.6      0.2      0.6                      best_position = i + 1
   308                                           
   309       572        256.2      0.4      0.1              path.insert(best_position, to_insert)
   310       572        171.9      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    163878      33609.4      0.2      6.9              for i, (cost, node) in enumerate(h):
   314    163306      33219.4      0.2      6.8                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    163306      63782.4      0.4     13.1                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318       572      11382.6     19.9      2.3              heapq.heapify(h)
   319                                           
   320         1          4.7      4.7      0.0          self.tour = path
   321         1        325.6    325.6      0.1          self.calculateCost()

Total time: 1.02105 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.5      0.5      0.0          n = self.numCity
   326         1      10693.7  10693.7      1.0          adj = np.array(self.adj)
   327         1      10604.7  10604.7      1.0          distances = np.array(self.adj)
   328         1          0.9      0.9      0.0          path = [0, 0]
   329                                           
   330         1          0.3      0.3      0.0          maxDist = 0
   331       575        111.7      0.2      0.0          for i in range(n):
   332    165025      26819.2      0.2      2.6              for j in range(0, i):
   333    164451      66694.8      0.4      6.5                  if distances[i][j] > maxDist:
   334        82         21.5      0.3      0.0                      path[0], path[1] = i, j
   335        82         33.5      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339       573        103.3      0.2      0.0          for i in set(range(n)) - in_path:
   340       572        577.1      1.0      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341       572        218.6      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         35.9     35.9      0.0          heapq.heapify(h)
   343                                           
   344       573        262.3      0.5      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346       572        481.2      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349       572        187.9      0.3      0.0              best_increase = np.inf
   350       572         88.9      0.2      0.0              best_pos = None
   351    165022      26754.8      0.2      2.6              for i in range(len(path)):
   352    164450      42686.2      0.3      4.2                  next_i = (i + 1) % len(path)
   353    164450     142241.9      0.9     13.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    164450      32626.2      0.2      3.2                  if increase < best_increase:
   355     12793       1838.0      0.1      0.2                      best_increase = increase
   356     12793       2053.2      0.2      0.2                      best_pos = next_i
   357                                           
   358       572        339.1      0.6      0.0              path.insert(best_pos, to_ins)
   359       572        182.9      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    163878      42474.5      0.3      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    163306      36084.6      0.2      3.5                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    163306      64398.4      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       226         49.4      0.2      0.0                      best_cost = np.inf
   367       226         49.6      0.2      0.0                      posL, posR = -1, -1
   368     16507       2719.8      0.2      0.3                      for i2 in range(len(path)):
   369     16281       4187.0      0.3      0.4                          next_i = (i2 + 1) % len(path)
   370     16281      17284.1      1.1      1.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     16281       3351.4      0.2      0.3                          if best_cost > insertion_cost:
   372      1818        421.4      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       226         82.8      0.4      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    163306     235036.2      1.4     23.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       144        197.9      1.4      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       144         70.8      0.5      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       144         39.4      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    163306     234330.3      1.4     22.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      1222       1518.1      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      1222        591.9      0.5      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385       572      12173.1     21.3      1.2              heapq.heapify(h)
   386                                           
   387         1          5.2      5.2      0.0          self.tour = path
   388         1        327.9    327.9      0.0          self.calculateCost()


Optimal 34643
_________________
p654
randomInsertion 1.0602434352191614
nearestInsertion 1.2027985368736647
cheapestInsertion 1.22613861424451
nearestNeighbor 1.2530816604201624
farthestInsertion 1.1449089200307645
furthestInsertion 1.0671565835268573

[('p654', 1.0602434352191614, 1.2027985368736647, 1.22613861424451, 1.2530816604201624, 1.1449089200307645, 1.0671565835268573)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.33395 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.2      1.2      0.0          n = self.numCity
   115         1      15273.5  15273.5      4.6          distances = np.array(self.adj)
   116         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.3      1.3      0.0          in_path = {0}
   118         1         60.6     60.6      0.0          notInPath = [x for x in range(1, n)]
   119         1        683.8    683.8      0.2          random.shuffle(notInPath)
   120                                           
   121       654        195.4      0.3      0.1          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       653        161.1      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       653        160.1      0.2      0.0              best_increase = np.inf
   127       653         92.7      0.1      0.0              best_position = None
   128    214184      36123.3      0.2     10.8              for i in range(len(path)):
   129    213531      54810.6      0.3     16.4                  next_i = (i + 1) % len(path)
   130    213531     173296.7      0.8     51.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    213531      41693.9      0.2     12.5                  if increase < best_increase:
   132     34847       4884.5      0.1      1.5                      best_increase = increase
   133     34847       5615.5      0.2      1.7                      best_position = next_i
   134                                           
   135       653        267.4      0.4      0.1              path.insert(best_position, to_insert)
   136       653        212.8      0.3      0.1              in_path.add(to_insert)
   137                                           
   138         1          4.2      4.2      0.0          self.tour = path
   139         1        410.2    410.2      0.1          self.calculateCost()

Total time: 0.112305 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          3.1      3.1      0.0          self.tour = [0]
   144         1          1.3      1.3      0.0          visited = set([0])
   145         1         10.2     10.2      0.0          notVisited = set(range(1, self.numCity))
   146       654        251.7      0.4      0.2          while len(self.tour) < self.numCity:
   147       653        129.5      0.2      0.1              cost = np.inf
   148       653         92.7      0.1      0.1              j = -1
   149    214184      34071.9      0.2     30.3              for j2 in notVisited:
   150    213531      70459.7      0.3     62.7                  if self.adj[self.tour[-1]][j2] < cost:
   151     15500       3964.2      0.3      3.5                      cost = self.adj[self.tour[-1]][j2]
   152     15500       2456.7      0.2      2.2                      j = j2
   153       653        200.8      0.3      0.2              self.tour.append(j)
   154       653        161.3      0.2      0.1              visited.add(j)
   155       653        156.6      0.2      0.1              notVisited.remove(j)
   156         1        344.8    344.8      0.3          self.calculateCost()

Total time: 0.592925 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          1.2      1.2      0.0          n = self.numCity
   162         1      15377.1  15377.1      2.6          distances = np.array(self.adj)
   163         1          1.1      1.1      0.0          path = [0, 0]
   164                                           
   165         1          1.3      1.3      0.0          minDist = np.inf
   166       655         99.6      0.2      0.0          for i in range(n):
   167    214185      35562.8      0.2      6.0              for j in range(0, i):
   168    213531      80157.0      0.4     13.5                  if distances[i][j] < minDist:
   169         3          1.2      0.4      0.0                      path[0], path[1] = i, j
   170         3          1.2      0.4      0.0                      minDist = distances[i][j]
   171         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.8      0.8      0.0          h = []
   176       653        188.9      0.3      0.0          for i in set(range(n)) - in_path:
   177       652       1144.1      1.8      0.2              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         41.9     41.9      0.0          heapq.heapify(h)
   179                                           
   180       653        232.6      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182       652        457.0      0.7      0.1              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185       652        173.4      0.3      0.0              best_increase = np.inf
   186       652        102.3      0.2      0.0              best_position = None
   187    214182      34844.5      0.2      5.9              for i in range(len(path)):
   188    213530      52640.9      0.2      8.9                  next_i = (i + 1) % len(path)
   189    213530     166759.4      0.8     28.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    213530      41123.3      0.2      6.9                  if increase < best_increase:
   191     29727       3962.7      0.1      0.7                      best_increase = increase
   192     29727       5605.6      0.2      0.9                      best_position = i + 1
   193                                           
   194       652        286.4      0.4      0.0              path.insert(best_position, to_insert)
   195       652        187.7      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    212878      46745.7      0.2      7.9              for i, (cost, node) in enumerate(h):
   199    212226      76366.0      0.4     12.9                  if node not in in_path and distances[to_insert, node] < cost:
   200     47619      15864.4      0.3      2.7                      h[i] = (distances[to_insert, node], node)
   201       652      14617.2     22.4      2.5              heapq.heapify(h)
   202                                           
   203         1          5.4      5.4      0.0          self.tour = path
   204         1        371.0    371.0      0.1          self.calculateCost()

Total time: 1.30624 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1      14043.7  14043.7      1.1          adj = np.array(self.adj)
   210         1      13926.6  13926.6      1.1          distances = np.array(self.adj)
   211         1          1.5      1.5      0.0          path = [0, 0]
   212                                           
   213         1          1.2      1.2      0.0          minDist = np.inf
   214       655         94.2      0.1      0.0          for i in range(n):
   215    214185      33043.4      0.2      2.5              for j in range(0, i):
   216    213531      78140.4      0.4      6.0                  if distances[i][j] < minDist:
   217         3          1.7      0.6      0.0                      path[0], path[1] = i, j
   218         3          1.2      0.4      0.0                      minDist = distances[i][j]
   219         1          1.9      1.9      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.7      0.7      0.0          h = []
   222       653        146.1      0.2      0.0          for i in set(range(n)) - in_path:
   223       652        650.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224       652        241.2      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         40.8     40.8      0.0          heapq.heapify(h)
   226                                           
   227       653        263.6      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229       652        477.4      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232       652        183.1      0.3      0.0              best_increase = np.inf
   233       652        109.4      0.2      0.0              best_pos = None
   234    214182      33450.7      0.2      2.6              for i in range(len(path)):
   235    213530      52800.9      0.2      4.0                  next_i = (i + 1) % len(path)
   236    213530     170658.2      0.8     13.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    213530      41464.1      0.2      3.2                  if increase < best_increase:
   238     22517       3139.8      0.1      0.2                      best_increase = increase
   239     22517       3463.2      0.2      0.3                      best_pos = next_i
   240                                           
   241       652        333.3      0.5      0.0              path.insert(best_pos, to_ins)
   242       652        190.2      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    212878      51728.8      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    212226      80001.2      0.4      6.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       330         69.7      0.2      0.0                      best_cost = np.inf
   251       330         55.8      0.2      0.0                      posL, posR = -1, -1
   252     30725       4947.2      0.2      0.4                      for i2 in range(len(path)):
   253     30395       7563.0      0.2      0.6                          next_i = (i2 + 1) % len(path)
   254     30395      28681.2      0.9      2.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255     30395       5886.7      0.2      0.5                          if best_cost > insertion_cost:
   256      2965        667.5      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       330         82.6      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    212226     264629.3      1.2     20.3                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     34554      37632.5      1.1      2.9                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     34554      13365.2      0.4      1.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     34554       8501.6      0.2      0.7                      best_pos = (best_pos + 1) % (len(path))
   266    212226     276148.2      1.3     21.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     40385      45942.0      1.1      3.5                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     40385      18347.3      0.5      1.4                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269       652      14742.6     22.6      1.1              heapq.heapify(h)
   270                                           
   271         1          5.2      5.2      0.0          self.tour = path
   272         1        375.1    375.1      0.0          self.calculateCost()

Total time: 0.607678 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          1.1      1.1      0.0          n = self.numCity
   277         1      15535.4  15535.4      2.6          distances = np.array(self.adj)
   278         1          1.3      1.3      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281       655         98.3      0.2      0.0          for i in range(n):
   282    214185      34741.2      0.2      5.7              for j in range(0, i):
   283    213531      79813.2      0.4     13.1                  if distances[i][j] > maxDist:
   284        23          5.2      0.2      0.0                      path[0], path[1] = i, j
   285        23          8.0      0.3      0.0                      maxDist = distances[i][j]
   286         1          1.3      1.3      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.7      0.7      0.0          h = []
   291       653        135.2      0.2      0.0          for i in set(range(n)) - in_path:
   292       652        499.6      0.8      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         37.6     37.6      0.0          heapq.heapify(h)
   294                                           
   295       653        244.2      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297       652        428.8      0.7      0.1              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300       652        158.5      0.2      0.0              best_increase = np.inf
   301       652         86.0      0.1      0.0              best_position = None
   302    214182      32521.7      0.2      5.4              for i in range(len(path)):
   303    213530      51994.8      0.2      8.6                  next_i = (i + 1) % len(path)
   304    213530     163898.2      0.8     27.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    213530      40228.2      0.2      6.6                  if increase < best_increase:
   306     13843       1779.9      0.1      0.3                      best_increase = increase
   307     13843       2528.4      0.2      0.4                      best_position = i + 1
   308                                           
   309       652        282.7      0.4      0.0              path.insert(best_position, to_insert)
   310       652        173.2      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    212878      42811.1      0.2      7.0              for i, (cost, node) in enumerate(h):
   314    212226      43416.8      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    212226      81243.4      0.4     13.4                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318       652      14636.0     22.4      2.4              heapq.heapify(h)
   319                                           
   320         1          5.2      5.2      0.0          self.tour = path
   321         1        362.2    362.2      0.1          self.calculateCost()

Total time: 1.23952 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.8      0.8      0.0          n = self.numCity
   326         1      13877.2  13877.2      1.1          adj = np.array(self.adj)
   327         1      13256.6  13256.6      1.1          distances = np.array(self.adj)
   328         1          1.0      1.0      0.0          path = [0, 0]
   329                                           
   330         1          0.3      0.3      0.0          maxDist = 0
   331       655         94.7      0.1      0.0          for i in range(n):
   332    214185      32857.5      0.2      2.7              for j in range(0, i):
   333    213531      76768.0      0.4      6.2                  if distances[i][j] > maxDist:
   334        23          6.1      0.3      0.0                      path[0], path[1] = i, j
   335        23          8.2      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.7      0.7      0.0          h = []
   339       653        136.0      0.2      0.0          for i in set(range(n)) - in_path:
   340       652        696.2      1.1      0.1              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341       652        244.7      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         37.9     37.9      0.0          heapq.heapify(h)
   343                                           
   344       653        264.4      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346       652        463.8      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349       652        161.8      0.2      0.0              best_increase = np.inf
   350       652        101.9      0.2      0.0              best_pos = None
   351    214182      34255.4      0.2      2.8              for i in range(len(path)):
   352    213530      53796.5      0.3      4.3                  next_i = (i + 1) % len(path)
   353    213530     168959.9      0.8     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    213530      41146.7      0.2      3.3                  if increase < best_increase:
   355     37244       5187.0      0.1      0.4                      best_increase = increase
   356     37244       6034.0      0.2      0.5                      best_pos = next_i
   357                                           
   358       652        295.1      0.5      0.0              path.insert(best_pos, to_ins)
   359       652        175.8      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    212878      53173.5      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    212226      42931.6      0.2      3.5                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    212226      79616.2      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       377         80.6      0.2      0.0                      best_cost = np.inf
   367       377         60.6      0.2      0.0                      posL, posR = -1, -1
   368     39126       6077.4      0.2      0.5                      for i2 in range(len(path)):
   369     38749       9067.5      0.2      0.7                          next_i = (i2 + 1) % len(path)
   370     38749      34992.6      0.9      2.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     38749       7221.0      0.2      0.6                          if best_cost > insertion_cost:
   372      9107       1872.3      0.2      0.2                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       377        117.3      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    212226     262613.0      1.2     21.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       696        797.1      1.1      0.1                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       696        283.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       696        170.2      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    212226     273653.7      1.3     22.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      1701       1966.4      1.2      0.2                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      1701        754.2      0.4      0.1                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385       652      14862.6     22.8      1.2              heapq.heapify(h)
   386                                           
   387         1          4.9      4.9      0.0          self.tour = path
   388         1        377.8    377.8      0.0          self.calculateCost()


Optimal 8806
_________________
rat783
randomInsertion 1.1329175595609693
nearestInsertion 1.2483067104981067
cheapestInsertion 1.2147962801440078
nearestNeighbor 1.2781138138726136
farthestInsertion 1.2553377382583182
furthestInsertion 1.1462305985701426

[('rat783', 1.1329175595609693, 1.2483067104981067, 1.2147962801440078, 1.2781138138726136, 1.2553377382583182, 1.1462305985701426)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.452715 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.9      0.9      0.0          n = self.numCity
   115         1      21498.6  21498.6      4.7          distances = np.array(self.adj)
   116         1          1.5      1.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1         69.4     69.4      0.0          notInPath = [x for x in range(1, n)]
   119         1        828.3    828.3      0.2          random.shuffle(notInPath)
   120                                           
   121       783        242.0      0.3      0.1          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123       782        176.8      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126       782        168.3      0.2      0.0              best_increase = np.inf
   127       782        106.1      0.1      0.0              best_position = None
   128    306935      49909.0      0.2     11.0              for i in range(len(path)):
   129    306153      75465.0      0.2     16.7                  next_i = (i + 1) % len(path)
   130    306153     236086.8      0.8     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    306153      59905.0      0.2     13.2                  if increase < best_increase:
   132     24323       3283.4      0.1      0.7                      best_increase = increase
   133     24323       4004.3      0.2      0.9                      best_position = next_i
   134                                           
   135       782        288.8      0.4      0.1              path.insert(best_position, to_insert)
   136       782        227.0      0.3      0.1              in_path.add(to_insert)
   137                                           
   138         1          2.9      2.9      0.0          self.tour = path
   139         1        449.9    449.9      0.1          self.calculateCost()

Total time: 0.172165 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          4.1      4.1      0.0          self.tour = [0]
   144         1          1.5      1.5      0.0          visited = set([0])
   145         1         12.8     12.8      0.0          notVisited = set(range(1, self.numCity))
   146       783        341.8      0.4      0.2          while len(self.tour) < self.numCity:
   147       782        183.3      0.2      0.1              cost = np.inf
   148       782        109.1      0.1      0.1              j = -1
   149    306935      53024.6      0.2     30.8              for j2 in notVisited:
   150    306153     109124.4      0.4     63.4                  if self.adj[self.tour[-1]][j2] < cost:
   151     20286       5067.9      0.2      2.9                      cost = self.adj[self.tour[-1]][j2]
   152     20286       3089.1      0.2      1.8                      j = j2
   153       782        294.0      0.4      0.2              self.tour.append(j)
   154       782        247.5      0.3      0.1              visited.add(j)
   155       782        208.7      0.3      0.1              notVisited.remove(j)
   156         1        456.3    456.3      0.3          self.calculateCost()

Total time: 0.830081 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.7      0.7      0.0          n = self.numCity
   162         1      21651.6  21651.6      2.6          distances = np.array(self.adj)
   163         1          1.2      1.2      0.0          path = [0, 0]
   164                                           
   165         1          1.5      1.5      0.0          minDist = np.inf
   166       784        111.9      0.1      0.0          for i in range(n):
   167    306936      47111.9      0.2      5.7              for j in range(0, i):
   168    306153     112960.8      0.4     13.6                  if distances[i][j] < minDist:
   169         6          2.1      0.3      0.0                      path[0], path[1] = i, j
   170         6          2.3      0.4      0.0                      minDist = distances[i][j]
   171         1          1.3      1.3      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.6      0.6      0.0          h = []
   176       782        158.0      0.2      0.0          for i in set(range(n)) - in_path:
   177       781       2525.5      3.2      0.3              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         48.9     48.9      0.0          heapq.heapify(h)
   179                                           
   180       782        272.9      0.3      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182       781        533.7      0.7      0.1              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185       781        217.6      0.3      0.0              best_increase = np.inf
   186       781        121.9      0.2      0.0              best_position = None
   187    306933      49475.1      0.2      6.0              for i in range(len(path)):
   188    306152      77099.3      0.3      9.3                  next_i = (i + 1) % len(path)
   189    306152     246568.9      0.8     29.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    306152      64358.7      0.2      7.8                  if increase < best_increase:
   191     19335       2580.9      0.1      0.3                      best_increase = increase
   192     19335       4057.8      0.2      0.5                      best_position = i + 1
   193                                           
   194       781        334.9      0.4      0.0              path.insert(best_position, to_insert)
   195       781        226.8      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    305371      64480.7      0.2      7.8              for i, (cost, node) in enumerate(h):
   199    304590     106065.3      0.3     12.8                  if node not in in_path and distances[to_insert, node] < cost:
   200     24012       7787.8      0.3      0.9                      h[i] = (distances[to_insert, node], node)
   201       781      20892.6     26.8      2.5              heapq.heapify(h)
   202                                           
   203         1          6.0      6.0      0.0          self.tour = path
   204         1        422.4    422.4      0.1          self.calculateCost()

Total time: 2.01033 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1      20249.6  20249.6      1.0          adj = np.array(self.adj)
   210         1      19278.4  19278.4      1.0          distances = np.array(self.adj)
   211         1          1.5      1.5      0.0          path = [0, 0]
   212                                           
   213         1          1.1      1.1      0.0          minDist = np.inf
   214       784        112.9      0.1      0.0          for i in range(n):
   215    306936      47961.7      0.2      2.4              for j in range(0, i):
   216    306153     110120.9      0.4      5.5                  if distances[i][j] < minDist:
   217         6          2.1      0.4      0.0                      path[0], path[1] = i, j
   218         6          2.0      0.3      0.0                      minDist = distances[i][j]
   219         1          2.0      2.0      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.5      0.5      0.0          h = []
   222       782        158.6      0.2      0.0          for i in set(range(n)) - in_path:
   223       781        758.9      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224       781        307.9      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         47.9     47.9      0.0          heapq.heapify(h)
   226                                           
   227       782        518.8      0.7      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229       781       1013.8      1.3      0.1              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232       781        530.5      0.7      0.0              best_increase = np.inf
   233       781        207.4      0.3      0.0              best_pos = None
   234    306933      58826.2      0.2      2.9              for i in range(len(path)):
   235    306152      87301.6      0.3      4.3                  next_i = (i + 1) % len(path)
   236    306152     297634.2      1.0     14.8                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    306152      67977.2      0.2      3.4                  if increase < best_increase:
   238     20120       3346.5      0.2      0.2                      best_increase = increase
   239     20120       3555.7      0.2      0.2                      best_pos = next_i
   240                                           
   241       781        950.7      1.2      0.0              path.insert(best_pos, to_ins)
   242       781        477.5      0.6      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    305371      95993.9      0.3      4.8              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    304590     126596.7      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       609        158.9      0.3      0.0                      best_cost = np.inf
   251       609        132.2      0.2      0.0                      posL, posR = -1, -1
   252     47182       8717.1      0.2      0.4                      for i2 in range(len(path)):
   253     46573      13502.7      0.3      0.7                          next_i = (i2 + 1) % len(path)
   254     46573      52554.3      1.1      2.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255     46573      10596.0      0.2      0.5                          if best_cost > insertion_cost:
   256      3753        934.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       609        174.4      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    304590     435957.2      1.4     21.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     19280      22283.6      1.2      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     19280       7685.8      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     19280       4842.1      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266    304590     444420.4      1.5     22.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     22700      27003.8      1.2      1.3                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     22700      10876.4      0.5      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269       781      25820.3     33.1      1.3              heapq.heapify(h)
   270                                           
   271         1         10.0     10.0      0.0          self.tour = path
   272         1        718.5    718.5      0.0          self.calculateCost()

Total time: 0.959612 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.8      0.8      0.0          n = self.numCity
   277         1      21904.9  21904.9      2.3          distances = np.array(self.adj)
   278         1          1.2      1.2      0.0          path = [0, 0]
   279                                           
   280         1          0.8      0.8      0.0          maxDist = 0
   281       784        130.1      0.2      0.0          for i in range(n):
   282    306936      51892.1      0.2      5.4              for j in range(0, i):
   283    306153     123519.7      0.4     12.9                  if distances[i][j] > maxDist:
   284        64         31.8      0.5      0.0                      path[0], path[1] = i, j
   285        64         24.8      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.6      0.6      0.0          h = []
   291       782        141.4      0.2      0.0          for i in set(range(n)) - in_path:
   292       781        570.0      0.7      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         57.7     57.7      0.0          heapq.heapify(h)
   294                                           
   295       782        422.7      0.5      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297       781        675.8      0.9      0.1              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300       781        276.6      0.4      0.0              best_increase = np.inf
   301       781        128.3      0.2      0.0              best_position = None
   302    306933      51311.3      0.2      5.3              for i in range(len(path)):
   303    306152      80112.6      0.3      8.3                  next_i = (i + 1) % len(path)
   304    306152     272249.9      0.9     28.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    306152      62701.8      0.2      6.5                  if increase < best_increase:
   306     22326       3061.1      0.1      0.3                      best_increase = increase
   307     22326       4485.9      0.2      0.5                      best_position = i + 1
   308                                           
   309       781        548.0      0.7      0.1              path.insert(best_position, to_insert)
   310       781        293.1      0.4      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    305371      68231.2      0.2      7.1              for i, (cost, node) in enumerate(h):
   314    304590      68148.0      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    304590     125454.7      0.4     13.1                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318       781      22781.7     29.2      2.4              heapq.heapify(h)
   319                                           
   320         1          6.9      6.9      0.0          self.tour = path
   321         1        444.7    444.7      0.0          self.calculateCost()

Total time: 1.85845 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          1.2      1.2      0.0          n = self.numCity
   326         1      22269.4  22269.4      1.2          adj = np.array(self.adj)
   327         1      22397.4  22397.4      1.2          distances = np.array(self.adj)
   328         1          1.3      1.3      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331       784        123.1      0.2      0.0          for i in range(n):
   332    306936      49403.7      0.2      2.7              for j in range(0, i):
   333    306153     115019.1      0.4      6.2                  if distances[i][j] > maxDist:
   334        64         30.6      0.5      0.0                      path[0], path[1] = i, j
   335        64         24.6      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.9      1.9      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.6      0.6      0.0          h = []
   339       782        146.6      0.2      0.0          for i in set(range(n)) - in_path:
   340       781        791.5      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341       781        316.9      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         56.3     56.3      0.0          heapq.heapify(h)
   343                                           
   344       782        367.6      0.5      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346       781        727.7      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349       781        278.8      0.4      0.0              best_increase = np.inf
   350       781        115.5      0.1      0.0              best_pos = None
   351    306933      50205.1      0.2      2.7              for i in range(len(path)):
   352    306152      78113.4      0.3      4.2                  next_i = (i + 1) % len(path)
   353    306152     272415.8      0.9     14.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    306152      61979.6      0.2      3.3                  if increase < best_increase:
   355     27884       4226.1      0.2      0.2                      best_increase = increase
   356     27884       4693.7      0.2      0.3                      best_pos = next_i
   357                                           
   358       781        528.8      0.7      0.0              path.insert(best_pos, to_ins)
   359       781        324.6      0.4      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    305371      83197.8      0.3      4.5              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    304590      67544.1      0.2      3.6                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    304590     117052.6      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       141         56.0      0.4      0.0                      best_cost = np.inf
   367       141         32.1      0.2      0.0                      posL, posR = -1, -1
   368     23180       3947.1      0.2      0.2                      for i2 in range(len(path)):
   369     23039       5973.9      0.3      0.3                          next_i = (i2 + 1) % len(path)
   370     23039      24031.6      1.0      1.3                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     23039       4777.4      0.2      0.3                          if best_cost > insertion_cost:
   372      2890        666.9      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       141         72.3      0.5      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    304590     412677.9      1.4     22.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       226        278.7      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       226        100.0      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       226         58.0      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    304590     427787.9      1.4     23.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      1446       1756.5      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      1446        677.0      0.5      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385       781      22732.6     29.1      1.2              heapq.heapify(h)
   386                                           
   387         1          7.4      7.4      0.0          self.tour = path
   388         1        461.9    461.9      0.0          self.calculateCost()


Optimal 259045
_________________
pr1002
randomInsertion 1.1223411011787852
nearestInsertion 1.1855192651239008
cheapestInsertion 1.1930272704519314
nearestNeighbor 1.2183079673193584
farthestInsertion 1.250696041570801
furthestInsertion 1.1693748897369363

[('pr1002', 1.1223411011787852, 1.1855192651239008, 1.1930272704519314, 1.2183079673193584, 1.250696041570801, 1.1693748897369363)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.839556 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.7      0.7      0.0          n = self.numCity
   115         1      39675.9  39675.9      4.7          distances = np.array(self.adj)
   116         1          1.0      1.0      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.3      1.3      0.0          in_path = {0}
   118         1         98.2     98.2      0.0          notInPath = [x for x in range(1, n)]
   119         1       1180.2   1180.2      0.1          random.shuffle(notInPath)
   120                                           
   121      1002        393.0      0.4      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1001        331.1      0.3      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1001        400.6      0.4      0.0              best_increase = np.inf
   127      1001        158.1      0.2      0.0              best_position = None
   128    502502      88896.6      0.2     10.6              for i in range(len(path)):
   129    501501     134522.3      0.3     16.0                  next_i = (i + 1) % len(path)
   130    501501     457719.5      0.9     54.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    501501     103529.4      0.2     12.3                  if increase < best_increase:
   132     33251       5211.2      0.2      0.6                      best_increase = increase
   133     33251       5665.5      0.2      0.7                      best_position = next_i
   134                                           
   135      1001        717.1      0.7      0.1              path.insert(best_position, to_insert)
   136      1001        504.9      0.5      0.1              in_path.add(to_insert)
   137                                           
   138         1          3.4      3.4      0.0          self.tour = path
   139         1        546.0    546.0      0.1          self.calculateCost()

Total time: 0.257813 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          4.6      4.6      0.0          self.tour = [0]
   144         1          1.3      1.3      0.0          visited = set([0])
   145         1         12.7     12.7      0.0          notVisited = set(range(1, self.numCity))
   146      1002        409.7      0.4      0.2          while len(self.tour) < self.numCity:
   147      1001        199.8      0.2      0.1              cost = np.inf
   148      1001        140.3      0.1      0.1              j = -1
   149    502502      78192.8      0.2     30.3              for j2 in notVisited:
   150    501501     169040.3      0.3     65.6                  if self.adj[self.tour[-1]][j2] < cost:
   151     20721       5348.8      0.3      2.1                      cost = self.adj[self.tour[-1]][j2]
   152     20721       3094.2      0.1      1.2                      j = j2
   153      1001        296.0      0.3      0.1              self.tour.append(j)
   154      1001        267.8      0.3      0.1              visited.add(j)
   155      1001        256.8      0.3      0.1              notVisited.remove(j)
   156         1        547.7    547.7      0.2          self.calculateCost()

Total time: 1.39428 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.8      0.8      0.0          n = self.numCity
   162         1      36349.1  36349.1      2.6          distances = np.array(self.adj)
   163         1          1.1      1.1      0.0          path = [0, 0]
   164                                           
   165         1          1.6      1.6      0.0          minDist = np.inf
   166      1003        146.3      0.1      0.0          for i in range(n):
   167    502503      81916.5      0.2      5.9              for j in range(0, i):
   168    501501     201716.6      0.4     14.5                  if distances[i][j] < minDist:
   169         8          2.3      0.3      0.0                      path[0], path[1] = i, j
   170         8          3.1      0.4      0.0                      minDist = distances[i][j]
   171         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.8      0.8      0.0          h = []
   176      1001        202.2      0.2      0.0          for i in set(range(n)) - in_path:
   177      1000       1541.8      1.5      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         68.9     68.9      0.0          heapq.heapify(h)
   179                                           
   180      1001        365.5      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1000        740.5      0.7      0.1              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1000        285.6      0.3      0.0              best_increase = np.inf
   186      1000        160.9      0.2      0.0              best_position = None
   187    502500      83961.5      0.2      6.0              for i in range(len(path)):
   188    501500     123497.1      0.2      8.9                  next_i = (i + 1) % len(path)
   189    501500     401087.3      0.8     28.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    501500      97858.6      0.2      7.0                  if increase < best_increase:
   191     38117       5301.2      0.1      0.4                      best_increase = increase
   192     38117       7283.1      0.2      0.5                      best_position = i + 1
   193                                           
   194      1000        493.2      0.5      0.0              path.insert(best_position, to_insert)
   195      1000        265.8      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    500500     108126.6      0.2      7.8              for i, (cost, node) in enumerate(h):
   199    499500     190828.6      0.4     13.7                  if node not in in_path and distances[to_insert, node] < cost:
   200     47202      17057.9      0.4      1.2                      h[i] = (distances[to_insert, node], node)
   201      1000      34461.1     34.5      2.5              heapq.heapify(h)
   202                                           
   203         1          7.9      7.9      0.0          self.tour = path
   204         1        544.1    544.1      0.0          self.calculateCost()

Total time: 3.07916 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1      35248.7  35248.7      1.1          adj = np.array(self.adj)
   210         1      34460.1  34460.1      1.1          distances = np.array(self.adj)
   211         1          1.3      1.3      0.0          path = [0, 0]
   212                                           
   213         1          1.7      1.7      0.0          minDist = np.inf
   214      1003        143.3      0.1      0.0          for i in range(n):
   215    502503      81139.4      0.2      2.6              for j in range(0, i):
   216    501501     203159.5      0.4      6.6                  if distances[i][j] < minDist:
   217         8          2.4      0.3      0.0                      path[0], path[1] = i, j
   218         8          2.9      0.4      0.0                      minDist = distances[i][j]
   219         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.7      0.7      0.0          h = []
   222      1001        209.1      0.2      0.0          for i in set(range(n)) - in_path:
   223      1000       1041.7      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1000        392.5      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         64.7     64.7      0.0          heapq.heapify(h)
   226                                           
   227      1001        446.2      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1000        846.1      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1000        353.0      0.4      0.0              best_increase = np.inf
   233      1000        191.1      0.2      0.0              best_pos = None
   234    502500      85831.9      0.2      2.8              for i in range(len(path)):
   235    501500     129862.8      0.3      4.2                  next_i = (i + 1) % len(path)
   236    501500     422924.2      0.8     13.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    501500     101897.6      0.2      3.3                  if increase < best_increase:
   238     38890       5851.9      0.2      0.2                      best_increase = increase
   239     38890       6343.4      0.2      0.2                      best_pos = next_i
   240                                           
   241      1000        607.3      0.6      0.0              path.insert(best_pos, to_ins)
   242      1000        334.9      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    500500     126139.8      0.3      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    499500     193304.8      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       716        174.6      0.2      0.0                      best_cost = np.inf
   251       716        118.5      0.2      0.0                      posL, posR = -1, -1
   252     80953      13843.7      0.2      0.4                      for i2 in range(len(path)):
   253     80237      20052.2      0.2      0.7                          next_i = (i2 + 1) % len(path)
   254     80237      81515.7      1.0      2.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255     80237      16021.9      0.2      0.5                          if best_cost > insertion_cost:
   256      7257       1626.0      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       716        189.8      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    499500     663327.8      1.3     21.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     29836      35238.7      1.2      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     29836      12040.9      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     29836       7641.0      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266    499500     699447.2      1.4     22.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     36378      43644.5      1.2      1.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     36378      17558.5      0.5      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1000      35360.0     35.4      1.1              heapq.heapify(h)
   270                                           
   271         1          7.9      7.9      0.0          self.tour = path
   272         1        541.5    541.5      0.0          self.calculateCost()

Total time: 1.50651 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1      34951.4  34951.4      2.3          distances = np.array(self.adj)
   278         1          1.5      1.5      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281      1003        151.1      0.2      0.0          for i in range(n):
   282    502503      75936.5      0.2      5.0              for j in range(0, i):
   283    501501     201040.9      0.4     13.3                  if distances[i][j] > maxDist:
   284       101         28.2      0.3      0.0                      path[0], path[1] = i, j
   285       101         37.2      0.4      0.0                      maxDist = distances[i][j]
   286         1          2.3      2.3      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.7      0.7      0.0          h = []
   291      1001        177.1      0.2      0.0          for i in set(range(n)) - in_path:
   292      1000        718.0      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         65.1     65.1      0.0          heapq.heapify(h)
   294                                           
   295      1001        387.7      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1000        718.5      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1000        253.1      0.3      0.0              best_increase = np.inf
   301      1000        149.8      0.1      0.0              best_position = None
   302    502500      82195.8      0.2      5.5              for i in range(len(path)):
   303    501500     126746.9      0.3      8.4                  next_i = (i + 1) % len(path)
   304    501500     421960.3      0.8     28.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    501500      98467.2      0.2      6.5                  if increase < best_increase:
   306     37362       5037.6      0.1      0.3                      best_increase = increase
   307     37362       7068.6      0.2      0.5                      best_position = i + 1
   308                                           
   309      1000        482.8      0.5      0.0              path.insert(best_position, to_insert)
   310      1000        303.9      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    500500     106685.4      0.2      7.1              for i, (cost, node) in enumerate(h):
   314    499500     105616.0      0.2      7.0                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    499500     202070.3      0.4     13.4                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1000      34701.9     34.7      2.3              heapq.heapify(h)
   319                                           
   320         1          9.1      9.1      0.0          self.tour = path
   321         1        541.7    541.7      0.0          self.calculateCost()

Total time: 2.97157 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.5      0.5      0.0          n = self.numCity
   326         1      33973.1  33973.1      1.1          adj = np.array(self.adj)
   327         1      34862.8  34862.8      1.2          distances = np.array(self.adj)
   328         1          1.2      1.2      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331      1003        162.5      0.2      0.0          for i in range(n):
   332    502503      77428.5      0.2      2.6              for j in range(0, i):
   333    501501     196452.4      0.4      6.6                  if distances[i][j] > maxDist:
   334       101         25.9      0.3      0.0                      path[0], path[1] = i, j
   335       101         37.1      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.3      1.3      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339      1001        174.5      0.2      0.0          for i in set(range(n)) - in_path:
   340      1000       1044.5      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1000        415.5      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         58.5     58.5      0.0          heapq.heapify(h)
   343                                           
   344      1001        387.3      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1000        717.5      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1000        237.4      0.2      0.0              best_increase = np.inf
   350      1000        150.4      0.2      0.0              best_pos = None
   351    502500      78993.6      0.2      2.7              for i in range(len(path)):
   352    501500     119882.9      0.2      4.0                  next_i = (i + 1) % len(path)
   353    501500     409311.6      0.8     13.8                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    501500      94342.8      0.2      3.2                  if increase < best_increase:
   355     41957       5759.1      0.1      0.2                      best_increase = increase
   356     41957       6349.5      0.2      0.2                      best_pos = next_i
   357                                           
   358      1000        410.2      0.4      0.0              path.insert(best_pos, to_ins)
   359      1000        247.7      0.2      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    500500     118773.4      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    499500     109546.9      0.2      3.7                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    499500     184586.2      0.4      6.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       439         96.5      0.2      0.0                      best_cost = np.inf
   367       439         69.8      0.2      0.0                      posL, posR = -1, -1
   368     47883       7498.3      0.2      0.3                      for i2 in range(len(path)):
   369     47444      11153.9      0.2      0.4                          next_i = (i2 + 1) % len(path)
   370     47444      46371.3      1.0      1.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     47444       8889.1      0.2      0.3                          if best_cost > insertion_cost:
   372      6126       1301.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       439        138.6      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    499500     682768.4      1.4     23.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       361        436.8      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       361        151.3      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       361         92.0      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    499500     700234.1      1.4     23.6                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      2004       2476.5      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      2004        877.5      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1000      34124.0     34.1      1.1              heapq.heapify(h)
   386                                           
   387         1          8.3      8.3      0.0          self.tour = path
   388         1        546.4    546.4      0.0          self.calculateCost()


Optimal 224094
_________________
u1060
randomInsertion 1.1189020057545411
nearestInsertion 1.2387062002307947
cheapestInsertion 1.229070272027485
nearestNeighbor 1.27196349379042
farthestInsertion 1.2181429570530204
furthestInsertion 1.1673024420755738

[('u1060', 1.1189020057545411, 1.2387062002307947, 1.229070272027485, 1.27196349379042, 1.2181429570530204, 1.1673024420755738)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 0.826306 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.8      0.8      0.0          n = self.numCity
   115         1      39008.5  39008.5      4.7          distances = np.array(self.adj)
   116         1          1.7      1.7      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.0      1.0      0.0          in_path = {0}
   118         1         89.0     89.0      0.0          notInPath = [x for x in range(1, n)]
   119         1       1073.7   1073.7      0.1          random.shuffle(notInPath)
   120                                           
   121      1060        330.3      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1059        253.0      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1059        232.1      0.2      0.0              best_increase = np.inf
   127      1059        155.5      0.1      0.0              best_position = None
   128    562329      95193.9      0.2     11.5              for i in range(len(path)):
   129    561270     139797.2      0.2     16.9                  next_i = (i + 1) % len(path)
   130    561270     430442.8      0.8     52.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    561270     106181.4      0.2     12.9                  if increase < best_increase:
   132     41387       5816.0      0.1      0.7                      best_increase = increase
   133     41387       6362.7      0.2      0.8                      best_position = next_i
   134                                           
   135      1059        439.5      0.4      0.1              path.insert(best_position, to_insert)
   136      1059        336.7      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.0      4.0      0.0          self.tour = path
   139         1        585.7    585.7      0.1          self.calculateCost()

Total time: 0.286992 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          4.7      4.7      0.0          self.tour = [0]
   144         1          1.9      1.9      0.0          visited = set([0])
   145         1         15.4     15.4      0.0          notVisited = set(range(1, self.numCity))
   146      1060        397.2      0.4      0.1          while len(self.tour) < self.numCity:
   147      1059        241.2      0.2      0.1              cost = np.inf
   148      1059        137.5      0.1      0.0              j = -1
   149    562329      96669.9      0.2     33.7              for j2 in notVisited:
   150    561270     179634.6      0.3     62.6                  if self.adj[self.tour[-1]][j2] < cost:
   151     21792       5202.0      0.2      1.8                      cost = self.adj[self.tour[-1]][j2]
   152     21792       3195.8      0.1      1.1                      j = j2
   153      1059        360.6      0.3      0.1              self.tour.append(j)
   154      1059        295.1      0.3      0.1              visited.add(j)
   155      1059        264.8      0.3      0.1              notVisited.remove(j)
   156         1        571.6    571.6      0.2          self.calculateCost()

Total time: 1.49174 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.6      0.6      0.0          n = self.numCity
   162         1      39273.7  39273.7      2.6          distances = np.array(self.adj)
   163         1          1.1      1.1      0.0          path = [0, 0]
   164                                           
   165         1          1.8      1.8      0.0          minDist = np.inf
   166      1061        153.4      0.1      0.0          for i in range(n):
   167    562330      88623.8      0.2      5.9              for j in range(0, i):
   168    561270     206017.3      0.4     13.8                  if distances[i][j] < minDist:
   169         5          1.7      0.3      0.0                      path[0], path[1] = i, j
   170         5          1.9      0.4      0.0                      minDist = distances[i][j]
   171         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.8      0.8      0.0          h = []
   176      1059        214.6      0.2      0.0          for i in set(range(n)) - in_path:
   177      1058       2536.0      2.4      0.2              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         68.4     68.4      0.0          heapq.heapify(h)
   179                                           
   180      1059        376.1      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1058        733.8      0.7      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1058        259.5      0.2      0.0              best_increase = np.inf
   186      1058        178.3      0.2      0.0              best_position = None
   187    562327      88995.5      0.2      6.0              for i in range(len(path)):
   188    561269     138030.5      0.2      9.3                  next_i = (i + 1) % len(path)
   189    561269     429255.7      0.8     28.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    561269     102886.6      0.2      6.9                  if increase < best_increase:
   191     44780       6366.7      0.1      0.4                      best_increase = increase
   192     44780       8139.3      0.2      0.5                      best_position = i + 1
   193                                           
   194      1058        449.0      0.4      0.0              path.insert(best_position, to_insert)
   195      1058        289.0      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    560211     121545.9      0.2      8.1              for i, (cost, node) in enumerate(h):
   199    559153     200416.8      0.4     13.4                  if node not in in_path and distances[to_insert, node] < cost:
   200     55274      18421.9      0.3      1.2                      h[i] = (distances[to_insert, node], node)
   201      1058      37887.6     35.8      2.5              heapq.heapify(h)
   202                                           
   203         1          8.3      8.3      0.0          self.tour = path
   204         1        600.1    600.1      0.0          self.calculateCost()

Total time: 3.18351 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.6      0.6      0.0          n = self.numCity
   209         1      38552.0  38552.0      1.2          adj = np.array(self.adj)
   210         1      39276.3  39276.3      1.2          distances = np.array(self.adj)
   211         1          1.2      1.2      0.0          path = [0, 0]
   212                                           
   213         1          1.5      1.5      0.0          minDist = np.inf
   214      1061        155.2      0.1      0.0          for i in range(n):
   215    562330      92598.1      0.2      2.9              for j in range(0, i):
   216    561270     207826.4      0.4      6.5                  if distances[i][j] < minDist:
   217         5          1.9      0.4      0.0                      path[0], path[1] = i, j
   218         5          1.9      0.4      0.0                      minDist = distances[i][j]
   219         1          1.8      1.8      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.8      0.8      0.0          h = []
   222      1059        246.0      0.2      0.0          for i in set(range(n)) - in_path:
   223      1058       1045.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1058        436.4      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         67.6     67.6      0.0          heapq.heapify(h)
   226                                           
   227      1059        457.4      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1058        773.5      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1058        262.5      0.2      0.0              best_increase = np.inf
   233      1058        166.1      0.2      0.0              best_pos = None
   234    562327      91604.0      0.2      2.9              for i in range(len(path)):
   235    561269     142554.1      0.3      4.5                  next_i = (i + 1) % len(path)
   236    561269     432126.6      0.8     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    561269     104481.0      0.2      3.3                  if increase < best_increase:
   238     39423       5744.2      0.1      0.2                      best_increase = increase
   239     39423       6021.5      0.2      0.2                      best_pos = next_i
   240                                           
   241      1058        548.4      0.5      0.0              path.insert(best_pos, to_ins)
   242      1058        277.4      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    560211     137846.8      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    559153     207724.0      0.4      6.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       508         97.1      0.2      0.0                      best_cost = np.inf
   251       508         78.2      0.2      0.0                      posL, posR = -1, -1
   252     62464       9726.3      0.2      0.3                      for i2 in range(len(path)):
   253     61956      15341.0      0.2      0.5                          next_i = (i2 + 1) % len(path)
   254     61956      56508.5      0.9      1.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255     61956      11372.7      0.2      0.4                          if best_cost > insertion_cost:
   256      5298       1088.5      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       508        128.8      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    559153     685327.9      1.2     21.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     40030      43406.3      1.1      1.4                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     40030      15063.4      0.4      0.5                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     40030       9795.5      0.2      0.3                      best_pos = (best_pos + 1) % (len(path))
   266    559153     711575.3      1.3     22.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     47724      53273.4      1.1      1.7                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     47724      20990.9      0.4      0.7                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1058      38343.6     36.2      1.2              heapq.heapify(h)
   270                                           
   271         1          8.7      8.7      0.0          self.tour = path
   272         1        580.9    580.9      0.0          self.calculateCost()

Total time: 1.60501 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1      38561.7  38561.7      2.4          distances = np.array(self.adj)
   278         1          1.9      1.9      0.0          path = [0, 0]
   279                                           
   280         1          0.4      0.4      0.0          maxDist = 0
   281      1061        148.6      0.1      0.0          for i in range(n):
   282    562330      91838.2      0.2      5.7              for j in range(0, i):
   283    561270     204852.7      0.4     12.8                  if distances[i][j] > maxDist:
   284       184         44.5      0.2      0.0                      path[0], path[1] = i, j
   285       184         63.0      0.3      0.0                      maxDist = distances[i][j]
   286         1          1.3      1.3      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.7      0.7      0.0          h = []
   291      1059        184.8      0.2      0.0          for i in set(range(n)) - in_path:
   292      1058        704.5      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         93.2     93.2      0.0          heapq.heapify(h)
   294                                           
   295      1059        407.3      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1058        713.7      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1058        261.4      0.2      0.0              best_increase = np.inf
   301      1058        151.8      0.1      0.0              best_position = None
   302    562327      89603.0      0.2      5.6              for i in range(len(path)):
   303    561269     140474.5      0.3      8.8                  next_i = (i + 1) % len(path)
   304    561269     437825.5      0.8     27.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    561269     105867.7      0.2      6.6                  if increase < best_increase:
   306     38292       5501.3      0.1      0.3                      best_increase = increase
   307     38292       7266.0      0.2      0.5                      best_position = i + 1
   308                                           
   309      1058        463.4      0.4      0.0              path.insert(best_position, to_insert)
   310      1058        304.6      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    560211     113218.8      0.2      7.1              for i, (cost, node) in enumerate(h):
   314    559153     113937.4      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    559153     213556.7      0.4     13.3                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1058      38349.6     36.2      2.4              heapq.heapify(h)
   319                                           
   320         1          9.3      9.3      0.0          self.tour = path
   321         1        598.2    598.2      0.0          self.calculateCost()

Total time: 3.21921 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.6      0.6      0.0          n = self.numCity
   326         1      38332.3  38332.3      1.2          adj = np.array(self.adj)
   327         1      38858.7  38858.7      1.2          distances = np.array(self.adj)
   328         1          1.3      1.3      0.0          path = [0, 0]
   329                                           
   330         1          0.4      0.4      0.0          maxDist = 0
   331      1061        155.1      0.1      0.0          for i in range(n):
   332    562330      90099.1      0.2      2.8              for j in range(0, i):
   333    561270     203751.3      0.4      6.3                  if distances[i][j] > maxDist:
   334       184         43.5      0.2      0.0                      path[0], path[1] = i, j
   335       184         62.5      0.3      0.0                      maxDist = distances[i][j]
   336         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.7      0.7      0.0          h = []
   339      1059        184.4      0.2      0.0          for i in set(range(n)) - in_path:
   340      1058       1017.6      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1058        407.4      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         66.1     66.1      0.0          heapq.heapify(h)
   343                                           
   344      1059        428.9      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1058        750.0      0.7      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1058        252.9      0.2      0.0              best_increase = np.inf
   350      1058        183.1      0.2      0.0              best_pos = None
   351    562327      88041.3      0.2      2.7              for i in range(len(path)):
   352    561269     138057.8      0.2      4.3                  next_i = (i + 1) % len(path)
   353    561269     450321.2      0.8     14.0                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    561269     105123.9      0.2      3.3                  if increase < best_increase:
   355     40813       6065.2      0.1      0.2                      best_increase = increase
   356     40813       6423.3      0.2      0.2                      best_pos = next_i
   357                                           
   358      1058        496.5      0.5      0.0              path.insert(best_pos, to_ins)
   359      1058        297.7      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    560211     143140.3      0.3      4.4              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    559153     110132.3      0.2      3.4                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    559153     205762.3      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       324         70.9      0.2      0.0                      best_cost = np.inf
   367       324         53.7      0.2      0.0                      posL, posR = -1, -1
   368     60624       9424.2      0.2      0.3                      for i2 in range(len(path)):
   369     60300      14346.2      0.2      0.4                          next_i = (i2 + 1) % len(path)
   370     60300      55369.8      0.9      1.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     60300      11115.8      0.2      0.3                          if best_cost > insertion_cost:
   372      6011       1238.5      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       324        113.9      0.4      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    559153     715072.9      1.3     22.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       476        555.5      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       476        187.8      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       476        117.1      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    559153     740445.1      1.3     23.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      2036       2363.3      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      2036        895.1      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1058      38760.9     36.6      1.2              heapq.heapify(h)
   386                                           
   387         1          9.3      9.3      0.0          self.tour = path
   388         1        614.6    614.6      0.0          self.calculateCost()


Optimal 56892
_________________
pcb1173
randomInsertion 1.1817821963582307
nearestInsertion 1.2815213887660943
cheapestInsertion 1.2682042403149125
nearestNeighbor 1.2352868855978227
farthestInsertion 1.2779652259861987
furthestInsertion 1.2170483649101143

[('pcb1173', 1.1817821963582307, 1.2815213887660943, 1.2682042403149125, 1.2352868855978227, 1.2779652259861987, 1.2170483649101143)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.03678 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.0      1.0      0.0          n = self.numCity
   115         1      49102.6  49102.6      4.7          distances = np.array(self.adj)
   116         1          1.6      1.6      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1         97.6     97.6      0.0          notInPath = [x for x in range(1, n)]
   119         1       1092.7   1092.7      0.1          random.shuffle(notInPath)
   120                                           
   121      1173        357.0      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1172        269.4      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1172        270.4      0.2      0.0              best_increase = np.inf
   127      1172        170.3      0.1      0.0              best_position = None
   128    688550     109474.0      0.2     10.6              for i in range(len(path)):
   129    687378     173683.8      0.3     16.8                  next_i = (i + 1) % len(path)
   130    687378     553203.1      0.8     53.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    687378     134012.5      0.2     12.9                  if increase < best_increase:
   132     44128       6350.8      0.1      0.6                      best_increase = increase
   133     44128       7085.2      0.2      0.7                      best_position = next_i
   134                                           
   135      1172        532.1      0.5      0.1              path.insert(best_position, to_insert)
   136      1172        360.3      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.3      4.3      0.0          self.tour = path
   139         1        705.5    705.5      0.1          self.calculateCost()

Total time: 0.337796 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          5.6      5.6      0.0          self.tour = [0]
   144         1          1.2      1.2      0.0          visited = set([0])
   145         1         16.6     16.6      0.0          notVisited = set(range(1, self.numCity))
   146      1173        454.2      0.4      0.1          while len(self.tour) < self.numCity:
   147      1172        229.5      0.2      0.1              cost = np.inf
   148      1172        154.8      0.1      0.0              j = -1
   149    688550     109238.8      0.2     32.3              for j2 in notVisited:
   150    687378     214503.1      0.3     63.5                  if self.adj[self.tour[-1]][j2] < cost:
   151     30589       7182.4      0.2      2.1                      cost = self.adj[self.tour[-1]][j2]
   152     30589       4424.3      0.1      1.3                      j = j2
   153      1172        354.8      0.3      0.1              self.tour.append(j)
   154      1172        301.6      0.3      0.1              visited.add(j)
   155      1172        293.0      0.3      0.1              notVisited.remove(j)
   156         1        635.9    635.9      0.2          self.calculateCost()

Total time: 1.9299 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.7      0.7      0.0          n = self.numCity
   162         1      49389.0  49389.0      2.6          distances = np.array(self.adj)
   163         1          1.1      1.1      0.0          path = [0, 0]
   164                                           
   165         1          0.9      0.9      0.0          minDist = np.inf
   166      1174        175.9      0.1      0.0          for i in range(n):
   167    688551     109704.4      0.2      5.7              for j in range(0, i):
   168    687378     280712.2      0.4     14.5                  if distances[i][j] < minDist:
   169        11          4.2      0.4      0.0                      path[0], path[1] = i, j
   170        11          4.4      0.4      0.0                      minDist = distances[i][j]
   171         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          1.0      1.0      0.0          h = []
   176      1172        222.8      0.2      0.0          for i in set(range(n)) - in_path:
   177      1171       4825.1      4.1      0.3              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         61.7     61.7      0.0          heapq.heapify(h)
   179                                           
   180      1172        428.2      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1171        892.3      0.8      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1171        301.7      0.3      0.0              best_increase = np.inf
   186      1171        180.0      0.2      0.0              best_position = None
   187    688548     111864.2      0.2      5.8              for i in range(len(path)):
   188    687377     176792.1      0.3      9.2                  next_i = (i + 1) % len(path)
   189    687377     553684.7      0.8     28.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    687377     134386.1      0.2      7.0                  if increase < best_increase:
   191     50645       7328.6      0.1      0.4                      best_increase = increase
   192     50645       9854.0      0.2      0.5                      best_position = i + 1
   193                                           
   194      1171        565.2      0.5      0.0              path.insert(best_position, to_insert)
   195      1171        341.6      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    686206     150477.9      0.2      7.8              for i, (cost, node) in enumerate(h):
   199    685035     264381.4      0.4     13.7                  if node not in in_path and distances[to_insert, node] < cost:
   200     70156      25894.2      0.4      1.3                      h[i] = (distances[to_insert, node], node)
   201      1171      46733.3     39.9      2.4              heapq.heapify(h)
   202                                           
   203         1          9.7      9.7      0.0          self.tour = path
   204         1        682.9    682.9      0.0          self.calculateCost()

Total time: 4.08128 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.7      0.7      0.0          n = self.numCity
   209         1      47508.3  47508.3      1.2          adj = np.array(self.adj)
   210         1      49055.0  49055.0      1.2          distances = np.array(self.adj)
   211         1          1.1      1.1      0.0          path = [0, 0]
   212                                           
   213         1          1.4      1.4      0.0          minDist = np.inf
   214      1174        166.3      0.1      0.0          for i in range(n):
   215    688551     107341.8      0.2      2.6              for j in range(0, i):
   216    687378     280684.7      0.4      6.9                  if distances[i][j] < minDist:
   217        11          3.6      0.3      0.0                      path[0], path[1] = i, j
   218        11          4.2      0.4      0.0                      minDist = distances[i][j]
   219         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.7      0.7      0.0          h = []
   222      1172        254.6      0.2      0.0          for i in set(range(n)) - in_path:
   223      1171       1207.5      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1171        481.5      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         61.8     61.8      0.0          heapq.heapify(h)
   226                                           
   227      1172        498.2      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1171        921.5      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1171        306.0      0.3      0.0              best_increase = np.inf
   233      1171        209.5      0.2      0.0              best_pos = None
   234    688548     118668.5      0.2      2.9              for i in range(len(path)):
   235    687377     177511.0      0.3      4.3                  next_i = (i + 1) % len(path)
   236    687377     548666.9      0.8     13.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    687377     139072.6      0.2      3.4                  if increase < best_increase:
   238     55473       7474.3      0.1      0.2                      best_increase = increase
   239     55473       9199.4      0.2      0.2                      best_pos = next_i
   240                                           
   241      1171        571.8      0.5      0.0              path.insert(best_pos, to_ins)
   242      1171        307.4      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    686206     165571.4      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    685035     256430.4      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       813        172.3      0.2      0.0                      best_cost = np.inf
   251       813        129.7      0.2      0.0                      posL, posR = -1, -1
   252    105148      16700.3      0.2      0.4                      for i2 in range(len(path)):
   253    104335      25859.2      0.2      0.6                          next_i = (i2 + 1) % len(path)
   254    104335     105645.5      1.0      2.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    104335      19523.0      0.2      0.5                          if best_cost > insertion_cost:
   256     10202       2162.4      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       813        199.7      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    685035     864847.6      1.3     21.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     46308      53120.4      1.1      1.3                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     46308      17358.9      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     46308      11271.7      0.2      0.3                      best_pos = (best_pos + 1) % (len(path))
   266    685035     915067.0      1.3     22.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     55397      64410.5      1.2      1.6                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     55397      24981.2      0.5      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1171      46951.9     40.1      1.2              heapq.heapify(h)
   270                                           
   271         1          8.5      8.5      0.0          self.tour = path
   272         1        685.3    685.3      0.0          self.calculateCost()

Total time: 2.00669 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.6      0.6      0.0          n = self.numCity
   277         1      49920.1  49920.1      2.5          distances = np.array(self.adj)
   278         1          1.2      1.2      0.0          path = [0, 0]
   279                                           
   280         1          0.1      0.1      0.0          maxDist = 0
   281      1174        165.7      0.1      0.0          for i in range(n):
   282    688551     106372.9      0.2      5.3              for j in range(0, i):
   283    687378     277790.5      0.4     13.8                  if distances[i][j] > maxDist:
   284        89         19.2      0.2      0.0                      path[0], path[1] = i, j
   285        89         32.0      0.4      0.0                      maxDist = distances[i][j]
   286         1          2.6      2.6      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.8      0.8      0.0          h = []
   291      1172        202.6      0.2      0.0          for i in set(range(n)) - in_path:
   292      1171        865.8      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         70.0     70.0      0.0          heapq.heapify(h)
   294                                           
   295      1172        491.3      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1171        854.0      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1171        297.3      0.3      0.0              best_increase = np.inf
   301      1171        211.8      0.2      0.0              best_position = None
   302    688548     107991.4      0.2      5.4              for i in range(len(path)):
   303    687377     170767.1      0.2      8.5                  next_i = (i + 1) % len(path)
   304    687377     541937.4      0.8     27.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    687377     134315.2      0.2      6.7                  if increase < best_increase:
   306     47495       6336.2      0.1      0.3                      best_increase = increase
   307     47495       8988.0      0.2      0.4                      best_position = i + 1
   308                                           
   309      1171        555.1      0.5      0.0              path.insert(best_position, to_insert)
   310      1171        317.8      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    686206     138960.9      0.2      6.9              for i, (cost, node) in enumerate(h):
   314    685035     147453.7      0.2      7.3                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    685035     263716.5      0.4     13.1                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1171      47284.0     40.4      2.4              heapq.heapify(h)
   319                                           
   320         1          9.6      9.6      0.0          self.tour = path
   321         1        760.6    760.6      0.0          self.calculateCost()

Total time: 4.01581 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.7      0.7      0.0          n = self.numCity
   326         1      47190.8  47190.8      1.2          adj = np.array(self.adj)
   327         1      48944.3  48944.3      1.2          distances = np.array(self.adj)
   328         1          1.2      1.2      0.0          path = [0, 0]
   329                                           
   330         1          0.3      0.3      0.0          maxDist = 0
   331      1174        178.3      0.2      0.0          for i in range(n):
   332    688551     105554.9      0.2      2.6              for j in range(0, i):
   333    687378     275296.3      0.4      6.9                  if distances[i][j] > maxDist:
   334        89         19.5      0.2      0.0                      path[0], path[1] = i, j
   335        89         31.5      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.7      0.7      0.0          h = []
   339      1172        201.4      0.2      0.0          for i in set(range(n)) - in_path:
   340      1171       1153.8      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1171        447.1      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         75.1     75.1      0.0          heapq.heapify(h)
   343                                           
   344      1172        460.4      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1171        902.2      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1171        306.2      0.3      0.0              best_increase = np.inf
   350      1171        179.1      0.2      0.0              best_pos = None
   351    688548     107392.3      0.2      2.7              for i in range(len(path)):
   352    687377     172053.0      0.3      4.3                  next_i = (i + 1) % len(path)
   353    687377     555185.3      0.8     13.8                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    687377     130429.5      0.2      3.2                  if increase < best_increase:
   355     45027       6247.8      0.1      0.2                      best_increase = increase
   356     45027       7011.8      0.2      0.2                      best_pos = next_i
   357                                           
   358      1171        549.7      0.5      0.0              path.insert(best_pos, to_ins)
   359      1171        330.0      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    686206     170141.7      0.2      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    685035     157840.8      0.2      3.9                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    685035     257350.5      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       354         83.6      0.2      0.0                      best_cost = np.inf
   367       354         59.9      0.2      0.0                      posL, posR = -1, -1
   368     72387      11297.8      0.2      0.3                      for i2 in range(len(path)):
   369     72033      16672.7      0.2      0.4                          next_i = (i2 + 1) % len(path)
   370     72033      71595.5      1.0      1.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371     72033      13566.9      0.2      0.3                          if best_cost > insertion_cost:
   372      6440       1360.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       354        133.1      0.4      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    685035     882183.0      1.3     22.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       395        474.8      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       395        161.8      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       395         99.6      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    685035     920772.9      1.3     22.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      2248       2685.1      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      2248        970.0      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1171      47503.2     40.6      1.2              heapq.heapify(h)
   386                                           
   387         1         10.0     10.0      0.0          self.tour = path
   388         1        706.4    706.4      0.0          self.calculateCost()


Optimal 50801
_________________
d1291
randomInsertion 1.1902949036658395
nearestInsertion 1.2291679851087234
cheapestInsertion 1.2486357723883312
nearestNeighbor 1.1880958916870108
farthestInsertion 1.355592422817178
furthestInsertion 1.2646974645065034

[('d1291', 1.1902949036658395, 1.2291679851087234, 1.2486357723883312, 1.1880958916870108, 1.355592422817178, 1.2646974645065034)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.22178 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.7      0.7      0.0          n = self.numCity
   115         1      58736.5  58736.5      4.8          distances = np.array(self.adj)
   116         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1        114.2    114.2      0.0          notInPath = [x for x in range(1, n)]
   119         1       1300.0   1300.0      0.1          random.shuffle(notInPath)
   120                                           
   121      1291        368.1      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1290        294.8      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1290        325.3      0.3      0.0              best_increase = np.inf
   127      1290        185.3      0.1      0.0              best_position = None
   128    833985     134522.4      0.2     11.0              for i in range(len(path)):
   129    832695     199535.4      0.2     16.3                  next_i = (i + 1) % len(path)
   130    832695     653623.9      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    832695     156035.7      0.2     12.8                  if increase < best_increase:
   132     51863       7023.8      0.1      0.6                      best_increase = increase
   133     51863       8021.7      0.2      0.7                      best_position = next_i
   134                                           
   135      1290        527.0      0.4      0.0              path.insert(best_position, to_insert)
   136      1290        419.8      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.3      4.3      0.0          self.tour = path
   139         1        734.2    734.2      0.1          self.calculateCost()

Total time: 0.409559 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          5.9      5.9      0.0          self.tour = [0]
   144         1          1.2      1.2      0.0          visited = set([0])
   145         1         23.7     23.7      0.0          notVisited = set(range(1, self.numCity))
   146      1291        520.9      0.4      0.1          while len(self.tour) < self.numCity:
   147      1290        295.0      0.2      0.1              cost = np.inf
   148      1290        175.7      0.1      0.0              j = -1
   149    833985     133528.5      0.2     32.6              for j2 in notVisited:
   150    832695     257960.8      0.3     63.0                  if self.adj[self.tour[-1]][j2] < cost:
   151     37932       9612.6      0.3      2.3                      cost = self.adj[self.tour[-1]][j2]
   152     37932       5482.8      0.1      1.3                      j = j2
   153      1290        468.8      0.4      0.1              self.tour.append(j)
   154      1290        348.4      0.3      0.1              visited.add(j)
   155      1290        341.5      0.3      0.1              notVisited.remove(j)
   156         1        793.7    793.7      0.2          self.calculateCost()

Total time: 2.2734 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.6      0.6      0.0          n = self.numCity
   162         1      59605.4  59605.4      2.6          distances = np.array(self.adj)
   163         1          1.3      1.3      0.0          path = [0, 0]
   164                                           
   165         1          1.3      1.3      0.0          minDist = np.inf
   166      1292        196.8      0.2      0.0          for i in range(n):
   167    833986     135056.5      0.2      5.9              for j in range(0, i):
   168    832695     333945.5      0.4     14.7                  if distances[i][j] < minDist:
   169         2          0.9      0.5      0.0                      path[0], path[1] = i, j
   170         2          0.8      0.4      0.0                      minDist = distances[i][j]
   171         1          2.3      2.3      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.8      0.8      0.0          h = []
   176      1290        292.3      0.2      0.0          for i in set(range(n)) - in_path:
   177      1289       7911.7      6.1      0.3              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         86.9     86.9      0.0          heapq.heapify(h)
   179                                           
   180      1290        474.9      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1289        970.1      0.8      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1289        392.5      0.3      0.0              best_increase = np.inf
   186      1289        211.8      0.2      0.0              best_position = None
   187    833983     131262.3      0.2      5.8              for i in range(len(path)):
   188    832694     205399.3      0.2      9.0                  next_i = (i + 1) % len(path)
   189    832694     644750.3      0.8     28.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    832694     159063.2      0.2      7.0                  if increase < best_increase:
   191     72981       9935.7      0.1      0.4                      best_increase = increase
   192     72981      13807.1      0.2      0.6                      best_position = i + 1
   193                                           
   194      1289        585.6      0.5      0.0              path.insert(best_position, to_insert)
   195      1289        331.4      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    831405     177957.3      0.2      7.8              for i, (cost, node) in enumerate(h):
   199    830116     295020.8      0.4     13.0                  if node not in in_path and distances[to_insert, node] < cost:
   200    112682      38066.6      0.3      1.7                      h[i] = (distances[to_insert, node], node)
   201      1289      57333.1     44.5      2.5              heapq.heapify(h)
   202                                           
   203         1         10.8     10.8      0.0          self.tour = path
   204         1        723.6    723.6      0.0          self.calculateCost()

Total time: 5.47462 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.3      0.3      0.0          n = self.numCity
   209         1      64030.6  64030.6      1.2          adj = np.array(self.adj)
   210         1      60581.1  60581.1      1.1          distances = np.array(self.adj)
   211         1          1.4      1.4      0.0          path = [0, 0]
   212                                           
   213         1          1.4      1.4      0.0          minDist = np.inf
   214      1292        178.3      0.1      0.0          for i in range(n):
   215    833986     134887.6      0.2      2.5              for j in range(0, i):
   216    832695     353692.1      0.4      6.5                  if distances[i][j] < minDist:
   217         2          1.2      0.6      0.0                      path[0], path[1] = i, j
   218         2          1.0      0.5      0.0                      minDist = distances[i][j]
   219         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.5      0.5      0.0          h = []
   222      1290        332.0      0.3      0.0          for i in set(range(n)) - in_path:
   223      1289       1462.2      1.1      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1289        513.9      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         90.3     90.3      0.0          heapq.heapify(h)
   226                                           
   227      1290        572.9      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1289       1062.1      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1289        385.6      0.3      0.0              best_increase = np.inf
   233      1289        242.2      0.2      0.0              best_pos = None
   234    833983     136008.9      0.2      2.5              for i in range(len(path)):
   235    832694     209042.9      0.3      3.8                  next_i = (i + 1) % len(path)
   236    832694     657553.2      0.8     12.0                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    832694     159045.2      0.2      2.9                  if increase < best_increase:
   238     59366       8677.4      0.1      0.2                      best_increase = increase
   239     59366       9194.2      0.2      0.2                      best_pos = next_i
   240                                           
   241      1289        726.0      0.6      0.0              path.insert(best_pos, to_ins)
   242      1289        377.6      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    831405     205377.5      0.2      3.8              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    830116     309015.5      0.4      5.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      1626        410.1      0.3      0.0                      best_cost = np.inf
   251      1626        283.0      0.2      0.0                      posL, posR = -1, -1
   252    385452      64047.8      0.2      1.2                      for i2 in range(len(path)):
   253    383826      98690.9      0.3      1.8                          next_i = (i2 + 1) % len(path)
   254    383826     391937.1      1.0      7.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    383826      74293.9      0.2      1.4                          if best_cost > insertion_cost:
   256     30473       6679.4      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      1626        416.1      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    830116    1101186.9      1.3     20.1                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     61236      72621.6      1.2      1.3                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     61236      23855.9      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     61236      15338.7      0.3      0.3                      best_pos = (best_pos + 1) % (len(path))
   266    830116    1137790.9      1.4     20.8                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     69648      83783.4      1.2      1.5                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     69648      30983.4      0.4      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1289      58487.2     45.4      1.1              heapq.heapify(h)
   270                                           
   271         1         12.2     12.2      0.0          self.tour = path
   272         1        741.0    741.0      0.0          self.calculateCost()

Total time: 2.39359 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.8      0.8      0.0          n = self.numCity
   277         1      57720.4  57720.4      2.4          distances = np.array(self.adj)
   278         1          1.2      1.2      0.0          path = [0, 0]
   279                                           
   280         1          0.3      0.3      0.0          maxDist = 0
   281      1292        188.7      0.1      0.0          for i in range(n):
   282    833986     119522.5      0.1      5.0              for j in range(0, i):
   283    832695     344715.7      0.4     14.4                  if distances[i][j] > maxDist:
   284       104         23.8      0.2      0.0                      path[0], path[1] = i, j
   285       104         38.0      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.6      0.6      0.0          h = []
   291      1290        227.7      0.2      0.0          for i in set(range(n)) - in_path:
   292      1289        858.3      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         74.8     74.8      0.0          heapq.heapify(h)
   294                                           
   295      1290        509.0      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1289        965.3      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1289        312.9      0.2      0.0              best_increase = np.inf
   301      1289        199.8      0.2      0.0              best_position = None
   302    833983     130550.3      0.2      5.5              for i in range(len(path)):
   303    832694     199177.0      0.2      8.3                  next_i = (i + 1) % len(path)
   304    832694     647238.3      0.8     27.0                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    832694     155930.1      0.2      6.5                  if increase < best_increase:
   306     60660       7849.2      0.1      0.3                      best_increase = increase
   307     60660      11137.8      0.2      0.5                      best_position = i + 1
   308                                           
   309      1289        577.1      0.4      0.0              path.insert(best_position, to_insert)
   310      1289        358.9      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    831405     166472.4      0.2      7.0              for i, (cost, node) in enumerate(h):
   314    830116     170353.6      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    830116     321157.0      0.4     13.4                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1289      56691.4     44.0      2.4              heapq.heapify(h)
   319                                           
   320         1         10.1     10.1      0.0          self.tour = path
   321         1        726.2    726.2      0.0          self.calculateCost()

Total time: 4.97117 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.4      0.4      0.0          n = self.numCity
   326         1      57566.6  57566.6      1.2          adj = np.array(self.adj)
   327         1      59279.2  59279.2      1.2          distances = np.array(self.adj)
   328         1          1.0      1.0      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331      1292        186.6      0.1      0.0          for i in range(n):
   332    833986     131620.4      0.2      2.6              for j in range(0, i):
   333    832695     343043.8      0.4      6.9                  if distances[i][j] > maxDist:
   334       104         23.2      0.2      0.0                      path[0], path[1] = i, j
   335       104         37.8      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.3      1.3      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.7      0.7      0.0          h = []
   339      1290        229.6      0.2      0.0          for i in set(range(n)) - in_path:
   340      1289       1397.2      1.1      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1289        483.7      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         79.4     79.4      0.0          heapq.heapify(h)
   343                                           
   344      1290        530.7      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1289       1051.7      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1289        353.3      0.3      0.0              best_increase = np.inf
   350      1289        187.8      0.1      0.0              best_pos = None
   351    833983     129523.5      0.2      2.6              for i in range(len(path)):
   352    832694     203181.5      0.2      4.1                  next_i = (i + 1) % len(path)
   353    832694     653648.1      0.8     13.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    832694     156355.9      0.2      3.1                  if increase < best_increase:
   355     53235       7412.7      0.1      0.1                      best_increase = increase
   356     53235       8262.7      0.2      0.2                      best_pos = next_i
   357                                           
   358      1289        622.0      0.5      0.0              path.insert(best_pos, to_ins)
   359      1289        355.4      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    831405     204645.9      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    830116     179764.7      0.2      3.6                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    830116     301303.5      0.4      6.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       382        103.6      0.3      0.0                      best_cost = np.inf
   367       382         66.1      0.2      0.0                      posL, posR = -1, -1
   368    129932      20175.6      0.2      0.4                      for i2 in range(len(path)):
   369    129550      31351.6      0.2      0.6                          next_i = (i2 + 1) % len(path)
   370    129550     130469.2      1.0      2.6                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    129550      24127.2      0.2      0.5                          if best_cost > insertion_cost:
   372      9749       2048.7      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       382        121.3      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    830116    1102345.7      1.3     22.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       600        715.9      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       600        249.6      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       600        148.7      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    830116    1153572.9      1.4     23.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      2639       3224.7      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      2639       1183.7      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1289      59361.6     46.1      1.2              heapq.heapify(h)
   386                                           
   387         1          8.6      8.6      0.0          self.tour = path
   388         1        744.1    744.1      0.0          self.calculateCost()


Optimal 270199
_________________
rl1323
randomInsertion 1.1990556540696151
nearestInsertion 1.3017055742677788
cheapestInsertion 1.2594394819046424
nearestNeighbor 1.2290754949633589
farthestInsertion 1.271161536635629
furthestInsertion 1.2130627519749035

[('rl1323', 1.1990556540696151, 1.3017055742677788, 1.2594394819046424, 1.2290754949633589, 1.271161536635629, 1.2130627519749035)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.32831 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.7      0.7      0.0          n = self.numCity
   115         1      62066.5  62066.5      4.7          distances = np.array(self.adj)
   116         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.0      1.0      0.0          in_path = {0}
   118         1        122.7    122.7      0.0          notInPath = [x for x in range(1, n)]
   119         1       1470.9   1470.9      0.1          random.shuffle(notInPath)
   120                                           
   121      1323        412.1      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1322        285.8      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1322        321.7      0.2      0.0              best_increase = np.inf
   127      1322        186.5      0.1      0.0              best_position = None
   128    875825     144667.7      0.2     10.9              for i in range(len(path)):
   129    874503     222160.5      0.3     16.7                  next_i = (i + 1) % len(path)
   130    874503     711300.0      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    874503     168554.9      0.2     12.7                  if increase < best_increase:
   132     51973       6978.3      0.1      0.5                      best_increase = increase
   133     51973       7932.2      0.2      0.6                      best_position = next_i
   134                                           
   135      1322        579.0      0.4      0.0              path.insert(best_position, to_insert)
   136      1322        441.0      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          3.8      3.8      0.0          self.tour = path
   139         1        824.1    824.1      0.1          self.calculateCost()

Total time: 0.443841 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          9.3      9.3      0.0          self.tour = [0]
   144         1          1.7      1.7      0.0          visited = set([0])
   145         1         26.1     26.1      0.0          notVisited = set(range(1, self.numCity))
   146      1323        541.9      0.4      0.1          while len(self.tour) < self.numCity:
   147      1322        281.4      0.2      0.1              cost = np.inf
   148      1322        183.2      0.1      0.0              j = -1
   149    875825     144709.1      0.2     32.6              for j2 in notVisited:
   150    874503     291197.0      0.3     65.6                  if self.adj[self.tour[-1]][j2] < cost:
   151     12164       3026.4      0.2      0.7                      cost = self.adj[self.tour[-1]][j2]
   152     12164       1804.0      0.1      0.4                      j = j2
   153      1322        485.8      0.4      0.1              self.tour.append(j)
   154      1322        383.6      0.3      0.1              visited.add(j)
   155      1322        360.7      0.3      0.1              notVisited.remove(j)
   156         1        831.1    831.1      0.2          self.calculateCost()

Total time: 2.50093 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.6      0.6      0.0          n = self.numCity
   162         1      62707.1  62707.1      2.5          distances = np.array(self.adj)
   163         1          1.0      1.0      0.0          path = [0, 0]
   164                                           
   165         1          1.5      1.5      0.0          minDist = np.inf
   166      1324        190.7      0.1      0.0          for i in range(n):
   167    875826     141080.7      0.2      5.6              for j in range(0, i):
   168    874503     351974.2      0.4     14.1                  if distances[i][j] < minDist:
   169         7          3.0      0.4      0.0                      path[0], path[1] = i, j
   170         7          2.8      0.4      0.0                      minDist = distances[i][j]
   171         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.6      0.6      0.0          h = []
   176      1322        306.1      0.2      0.0          for i in set(range(n)) - in_path:
   177      1321       1430.0      1.1      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        105.5    105.5      0.0          heapq.heapify(h)
   179                                           
   180      1322        548.1      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1321        989.4      0.7      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1321        339.6      0.3      0.0              best_increase = np.inf
   186      1321        260.4      0.2      0.0              best_position = None
   187    875823     145711.5      0.2      5.8              for i in range(len(path)):
   188    874502     228088.2      0.3      9.1                  next_i = (i + 1) % len(path)
   189    874502     741773.5      0.8     29.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    874502     171669.6      0.2      6.9                  if increase < best_increase:
   191     52913       7494.5      0.1      0.3                      best_increase = increase
   192     52913      10515.5      0.2      0.4                      best_position = i + 1
   193                                           
   194      1321        600.3      0.5      0.0              path.insert(best_position, to_insert)
   195      1321        416.3      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    873181     198318.6      0.2      7.9              for i, (cost, node) in enumerate(h):
   199    871860     342527.4      0.4     13.7                  if node not in in_path and distances[to_insert, node] < cost:
   200     84459      31357.4      0.4      1.3                      h[i] = (distances[to_insert, node], node)
   201      1321      61670.8     46.7      2.5              heapq.heapify(h)
   202                                           
   203         1         13.0     13.0      0.0          self.tour = path
   204         1        826.9    826.9      0.0          self.calculateCost()

Total time: 5.52401 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.6      0.6      0.0          n = self.numCity
   209         1      60917.3  60917.3      1.1          adj = np.array(self.adj)
   210         1      62498.9  62498.9      1.1          distances = np.array(self.adj)
   211         1          1.4      1.4      0.0          path = [0, 0]
   212                                           
   213         1          1.2      1.2      0.0          minDist = np.inf
   214      1324        204.8      0.2      0.0          for i in range(n):
   215    875826     147763.3      0.2      2.7              for j in range(0, i):
   216    874503     365477.2      0.4      6.6                  if distances[i][j] < minDist:
   217         7          2.6      0.4      0.0                      path[0], path[1] = i, j
   218         7          2.9      0.4      0.0                      minDist = distances[i][j]
   219         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          1.2      1.2      0.0          h = []
   222      1322        320.5      0.2      0.0          for i in set(range(n)) - in_path:
   223      1321       1365.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1321        598.1      0.5      0.0              h.append((cost, i, path[0], path[1]))
   225         1         75.7     75.7      0.0          heapq.heapify(h)
   226                                           
   227      1322        599.2      0.5      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1321       1028.4      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1321        385.1      0.3      0.0              best_increase = np.inf
   233      1321        307.3      0.2      0.0              best_pos = None
   234    875823     141097.5      0.2      2.6              for i in range(len(path)):
   235    874502     228643.0      0.3      4.1                  next_i = (i + 1) % len(path)
   236    874502     757697.3      0.9     13.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    874502     180272.6      0.2      3.3                  if increase < best_increase:
   238     46341       6690.9      0.1      0.1                      best_increase = increase
   239     46341       8100.5      0.2      0.1                      best_pos = next_i
   240                                           
   241      1321        656.4      0.5      0.0              path.insert(best_pos, to_ins)
   242      1321        430.4      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    873181     213994.8      0.2      3.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    871860     351340.3      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       841        190.0      0.2      0.0                      best_cost = np.inf
   251       841        164.6      0.2      0.0                      posL, posR = -1, -1
   252    154764      27786.1      0.2      0.5                      for i2 in range(len(path)):
   253    153923      41863.5      0.3      0.8                          next_i = (i2 + 1) % len(path)
   254    153923     157946.7      1.0      2.9                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    153923      32240.1      0.2      0.6                          if best_cost > insertion_cost:
   256      9022       2212.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       841        216.4      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    871860    1218265.7      1.4     22.1                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     50669      61734.6      1.2      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     50669      20585.3      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     50669      13010.8      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266    871860    1258687.9      1.4     22.8                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     56374      69530.6      1.2      1.3                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     56374      27729.7      0.5      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1321      60528.1     45.8      1.1              heapq.heapify(h)
   270                                           
   271         1         12.4     12.4      0.0          self.tour = path
   272         1        826.6    826.6      0.0          self.calculateCost()

Total time: 2.61169 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.8      0.8      0.0          n = self.numCity
   277         1      60649.9  60649.9      2.3          distances = np.array(self.adj)
   278         1          1.2      1.2      0.0          path = [0, 0]
   279                                           
   280         1          0.4      0.4      0.0          maxDist = 0
   281      1324        194.8      0.1      0.0          for i in range(n):
   282    875826     143034.6      0.2      5.5              for j in range(0, i):
   283    874503     365035.5      0.4     14.0                  if distances[i][j] > maxDist:
   284        20          6.4      0.3      0.0                      path[0], path[1] = i, j
   285        20          7.7      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.7      0.7      0.0          h = []
   291      1322        243.1      0.2      0.0          for i in set(range(n)) - in_path:
   292      1321        929.7      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         81.0     81.0      0.0          heapq.heapify(h)
   294                                           
   295      1322        517.3      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1321        958.4      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1321        348.5      0.3      0.0              best_increase = np.inf
   301      1321        216.5      0.2      0.0              best_position = None
   302    875823     142594.5      0.2      5.5              for i in range(len(path)):
   303    874502     226267.5      0.3      8.7                  next_i = (i + 1) % len(path)
   304    874502     714863.4      0.8     27.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    874502     171442.0      0.2      6.6                  if increase < best_increase:
   306     51539       7596.0      0.1      0.3                      best_increase = increase
   307     51539       9739.8      0.2      0.4                      best_position = i + 1
   308                                           
   309      1321        604.9      0.5      0.0              path.insert(best_position, to_insert)
   310      1321        395.3      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    873181     188909.3      0.2      7.2              for i, (cost, node) in enumerate(h):
   314    871860     179357.8      0.2      6.9                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    871860     337561.0      0.4     12.9                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1321      59296.0     44.9      2.3              heapq.heapify(h)
   319                                           
   320         1         12.6     12.6      0.0          self.tour = path
   321         1        823.4    823.4      0.0          self.calculateCost()

Total time: 5.27269 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.4      0.4      0.0          n = self.numCity
   326         1      61132.5  61132.5      1.2          adj = np.array(self.adj)
   327         1      62669.5  62669.5      1.2          distances = np.array(self.adj)
   328         1          1.2      1.2      0.0          path = [0, 0]
   329                                           
   330         1          0.1      0.1      0.0          maxDist = 0
   331      1324        193.0      0.1      0.0          for i in range(n):
   332    875826     138025.8      0.2      2.6              for j in range(0, i):
   333    874503     352741.6      0.4      6.7                  if distances[i][j] > maxDist:
   334        20          5.8      0.3      0.0                      path[0], path[1] = i, j
   335        20          7.7      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.8      0.8      0.0          h = []
   339      1322        238.5      0.2      0.0          for i in set(range(n)) - in_path:
   340      1321       1485.9      1.1      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1321        542.8      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         82.3     82.3      0.0          heapq.heapify(h)
   343                                           
   344      1322        515.1      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1321       1001.2      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1321        334.7      0.3      0.0              best_increase = np.inf
   350      1321        200.3      0.2      0.0              best_pos = None
   351    875823     138210.6      0.2      2.6              for i in range(len(path)):
   352    874502     220386.4      0.3      4.2                  next_i = (i + 1) % len(path)
   353    874502     718078.3      0.8     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    874502     163206.7      0.2      3.1                  if increase < best_increase:
   355     59466       8745.1      0.1      0.2                      best_increase = increase
   356     59466       9306.4      0.2      0.2                      best_pos = next_i
   357                                           
   358      1321        604.3      0.5      0.0              path.insert(best_pos, to_ins)
   359      1321        374.7      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    873181     211028.4      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    871860     190259.0      0.2      3.6                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    871860     325620.4      0.4      6.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       303         78.0      0.3      0.0                      best_cost = np.inf
   367       303         54.5      0.2      0.0                      posL, posR = -1, -1
   368    109018      17185.9      0.2      0.3                      for i2 in range(len(path)):
   369    108715      27207.8      0.3      0.5                          next_i = (i2 + 1) % len(path)
   370    108715     108225.5      1.0      2.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    108715      21701.6      0.2      0.4                          if best_cost > insertion_cost:
   372      9384       2040.1      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       303        100.1      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    871860    1189050.9      1.4     22.6                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       646        790.3      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       646        277.6      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       646        183.9      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    871860    1234379.3      1.4     23.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      2929       3651.7      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      2929       1320.7      0.5      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1321      60610.3     45.9      1.1              heapq.heapify(h)
   386                                           
   387         1         12.5     12.5      0.0          self.tour = path
   388         1        823.3    823.3      0.0          self.calculateCost()


Optimal 20127
_________________
fl1400
randomInsertion 1.0698589297152599
nearestInsertion 1.2080563536350817
cheapestInsertion 1.1825123594545375
nearestNeighbor 1.3652097742596425
farthestInsertion 1.2073589247226721
furthestInsertion 1.1034108135372587

[('fl1400', 1.0698589297152599, 1.2080563536350817, 1.1825123594545375, 1.3652097742596425, 1.2073589247226721, 1.1034108135372587)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.46271 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.0      1.0      0.0          n = self.numCity
   115         1      70169.2  70169.2      4.8          distances = np.array(self.adj)
   116         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.8      1.8      0.0          in_path = {0}
   118         1        121.6    121.6      0.0          notInPath = [x for x in range(1, n)]
   119         1       1475.2   1475.2      0.1          random.shuffle(notInPath)
   120                                           
   121      1400        426.9      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1399        329.3      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1399        337.8      0.2      0.0              best_increase = np.inf
   127      1399        190.8      0.1      0.0              best_position = None
   128    980699     152595.1      0.2     10.4              for i in range(len(path)):
   129    979300     240880.8      0.2     16.5                  next_i = (i + 1) % len(path)
   130    979300     778299.2      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131    979300     184256.8      0.2     12.6                  if increase < best_increase:
   132    105004      14967.4      0.1      1.0                      best_increase = increase
   133    105004      16740.9      0.2      1.1                      best_position = next_i
   134                                           
   135      1399        618.3      0.4      0.0              path.insert(best_position, to_insert)
   136      1399        459.4      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.7      4.7      0.0          self.tour = path
   139         1        830.8    830.8      0.1          self.calculateCost()

Total time: 0.482008 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          6.5      6.5      0.0          self.tour = [0]
   144         1          1.0      1.0      0.0          visited = set([0])
   145         1         24.9     24.9      0.0          notVisited = set(range(1, self.numCity))
   146      1400        525.7      0.4      0.1          while len(self.tour) < self.numCity:
   147      1399        317.9      0.2      0.1              cost = np.inf
   148      1399        195.4      0.1      0.0              j = -1
   149    980699     158896.4      0.2     33.0              for j2 in notVisited:
   150    979300     312062.8      0.3     64.7                  if self.adj[self.tour[-1]][j2] < cost:
   151     20812       5049.6      0.2      1.0                      cost = self.adj[self.tour[-1]][j2]
   152     20812       2964.3      0.1      0.6                      j = j2
   153      1399        497.2      0.4      0.1              self.tour.append(j)
   154      1399        364.7      0.3      0.1              visited.add(j)
   155      1399        337.9      0.2      0.1              notVisited.remove(j)
   156         1        764.1    764.1      0.2          self.calculateCost()

Total time: 2.64027 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          1.1      1.1      0.0          n = self.numCity
   162         1      70028.7  70028.7      2.7          distances = np.array(self.adj)
   163         1          1.2      1.2      0.0          path = [0, 0]
   164                                           
   165         1          1.3      1.3      0.0          minDist = np.inf
   166      1401        224.2      0.2      0.0          for i in range(n):
   167    980700     156099.8      0.2      5.9              for j in range(0, i):
   168    979300     372145.8      0.4     14.1                  if distances[i][j] < minDist:
   169        12          4.1      0.3      0.0                      path[0], path[1] = i, j
   170        12          4.5      0.4      0.0                      minDist = distances[i][j]
   171         1          2.2      2.2      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          1.0      1.0      0.0          h = []
   176      1399        307.2      0.2      0.0          for i in set(range(n)) - in_path:
   177      1398       2999.6      2.1      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         88.6     88.6      0.0          heapq.heapify(h)
   179                                           
   180      1399        566.0      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1398       1028.7      0.7      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1398        353.1      0.3      0.0              best_increase = np.inf
   186      1398        195.4      0.1      0.0              best_position = None
   187    980697     154217.0      0.2      5.8              for i in range(len(path)):
   188    979299     243232.0      0.2      9.2                  next_i = (i + 1) % len(path)
   189    979299     772774.4      0.8     29.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190    979299     185427.3      0.2      7.0                  if increase < best_increase:
   191     54897       7846.1      0.1      0.3                      best_increase = increase
   192     54897      10324.8      0.2      0.4                      best_position = i + 1
   193                                           
   194      1398        780.6      0.6      0.0              path.insert(best_position, to_insert)
   195      1398        421.3      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198    977901     205024.8      0.2      7.8              for i, (cost, node) in enumerate(h):
   199    976503     357442.1      0.4     13.5                  if node not in in_path and distances[to_insert, node] < cost:
   200     85181      29514.6      0.3      1.1                      h[i] = (distances[to_insert, node], node)
   201      1398      68375.6     48.9      2.6              heapq.heapify(h)
   202                                           
   203         1         12.7     12.7      0.0          self.tour = path
   204         1        828.2    828.2      0.0          self.calculateCost()

Total time: 5.77212 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.4      0.4      0.0          n = self.numCity
   209         1      68419.1  68419.1      1.2          adj = np.array(self.adj)
   210         1      70058.9  70058.9      1.2          distances = np.array(self.adj)
   211         1          1.1      1.1      0.0          path = [0, 0]
   212                                           
   213         1          1.9      1.9      0.0          minDist = np.inf
   214      1401        206.8      0.1      0.0          for i in range(n):
   215    980700     158136.0      0.2      2.7              for j in range(0, i):
   216    979300     366138.9      0.4      6.3                  if distances[i][j] < minDist:
   217        12          4.0      0.3      0.0                      path[0], path[1] = i, j
   218        12          4.4      0.4      0.0                      minDist = distances[i][j]
   219         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222      1399        320.6      0.2      0.0          for i in set(range(n)) - in_path:
   223      1398       1441.1      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1398        571.2      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         88.5     88.5      0.0          heapq.heapify(h)
   226                                           
   227      1399        664.3      0.5      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1398       1218.0      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1398        397.6      0.3      0.0              best_increase = np.inf
   233      1398        258.2      0.2      0.0              best_pos = None
   234    980697     162005.2      0.2      2.8              for i in range(len(path)):
   235    979299     247367.2      0.3      4.3                  next_i = (i + 1) % len(path)
   236    979299     780240.3      0.8     13.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237    979299     192799.6      0.2      3.3                  if increase < best_increase:
   238     68543       9937.5      0.1      0.2                      best_increase = increase
   239     68543      10984.8      0.2      0.2                      best_pos = next_i
   240                                           
   241      1398        911.4      0.7      0.0              path.insert(best_pos, to_ins)
   242      1398        461.7      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247    977901     241726.0      0.2      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249    976503     368921.3      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      1126        238.9      0.2      0.0                      best_cost = np.inf
   251      1126        174.7      0.2      0.0                      posL, posR = -1, -1
   252    166618      27264.9      0.2      0.5                      for i2 in range(len(path)):
   253    165492      41432.8      0.3      0.7                          next_i = (i2 + 1) % len(path)
   254    165492     159887.4      1.0      2.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    165492      30947.9      0.2      0.5                          if best_cost > insertion_cost:
   256     15567       3286.9      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      1126        303.6      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260    976503    1243174.7      1.3     21.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     56706      63841.1      1.1      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     56706      22647.1      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     56706      14333.5      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266    976503    1297889.9      1.3     22.5                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     69469      81166.1      1.2      1.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     69469      32096.2      0.5      0.6                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1398      69302.7     49.6      1.2              heapq.heapify(h)
   270                                           
   271         1         12.0     12.0      0.0          self.tour = path
   272         1        830.8    830.8      0.0          self.calculateCost()

Total time: 2.75756 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.8      0.8      0.0          n = self.numCity
   277         1      67829.1  67829.1      2.5          distances = np.array(self.adj)
   278         1          1.3      1.3      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281      1401        185.8      0.1      0.0          for i in range(n):
   282    980700     151304.7      0.2      5.5              for j in range(0, i):
   283    979300     361079.3      0.4     13.1                  if distances[i][j] > maxDist:
   284         4          1.9      0.5      0.0                      path[0], path[1] = i, j
   285         4          1.6      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.6      0.6      0.0          h = []
   291      1399        242.3      0.2      0.0          for i in set(range(n)) - in_path:
   292      1398        941.4      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         83.0     83.0      0.0          heapq.heapify(h)
   294                                           
   295      1399        580.5      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1398       1027.5      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1398        341.0      0.2      0.0              best_increase = np.inf
   301      1398        202.8      0.1      0.0              best_position = None
   302    980697     152013.7      0.2      5.5              for i in range(len(path)):
   303    979299     236066.3      0.2      8.6                  next_i = (i + 1) % len(path)
   304    979299     751121.2      0.8     27.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305    979299     185981.9      0.2      6.7                  if increase < best_increase:
   306     64154       8507.2      0.1      0.3                      best_increase = increase
   307     64154      12248.3      0.2      0.4                      best_position = i + 1
   308                                           
   309      1398        671.5      0.5      0.0              path.insert(best_position, to_insert)
   310      1398        395.5      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313    977901     193820.6      0.2      7.0              for i, (cost, node) in enumerate(h):
   314    976503     191416.1      0.2      6.9                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316    976503     372701.4      0.4     13.5                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1398      67966.5     48.6      2.5              heapq.heapify(h)
   319                                           
   320         1         11.9     11.9      0.0          self.tour = path
   321         1        809.0    809.0      0.0          self.calculateCost()

Total time: 5.71524 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.4      0.4      0.0          n = self.numCity
   326         1      67510.2  67510.2      1.2          adj = np.array(self.adj)
   327         1      68643.3  68643.3      1.2          distances = np.array(self.adj)
   328         1          1.7      1.7      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331      1401        214.0      0.2      0.0          for i in range(n):
   332    980700     147949.5      0.2      2.6              for j in range(0, i):
   333    979300     359110.3      0.4      6.3                  if distances[i][j] > maxDist:
   334         4          2.2      0.6      0.0                      path[0], path[1] = i, j
   335         4          2.3      0.6      0.0                      maxDist = distances[i][j]
   336         1          1.3      1.3      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339      1399        247.4      0.2      0.0          for i in set(range(n)) - in_path:
   340      1398       1342.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1398        512.2      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         82.7     82.7      0.0          heapq.heapify(h)
   343                                           
   344      1399        547.3      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1398       1063.1      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1398        322.4      0.2      0.0              best_increase = np.inf
   350      1398        209.2      0.1      0.0              best_pos = None
   351    980697     146981.9      0.1      2.6              for i in range(len(path)):
   352    979299     234082.5      0.2      4.1                  next_i = (i + 1) % len(path)
   353    979299     778896.2      0.8     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354    979299     176661.8      0.2      3.1                  if increase < best_increase:
   355    103523      14263.1      0.1      0.2                      best_increase = increase
   356    103523      15716.5      0.2      0.3                      best_pos = next_i
   357                                           
   358      1398        663.3      0.5      0.0              path.insert(best_pos, to_ins)
   359      1398        412.0      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362    977901     236060.4      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363    976503     202091.9      0.2      3.5                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365    976503     361545.4      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       750        156.7      0.2      0.0                      best_cost = np.inf
   367       750        130.8      0.2      0.0                      posL, posR = -1, -1
   368    146500      22594.1      0.2      0.4                      for i2 in range(len(path)):
   369    145750      34509.9      0.2      0.6                          next_i = (i2 + 1) % len(path)
   370    145750     144238.2      1.0      2.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    145750      26835.4      0.2      0.5                          if best_cost > insertion_cost:
   372     18477       3935.0      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       750        249.8      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376    976503    1259861.9      1.3     22.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377      1740       2078.4      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378      1740        702.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381      1740        441.4      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382    976503    1328379.5      1.4     23.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      4152       4921.4      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      4152       1914.2      0.5      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1398      68308.8     48.9      1.2              heapq.heapify(h)
   386                                           
   387         1         13.3     13.3      0.0          self.tour = path
   388         1        828.2    828.2      0.0          self.calculateCost()


Optimal 152970
_________________
u1432
randomInsertion 1.1356784745558097
nearestInsertion 1.1483952463134723
cheapestInsertion 1.2072385048587797
nearestNeighbor 1.2343270596893654
farthestInsertion 1.2223201267519017
furthestInsertion 1.155013962784275

[('u1432', 1.1356784745558097, 1.1483952463134723, 1.2072385048587797, 1.2343270596893654, 1.2223201267519017, 1.155013962784275)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.57347 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.8      0.8      0.0          n = self.numCity
   115         1      72715.3  72715.3      4.6          distances = np.array(self.adj)
   116         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.2      1.2      0.0          in_path = {0}
   118         1        125.3    125.3      0.0          notInPath = [x for x in range(1, n)]
   119         1       1496.2   1496.2      0.1          random.shuffle(notInPath)
   120                                           
   121      1432        477.1      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1431        325.5      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1431        335.1      0.2      0.0              best_increase = np.inf
   127      1431        203.0      0.1      0.0              best_position = None
   128   1026027     173818.6      0.2     11.0              for i in range(len(path)):
   129   1024596     255020.6      0.2     16.2                  next_i = (i + 1) % len(path)
   130   1024596     841954.0      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   1024596     210555.3      0.2     13.4                  if increase < best_increase:
   132     46657       6633.7      0.1      0.4                      best_increase = increase
   133     46657       7822.1      0.2      0.5                      best_position = next_i
   134                                           
   135      1431        650.2      0.5      0.0              path.insert(best_position, to_insert)
   136      1431        488.8      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.2      4.2      0.0          self.tour = path
   139         1        840.3    840.3      0.1          self.calculateCost()

Total time: 0.511193 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          6.6      6.6      0.0          self.tour = [0]
   144         1          1.5      1.5      0.0          visited = set([0])
   145         1         26.7     26.7      0.0          notVisited = set(range(1, self.numCity))
   146      1432        586.7      0.4      0.1          while len(self.tour) < self.numCity:
   147      1431        330.2      0.2      0.1              cost = np.inf
   148      1431        191.6      0.1      0.0              j = -1
   149   1026027     167460.0      0.2     32.8              for j2 in notVisited:
   150   1024596     327752.8      0.3     64.1                  if self.adj[self.tour[-1]][j2] < cost:
   151     31765       7958.1      0.3      1.6                      cost = self.adj[self.tour[-1]][j2]
   152     31765       4722.9      0.1      0.9                      j = j2
   153      1431        572.1      0.4      0.1              self.tour.append(j)
   154      1431        398.3      0.3      0.1              visited.add(j)
   155      1431        407.4      0.3      0.1              notVisited.remove(j)
   156         1        778.4    778.4      0.2          self.calculateCost()

Total time: 2.82328 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          1.2      1.2      0.0          n = self.numCity
   162         1      72507.5  72507.5      2.6          distances = np.array(self.adj)
   163         1          1.3      1.3      0.0          path = [0, 0]
   164                                           
   165         1          1.4      1.4      0.0          minDist = np.inf
   166      1433        215.3      0.2      0.0          for i in range(n):
   167   1026028     169927.2      0.2      6.0              for j in range(0, i):
   168   1024596     402126.5      0.4     14.2                  if distances[i][j] < minDist:
   169         2          0.9      0.5      0.0                      path[0], path[1] = i, j
   170         2          0.9      0.4      0.0                      minDist = distances[i][j]
   171         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.9      0.9      0.0          h = []
   176      1431        335.2      0.2      0.0          for i in set(range(n)) - in_path:
   177      1430       3731.1      2.6      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1         94.1     94.1      0.0          heapq.heapify(h)
   179                                           
   180      1431        543.8      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1430       1117.5      0.8      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1430        366.4      0.3      0.0              best_increase = np.inf
   186      1430        255.4      0.2      0.0              best_position = None
   187   1026025     176260.6      0.2      6.2              for i in range(len(path)):
   188   1024595     256267.4      0.3      9.1                  next_i = (i + 1) % len(path)
   189   1024595     828904.1      0.8     29.4                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   1024595     210786.0      0.2      7.5                  if increase < best_increase:
   191     53106       7926.3      0.1      0.3                      best_increase = increase
   192     53106      10594.1      0.2      0.4                      best_position = i + 1
   193                                           
   194      1430        714.8      0.5      0.0              path.insert(best_position, to_insert)
   195      1430        401.4      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   1023165     215482.1      0.2      7.6              for i, (cost, node) in enumerate(h):
   199   1021735     369262.6      0.4     13.1                  if node not in in_path and distances[to_insert, node] < cost:
   200     68526      23172.0      0.3      0.8                      h[i] = (distances[to_insert, node], node)
   201      1430      71475.5     50.0      2.5              heapq.heapify(h)
   202                                           
   203         1         11.6     11.6      0.0          self.tour = path
   204         1        791.5    791.5      0.0          self.calculateCost()

Total time: 6.22473 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.7      0.7      0.0          n = self.numCity
   209         1      72415.6  72415.6      1.2          adj = np.array(self.adj)
   210         1      73100.9  73100.9      1.2          distances = np.array(self.adj)
   211         1          1.2      1.2      0.0          path = [0, 0]
   212                                           
   213         1          2.3      2.3      0.0          minDist = np.inf
   214      1433        219.7      0.2      0.0          for i in range(n):
   215   1026028     174409.7      0.2      2.8              for j in range(0, i):
   216   1024596     420696.1      0.4      6.8                  if distances[i][j] < minDist:
   217         2          1.4      0.7      0.0                      path[0], path[1] = i, j
   218         2          0.9      0.4      0.0                      minDist = distances[i][j]
   219         1          1.9      1.9      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222      1431        342.3      0.2      0.0          for i in set(range(n)) - in_path:
   223      1430       1515.0      1.1      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1430        593.1      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1         94.1     94.1      0.0          heapq.heapify(h)
   226                                           
   227      1431        664.1      0.5      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1430       1177.6      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1430        426.8      0.3      0.0              best_increase = np.inf
   233      1430        270.8      0.2      0.0              best_pos = None
   234   1026025     176020.3      0.2      2.8              for i in range(len(path)):
   235   1024595     258919.5      0.3      4.2                  next_i = (i + 1) % len(path)
   236   1024595     866481.1      0.8     13.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   1024595     213315.4      0.2      3.4                  if increase < best_increase:
   238     67013      10068.7      0.2      0.2                      best_increase = increase
   239     67013      11210.1      0.2      0.2                      best_pos = next_i
   240                                           
   241      1430        761.0      0.5      0.0              path.insert(best_pos, to_ins)
   242      1430        407.5      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   1023165     260000.2      0.3      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   1021735     406284.5      0.4      6.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       880        194.8      0.2      0.0                      best_cost = np.inf
   251       880        159.1      0.2      0.0                      posL, posR = -1, -1
   252    153851      26082.0      0.2      0.4                      for i2 in range(len(path)):
   253    152971      38563.8      0.3      0.6                          next_i = (i2 + 1) % len(path)
   254    152971     156677.4      1.0      2.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    152971      30949.8      0.2      0.5                          if best_cost > insertion_cost:
   256     11334       2681.7      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       880        244.3      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   1021735    1353710.9      1.3     21.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     45112      55032.9      1.2      0.9                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     45112      18821.8      0.4      0.3                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     45112      11723.4      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266   1021735    1413831.9      1.4     22.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     54295      66793.7      1.2      1.1                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     54295      26516.6      0.5      0.4                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1430      72540.7     50.7      1.2              heapq.heapify(h)
   270                                           
   271         1         11.2     11.2      0.0          self.tour = path
   272         1        788.8    788.8      0.0          self.calculateCost()

Total time: 3.04586 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1      72004.9  72004.9      2.4          distances = np.array(self.adj)
   278         1          1.3      1.3      0.0          path = [0, 0]
   279                                           
   280         1          0.3      0.3      0.0          maxDist = 0
   281      1433        210.6      0.1      0.0          for i in range(n):
   282   1026028     169950.0      0.2      5.6              for j in range(0, i):
   283   1024596     412663.9      0.4     13.5                  if distances[i][j] > maxDist:
   284       155         37.3      0.2      0.0                      path[0], path[1] = i, j
   285       155         55.0      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.8      0.8      0.0          h = []
   291      1431        265.8      0.2      0.0          for i in set(range(n)) - in_path:
   292      1430        997.7      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         88.9     88.9      0.0          heapq.heapify(h)
   294                                           
   295      1431        526.5      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1430       1086.2      0.8      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1430        361.6      0.3      0.0              best_increase = np.inf
   301      1430        244.1      0.2      0.0              best_position = None
   302   1026025     169378.8      0.2      5.6              for i in range(len(path)):
   303   1024595     259652.7      0.3      8.5                  next_i = (i + 1) % len(path)
   304   1024595     831325.4      0.8     27.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   1024595     210022.0      0.2      6.9                  if increase < best_increase:
   306     50961       7262.8      0.1      0.2                      best_increase = increase
   307     50961       9880.1      0.2      0.3                      best_position = i + 1
   308                                           
   309      1430        688.0      0.5      0.0              path.insert(best_position, to_insert)
   310      1430        416.7      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   1023165     214828.8      0.2      7.1              for i, (cost, node) in enumerate(h):
   314   1021735     207113.6      0.2      6.8                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   1021735     403550.2      0.4     13.2                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1430      72440.6     50.7      2.4              heapq.heapify(h)
   319                                           
   320         1         11.4     11.4      0.0          self.tour = path
   321         1        792.3    792.3      0.0          self.calculateCost()

Total time: 6.23536 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.8      0.8      0.0          n = self.numCity
   326         1      71725.3  71725.3      1.2          adj = np.array(self.adj)
   327         1      73632.5  73632.5      1.2          distances = np.array(self.adj)
   328         1          1.3      1.3      0.0          path = [0, 0]
   329                                           
   330         1          0.1      0.1      0.0          maxDist = 0
   331      1433        227.5      0.2      0.0          for i in range(n):
   332   1026028     166591.6      0.2      2.7              for j in range(0, i):
   333   1024596     410166.1      0.4      6.6                  if distances[i][j] > maxDist:
   334       155         36.9      0.2      0.0                      path[0], path[1] = i, j
   335       155         56.2      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.9      1.9      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.7      0.7      0.0          h = []
   339      1431        288.3      0.2      0.0          for i in set(range(n)) - in_path:
   340      1430       1524.5      1.1      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1430        590.1      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         90.3     90.3      0.0          heapq.heapify(h)
   343                                           
   344      1431        633.6      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1430       1156.4      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1430        393.9      0.3      0.0              best_increase = np.inf
   350      1430        265.3      0.2      0.0              best_pos = None
   351   1026025     168189.7      0.2      2.7              for i in range(len(path)):
   352   1024595     255343.7      0.2      4.1                  next_i = (i + 1) % len(path)
   353   1024595     850122.4      0.8     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   1024595     210511.9      0.2      3.4                  if increase < best_increase:
   355     59730       8446.8      0.1      0.1                      best_increase = increase
   356     59730       9851.0      0.2      0.2                      best_pos = next_i
   357                                           
   358      1430        681.5      0.5      0.0              path.insert(best_pos, to_ins)
   359      1430        406.9      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   1023165     267969.6      0.3      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   1021735     237345.9      0.2      3.8                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   1021735     389988.5      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       423        106.2      0.3      0.0                      best_cost = np.inf
   367       423         73.8      0.2      0.0                      posL, posR = -1, -1
   368    142568      23404.2      0.2      0.4                      for i2 in range(len(path)):
   369    142145      34979.2      0.2      0.6                          next_i = (i2 + 1) % len(path)
   370    142145     144292.3      1.0      2.3                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    142145      28049.9      0.2      0.4                          if best_cost > insertion_cost:
   372     10438       2203.4      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       423        146.4      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   1021735    1381173.1      1.4     22.2                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       546        678.9      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       546        228.3      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       546        135.6      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   1021735    1414377.5      1.4     22.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      3168       3952.5      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      3168       1530.6      0.5      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1430      72979.3     51.0      1.2              heapq.heapify(h)
   386                                           
   387         1         12.0     12.0      0.0          self.tour = path
   388         1        793.8    793.8      0.0          self.calculateCost()


Optimal 22249
_________________
fl1577
randomInsertion 1.1848840539413987
nearestInsertion 1.2305807801146789
cheapestInsertion 1.2215374358295787
nearestNeighbor 1.3330069924091936
farthestInsertion 1.2273605418469855
furthestInsertion 1.1949572551928174

[('fl1577', 1.1848840539413987, 1.2305807801146789, 1.2215374358295787, 1.3330069924091936, 1.2273605418469855, 1.1949572551928174)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 1.87422 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.0      1.0      0.0          n = self.numCity
   115         1      89551.4  89551.4      4.8          distances = np.array(self.adj)
   116         1          1.4      1.4      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.2      1.2      0.0          in_path = {0}
   118         1        145.5    145.5      0.0          notInPath = [x for x in range(1, n)]
   119         1       1610.1   1610.1      0.1          random.shuffle(notInPath)
   120                                           
   121      1577        467.7      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1576        318.2      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1576        399.1      0.3      0.0              best_increase = np.inf
   127      1576        250.5      0.2      0.0              best_position = None
   128   1244252     211422.3      0.2     11.3              for i in range(len(path)):
   129   1242676     324962.1      0.3     17.3                  next_i = (i + 1) % len(path)
   130   1242676     990636.5      0.8     52.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   1242676     232430.0      0.2     12.4                  if increase < best_increase:
   132     67642       9411.8      0.1      0.5                      best_increase = increase
   133     67642      10461.7      0.2      0.6                      best_position = next_i
   134                                           
   135      1576        735.0      0.5      0.0              path.insert(best_position, to_insert)
   136      1576        518.5      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.4      4.4      0.0          self.tour = path
   139         1        887.4    887.4      0.0          self.calculateCost()

Total time: 0.605175 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          7.5      7.5      0.0          self.tour = [0]
   144         1          2.1      2.1      0.0          visited = set([0])
   145         1         27.2     27.2      0.0          notVisited = set(range(1, self.numCity))
   146      1577        650.9      0.4      0.1          while len(self.tour) < self.numCity:
   147      1576        344.2      0.2      0.1              cost = np.inf
   148      1576        218.7      0.1      0.0              j = -1
   149   1244252     196888.9      0.2     32.5              for j2 in notVisited:
   150   1242676     391955.9      0.3     64.8                  if self.adj[self.tour[-1]][j2] < cost:
   151     33969       7948.3      0.2      1.3                      cost = self.adj[self.tour[-1]][j2]
   152     33969       4860.3      0.1      0.8                      j = j2
   153      1576        575.3      0.4      0.1              self.tour.append(j)
   154      1576        449.0      0.3      0.1              visited.add(j)
   155      1576        425.3      0.3      0.1              notVisited.remove(j)
   156         1        821.1    821.1      0.1          self.calculateCost()

Total time: 3.40691 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.6      0.6      0.0          n = self.numCity
   162         1      90093.0  90093.0      2.6          distances = np.array(self.adj)
   163         1          1.8      1.8      0.0          path = [0, 0]
   164                                           
   165         1          1.1      1.1      0.0          minDist = np.inf
   166      1578        226.9      0.1      0.0          for i in range(n):
   167   1244253     200777.7      0.2      5.9              for j in range(0, i):
   168   1242676     514028.6      0.4     15.1                  if distances[i][j] < minDist:
   169         4          1.4      0.4      0.0                      path[0], path[1] = i, j
   170         4          1.6      0.4      0.0                      minDist = distances[i][j]
   171         1          1.8      1.8      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.9      0.9      0.0          h = []
   176      1576        369.5      0.2      0.0          for i in set(range(n)) - in_path:
   177      1575       7468.9      4.7      0.2              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        102.7    102.7      0.0          heapq.heapify(h)
   179                                           
   180      1576        572.8      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1575       1180.1      0.7      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1575        391.2      0.2      0.0              best_increase = np.inf
   186      1575        243.7      0.2      0.0              best_position = None
   187   1244250     197656.4      0.2      5.8              for i in range(len(path)):
   188   1242675     305702.3      0.2      9.0                  next_i = (i + 1) % len(path)
   189   1242675     963245.6      0.8     28.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   1242675     236130.2      0.2      6.9                  if increase < best_increase:
   191     83846      11551.2      0.1      0.3                      best_increase = increase
   192     83846      16136.3      0.2      0.5                      best_position = i + 1
   193                                           
   194      1575        813.0      0.5      0.0              path.insert(best_position, to_insert)
   195      1575        425.2      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   1241100     261133.0      0.2      7.7              for i, (cost, node) in enumerate(h):
   199   1239525     451654.9      0.4     13.3                  if node not in in_path and distances[to_insert, node] < cost:
   200    182074      60573.1      0.3      1.8                      h[i] = (distances[to_insert, node], node)
   201      1575      85530.4     54.3      2.5              heapq.heapify(h)
   202                                           
   203         1         15.0     15.0      0.0          self.tour = path
   204         1        878.7    878.7      0.0          self.calculateCost()

Total time: 7.49616 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.6      0.6      0.0          n = self.numCity
   209         1      87822.4  87822.4      1.2          adj = np.array(self.adj)
   210         1      89534.4  89534.4      1.2          distances = np.array(self.adj)
   211         1          1.3      1.3      0.0          path = [0, 0]
   212                                           
   213         1          1.2      1.2      0.0          minDist = np.inf
   214      1578        228.0      0.1      0.0          for i in range(n):
   215   1244253     205119.5      0.2      2.7              for j in range(0, i):
   216   1242676     511489.2      0.4      6.8                  if distances[i][j] < minDist:
   217         4          1.3      0.3      0.0                      path[0], path[1] = i, j
   218         4          1.7      0.4      0.0                      minDist = distances[i][j]
   219         1          1.9      1.9      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222      1576        350.5      0.2      0.0          for i in set(range(n)) - in_path:
   223      1575       1590.0      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1575        621.7      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1        103.9    103.9      0.0          heapq.heapify(h)
   226                                           
   227      1576        668.7      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1575       1247.3      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1575        404.6      0.3      0.0              best_increase = np.inf
   233      1575        270.8      0.2      0.0              best_pos = None
   234   1244250     199251.3      0.2      2.7              for i in range(len(path)):
   235   1242675     311399.6      0.3      4.2                  next_i = (i + 1) % len(path)
   236   1242675     959832.1      0.8     12.8                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   1242675     235988.5      0.2      3.1                  if increase < best_increase:
   238     92696      13772.2      0.1      0.2                      best_increase = increase
   239     92696      15302.8      0.2      0.2                      best_pos = next_i
   240                                           
   241      1575        878.3      0.6      0.0              path.insert(best_pos, to_ins)
   242      1575        446.8      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   1241100     303668.9      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   1239525     458789.8      0.4      6.1                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250       816        216.7      0.3      0.0                      best_cost = np.inf
   251       816        155.0      0.2      0.0                      posL, posR = -1, -1
   252    290623      52325.7      0.2      0.7                      for i2 in range(len(path)):
   253    289807      77132.0      0.3      1.0                          next_i = (i2 + 1) % len(path)
   254    289807     299351.9      1.0      4.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    289807      57800.8      0.2      0.8                          if best_cost > insertion_cost:
   256     21957       4965.0      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257       816        214.0      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   1239525    1601340.0      1.3     21.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     70375      81483.6      1.2      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     70375      27876.9      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     70375      18283.9      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266   1239525    1649921.9      1.3     22.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     84385     100394.7      1.2      1.3                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     84385      38824.6      0.5      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1575      86193.0     54.7      1.1              heapq.heapify(h)
   270                                           
   271         1         13.1     13.1      0.0          self.tour = path
   272         1        881.5    881.5      0.0          self.calculateCost()

Total time: 3.62312 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.6      0.6      0.0          n = self.numCity
   277         1      87456.0  87456.0      2.4          distances = np.array(self.adj)
   278         1          1.0      1.0      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281      1578        229.4      0.1      0.0          for i in range(n):
   282   1244253     208929.1      0.2      5.8              for j in range(0, i):
   283   1242676     504347.3      0.4     13.9                  if distances[i][j] > maxDist:
   284       179         43.5      0.2      0.0                      path[0], path[1] = i, j
   285       179         65.1      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.4      0.4      0.0          h = []
   291      1576        281.7      0.2      0.0          for i in set(range(n)) - in_path:
   292      1575       1088.6      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         93.1     93.1      0.0          heapq.heapify(h)
   294                                           
   295      1576        627.6      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1575       1147.8      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1575        396.5      0.3      0.0              best_increase = np.inf
   301      1575        273.5      0.2      0.0              best_position = None
   302   1244250     205262.5      0.2      5.7              for i in range(len(path)):
   303   1242675     307674.3      0.2      8.5                  next_i = (i + 1) % len(path)
   304   1242675     980505.3      0.8     27.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   1242675     240366.3      0.2      6.6                  if increase < best_increase:
   306     52034       7039.6      0.1      0.2                      best_increase = increase
   307     52034      10057.9      0.2      0.3                      best_position = i + 1
   308                                           
   309      1575        825.9      0.5      0.0              path.insert(best_position, to_insert)
   310      1575        405.5      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   1241100     259262.2      0.2      7.2              for i, (cost, node) in enumerate(h):
   314   1239525     258587.6      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   1239525     463612.6      0.4     12.8                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1575      83550.8     53.0      2.3              heapq.heapify(h)
   319                                           
   320         1         13.0     13.0      0.0          self.tour = path
   321         1        974.6    974.6      0.0          self.calculateCost()

Total time: 7.35646 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.6      0.6      0.0          n = self.numCity
   326         1      87614.0  87614.0      1.2          adj = np.array(self.adj)
   327         1      89690.6  89690.6      1.2          distances = np.array(self.adj)
   328         1          1.4      1.4      0.0          path = [0, 0]
   329                                           
   330         1         15.5     15.5      0.0          maxDist = 0
   331      1578        256.9      0.2      0.0          for i in range(n):
   332   1244253     217092.8      0.2      3.0              for j in range(0, i):
   333   1242676     509593.1      0.4      6.9                  if distances[i][j] > maxDist:
   334       179         43.4      0.2      0.0                      path[0], path[1] = i, j
   335       179         66.0      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.8      0.8      0.0          h = []
   339      1576        315.5      0.2      0.0          for i in set(range(n)) - in_path:
   340      1575       1579.6      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1575        583.4      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1         99.0     99.0      0.0          heapq.heapify(h)
   343                                           
   344      1576        623.7      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1575       1236.4      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1575        409.6      0.3      0.0              best_increase = np.inf
   350      1575        251.2      0.2      0.0              best_pos = None
   351   1244250     203792.8      0.2      2.8              for i in range(len(path)):
   352   1242675     306034.7      0.2      4.2                  next_i = (i + 1) % len(path)
   353   1242675     987034.4      0.8     13.4                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   1242675     233939.7      0.2      3.2                  if increase < best_increase:
   355     76389      10513.0      0.1      0.1                      best_increase = increase
   356     76389      11661.0      0.2      0.2                      best_pos = next_i
   357                                           
   358      1575        863.4      0.5      0.0              path.insert(best_pos, to_ins)
   359      1575        428.3      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   1241100     301067.7      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   1239525     263128.5      0.2      3.6                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   1239525     457848.8      0.4      6.2                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       939        208.5      0.2      0.0                      best_cost = np.inf
   367       939        156.7      0.2      0.0                      posL, posR = -1, -1
   368    182830      30693.5      0.2      0.4                      for i2 in range(len(path)):
   369    181891      44582.1      0.2      0.6                          next_i = (i2 + 1) % len(path)
   370    181891     182116.4      1.0      2.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    181891      34395.9      0.2      0.5                          if best_cost > insertion_cost:
   372     14888       3221.0      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       939        288.2      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   1239525    1614558.8      1.3     21.9                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377      1252       1515.9      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378      1252        485.6      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381      1252        313.4      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   1239525    1661207.5      1.3     22.6                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      3691       4392.2      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      3691       1624.7      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1575      89968.1     57.1      1.2              heapq.heapify(h)
   386                                           
   387         1         11.7     11.7      0.0          self.tour = path
   388         1        930.5    930.5      0.0          self.calculateCost()


Optimal 62128
_________________
d1655
randomInsertion 1.1750102891816934
nearestInsertion 1.2113597825776634
cheapestInsertion 1.217024968476125
nearestNeighbor 1.1975894261002455
farthestInsertion 1.269233617389052
furthestInsertion 1.2282027715395512

[('d1655', 1.1750102891816934, 1.2113597825776634, 1.217024968476125, 1.1975894261002455, 1.269233617389052, 1.2282027715395512)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 2.03416 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.5      1.5      0.0          n = self.numCity
   115         1      98306.7  98306.7      4.8          distances = np.array(self.adj)
   116         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1        126.0    126.0      0.0          notInPath = [x for x in range(1, n)]
   119         1       1696.1   1696.1      0.1          random.shuffle(notInPath)
   120                                           
   121      1655        479.6      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1654        369.1      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1654        388.1      0.2      0.0              best_increase = np.inf
   127      1654        229.6      0.1      0.0              best_position = None
   128   1370339     220753.9      0.2     10.9              for i in range(len(path)):
   129   1368685     332340.1      0.2     16.3                  next_i = (i + 1) % len(path)
   130   1368685    1089580.0      0.8     53.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   1368685     260947.2      0.2     12.8                  if increase < best_increase:
   132     89833      12303.3      0.1      0.6                      best_increase = increase
   133     89833      14361.9      0.2      0.7                      best_position = next_i
   134                                           
   135      1654        759.5      0.5      0.0              path.insert(best_position, to_insert)
   136      1654        569.2      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.3      4.3      0.0          self.tour = path
   139         1        943.9    943.9      0.0          self.calculateCost()

Total time: 0.685871 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          7.0      7.0      0.0          self.tour = [0]
   144         1          1.3      1.3      0.0          visited = set([0])
   145         1         27.1     27.1      0.0          notVisited = set(range(1, self.numCity))
   146      1655        660.8      0.4      0.1          while len(self.tour) < self.numCity:
   147      1654        381.2      0.2      0.1              cost = np.inf
   148      1654        229.7      0.1      0.0              j = -1
   149   1370339     211524.3      0.2     30.8              for j2 in notVisited:
   150   1368685     436337.6      0.3     63.6                  if self.adj[self.tour[-1]][j2] < cost:
   151     84615      20895.5      0.2      3.0                      cost = self.adj[self.tour[-1]][j2]
   152     84615      13434.5      0.2      2.0                      j = j2
   153      1654        574.6      0.3      0.1              self.tour.append(j)
   154      1654        476.2      0.3      0.1              visited.add(j)
   155      1654        431.1      0.3      0.1              notVisited.remove(j)
   156         1        890.2    890.2      0.1          self.calculateCost()

Total time: 3.68398 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.7      0.7      0.0          n = self.numCity
   162         1      98299.8  98299.8      2.7          distances = np.array(self.adj)
   163         1          1.5      1.5      0.0          path = [0, 0]
   164                                           
   165         1          1.4      1.4      0.0          minDist = np.inf
   166      1656        238.9      0.1      0.0          for i in range(n):
   167   1370340     210992.1      0.2      5.7              for j in range(0, i):
   168   1368685     497610.1      0.4     13.5                  if distances[i][j] < minDist:
   169         4          1.7      0.4      0.0                      path[0], path[1] = i, j
   170         4          1.7      0.4      0.0                      minDist = distances[i][j]
   171         1          2.1      2.1      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          1.5      1.5      0.0          h = []
   176      1654        346.5      0.2      0.0          for i in set(range(n)) - in_path:
   177      1653       1301.1      0.8      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        106.9    106.9      0.0          heapq.heapify(h)
   179                                           
   180      1654        653.3      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1653       1286.1      0.8      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1653        434.0      0.3      0.0              best_increase = np.inf
   186      1653        316.7      0.2      0.0              best_position = None
   187   1370337     229873.8      0.2      6.2              for i in range(len(path)):
   188   1368684     344928.7      0.3      9.4                  next_i = (i + 1) % len(path)
   189   1368684    1070948.4      0.8     29.1                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   1368684     273372.0      0.2      7.4                  if increase < best_increase:
   191     96973      13426.3      0.1      0.4                      best_increase = increase
   192     96973      19436.5      0.2      0.5                      best_position = i + 1
   193                                           
   194      1653        796.2      0.5      0.0              path.insert(best_position, to_insert)
   195      1653        476.4      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   1367031     285087.0      0.2      7.7              for i, (cost, node) in enumerate(h):
   199   1365378     489029.4      0.4     13.3                  if node not in in_path and distances[to_insert, node] < cost:
   200    147465      50467.9      0.3      1.4                      h[i] = (distances[to_insert, node], node)
   201      1653      93586.3     56.6      2.5              heapq.heapify(h)
   202                                           
   203         1         12.8     12.8      0.0          self.tour = path
   204         1        945.4    945.4      0.0          self.calculateCost()

Total time: 8.2926 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.7      0.7      0.0          n = self.numCity
   209         1      96252.1  96252.1      1.2          adj = np.array(self.adj)
   210         1      97602.7  97602.7      1.2          distances = np.array(self.adj)
   211         1          0.9      0.9      0.0          path = [0, 0]
   212                                           
   213         1          1.0      1.0      0.0          minDist = np.inf
   214      1656        233.3      0.1      0.0          for i in range(n):
   215   1370340     209054.8      0.2      2.5              for j in range(0, i):
   216   1368685     485962.6      0.4      5.9                  if distances[i][j] < minDist:
   217         4          1.5      0.4      0.0                      path[0], path[1] = i, j
   218         4          1.4      0.4      0.0                      minDist = distances[i][j]
   219         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222      1654        345.5      0.2      0.0          for i in set(range(n)) - in_path:
   223      1653       1703.8      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1653        682.3      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1        107.3    107.3      0.0          heapq.heapify(h)
   226                                           
   227      1654        696.0      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1653       1291.1      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1653        451.7      0.3      0.0              best_increase = np.inf
   233      1653        262.5      0.2      0.0              best_pos = None
   234   1370337     211773.7      0.2      2.6              for i in range(len(path)):
   235   1368684     345961.9      0.3      4.2                  next_i = (i + 1) % len(path)
   236   1368684    1057227.1      0.8     12.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   1368684     263935.9      0.2      3.2                  if increase < best_increase:
   238    107643      14931.6      0.1      0.2                      best_increase = increase
   239    107643      17351.4      0.2      0.2                      best_pos = next_i
   240                                           
   241      1653        800.5      0.5      0.0              path.insert(best_pos, to_ins)
   242      1653        475.0      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   1367031     324453.9      0.2      3.9              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   1365378     530706.1      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      3380        686.1      0.2      0.0                      best_cost = np.inf
   251      3380        515.4      0.2      0.0                      posL, posR = -1, -1
   252    463814      73659.5      0.2      0.9                      for i2 in range(len(path)):
   253    460434     119059.3      0.3      1.4                          next_i = (i2 + 1) % len(path)
   254    460434     429764.1      0.9      5.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    460434      87886.1      0.2      1.1                          if best_cost > insertion_cost:
   256     68574      15959.3      0.2      0.2                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      3380        840.9      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   1365378    1704461.6      1.2     20.6                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     83977      94712.8      1.1      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     83977      31282.1      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     83977      20760.7      0.2      0.3                      best_pos = (best_pos + 1) % (len(path))
   266   1365378    1798749.4      1.3     21.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     97721     112797.8      1.2      1.4                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     97721      43184.7      0.4      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1653      95044.6     57.5      1.1              heapq.heapify(h)
   270                                           
   271         1         13.3     13.3      0.0          self.tour = path
   272         1        951.0    951.0      0.0          self.calculateCost()

Total time: 3.91353 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1      96273.5  96273.5      2.5          distances = np.array(self.adj)
   278         1          1.4      1.4      0.0          path = [0, 0]
   279                                           
   280         1          0.3      0.3      0.0          maxDist = 0
   281      1656        226.6      0.1      0.0          for i in range(n):
   282   1370340     213882.1      0.2      5.5              for j in range(0, i):
   283   1368685     485382.8      0.4     12.4                  if distances[i][j] > maxDist:
   284       128         30.3      0.2      0.0                      path[0], path[1] = i, j
   285       128         42.2      0.3      0.0                      maxDist = distances[i][j]
   286         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          1.0      1.0      0.0          h = []
   291      1654        275.6      0.2      0.0          for i in set(range(n)) - in_path:
   292      1653       1084.8      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1         89.8     89.8      0.0          heapq.heapify(h)
   294                                           
   295      1654        652.1      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1653       1235.9      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1653        417.7      0.3      0.0              best_increase = np.inf
   301      1653        263.7      0.2      0.0              best_position = None
   302   1370337     214741.7      0.2      5.5              for i in range(len(path)):
   303   1368684     339197.0      0.2      8.7                  next_i = (i + 1) % len(path)
   304   1368684    1080960.2      0.8     27.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   1368684     268499.1      0.2      6.9                  if increase < best_increase:
   306    103971      14419.7      0.1      0.4                      best_increase = increase
   307    103971      20326.7      0.2      0.5                      best_position = i + 1
   308                                           
   309      1653        750.7      0.5      0.0              path.insert(best_position, to_insert)
   310      1653        431.3      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   1367031     269267.6      0.2      6.9              for i, (cost, node) in enumerate(h):
   314   1365378     292279.2      0.2      7.5                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   1365378     519226.4      0.4     13.3                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1653      92606.3     56.0      2.4              heapq.heapify(h)
   319                                           
   320         1         13.7     13.7      0.0          self.tour = path
   321         1        948.4    948.4      0.0          self.calculateCost()

Total time: 7.9291 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.5      0.5      0.0          n = self.numCity
   326         1      96685.3  96685.3      1.2          adj = np.array(self.adj)
   327         1      98041.0  98041.0      1.2          distances = np.array(self.adj)
   328         1          1.2      1.2      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331      1656        239.2      0.1      0.0          for i in range(n):
   332   1370340     210879.1      0.2      2.7              for j in range(0, i):
   333   1368685     502406.1      0.4      6.3                  if distances[i][j] > maxDist:
   334       128         30.4      0.2      0.0                      path[0], path[1] = i, j
   335       128         43.6      0.3      0.0                      maxDist = distances[i][j]
   336         1          2.1      2.1      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.6      0.6      0.0          h = []
   339      1654        285.2      0.2      0.0          for i in set(range(n)) - in_path:
   340      1653       1585.7      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1653        614.8      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1        102.1    102.1      0.0          heapq.heapify(h)
   343                                           
   344      1654        685.3      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1653       1400.6      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1653        468.7      0.3      0.0              best_increase = np.inf
   350      1653        294.5      0.2      0.0              best_pos = None
   351   1370337     213310.5      0.2      2.7              for i in range(len(path)):
   352   1368684     331016.9      0.2      4.2                  next_i = (i + 1) % len(path)
   353   1368684    1096140.3      0.8     13.8                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   1368684     257990.8      0.2      3.3                  if increase < best_increase:
   355     81280      10873.4      0.1      0.1                      best_increase = increase
   356     81280      12779.6      0.2      0.2                      best_pos = next_i
   357                                           
   358      1653        891.1      0.5      0.0              path.insert(best_pos, to_ins)
   359      1653        497.9      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   1367031     344527.2      0.3      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   1365378     296616.3      0.2      3.7                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   1365378     532627.7      0.4      6.7                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       466        115.9      0.2      0.0                      best_cost = np.inf
   367       466         85.8      0.2      0.0                      posL, posR = -1, -1
   368    160472      25063.5      0.2      0.3                      for i2 in range(len(path)):
   369    160006      40675.8      0.3      0.5                          next_i = (i2 + 1) % len(path)
   370    160006     153469.3      1.0      1.9                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    160006      30112.5      0.2      0.4                          if best_cost > insertion_cost:
   372     13023       3017.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       466        163.7      0.4      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   1365378    1738548.1      1.3     21.9                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       558        657.8      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       558        218.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       558        153.3      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   1365378    1820568.3      1.3     23.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      3202       3742.4      1.2      0.0                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      3202       1376.4      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1653      98989.9     59.9      1.2              heapq.heapify(h)
   386                                           
   387         1         13.6     13.6      0.0          self.tour = path
   388         1       1088.6   1088.6      0.0          self.calculateCost()


Optimal 336556
_________________
vm1748
randomInsertion 1.1329002374771882
nearestInsertion 1.2109574478080554
cheapestInsertion 1.2122546939929328
nearestNeighbor 1.2125492008590812
farthestInsertion 1.2683468774644422
furthestInsertion 1.1566841089973436

[('vm1748', 1.1329002374771882, 1.2109574478080554, 1.2122546939929328, 1.2125492008590812, 1.2683468774644422, 1.1566841089973436)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 2.28435 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.8      0.8      0.0          n = self.numCity
   115         1     110652.1 110652.1      4.8          distances = np.array(self.adj)
   116         1          1.2      1.2      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.4      1.4      0.0          in_path = {0}
   118         1        157.3    157.3      0.0          notInPath = [x for x in range(1, n)]
   119         1       1784.9   1784.9      0.1          random.shuffle(notInPath)
   120                                           
   121      1748        522.8      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1747        364.5      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1747        403.4      0.2      0.0              best_increase = np.inf
   127      1747        242.9      0.1      0.0              best_position = None
   128   1528625     253199.5      0.2     11.1              for i in range(len(path)):
   129   1526878     372510.1      0.2     16.3                  next_i = (i + 1) % len(path)
   130   1526878    1217084.4      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   1526878     300824.4      0.2     13.2                  if increase < best_increase:
   132     77856      11269.8      0.1      0.5                      best_increase = increase
   133     77856      12837.6      0.2      0.6                      best_position = next_i
   134                                           
   135      1747        853.5      0.5      0.0              path.insert(best_position, to_insert)
   136      1747        588.4      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          4.5      4.5      0.0          self.tour = path
   139         1       1042.9   1042.9      0.0          self.calculateCost()

Total time: 0.80349 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1         10.1     10.1      0.0          self.tour = [0]
   144         1          1.3      1.3      0.0          visited = set([0])
   145         1         27.8     27.8      0.0          notVisited = set(range(1, self.numCity))
   146      1748        699.2      0.4      0.1          while len(self.tour) < self.numCity:
   147      1747        419.1      0.2      0.1              cost = np.inf
   148      1747        252.5      0.1      0.0              j = -1
   149   1528625     254327.9      0.2     31.7              for j2 in notVisited:
   150   1526878     539041.6      0.4     67.1                  if self.adj[self.tour[-1]][j2] < cost:
   151     14910       3743.4      0.3      0.5                      cost = self.adj[self.tour[-1]][j2]
   152     14910       2342.5      0.2      0.3                      j = j2
   153      1747        650.1      0.4      0.1              self.tour.append(j)
   154      1747        520.2      0.3      0.1              visited.add(j)
   155      1747        457.6      0.3      0.1              notVisited.remove(j)
   156         1        996.4    996.4      0.1          self.calculateCost()

Total time: 4.05742 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.7      0.7      0.0          n = self.numCity
   162         1     110432.0 110432.0      2.7          distances = np.array(self.adj)
   163         1          1.2      1.2      0.0          path = [0, 0]
   164                                           
   165         1          1.5      1.5      0.0          minDist = np.inf
   166      1749        247.1      0.1      0.0          for i in range(n):
   167   1528626     246928.1      0.2      6.1              for j in range(0, i):
   168   1526878     554072.1      0.4     13.7                  if distances[i][j] < minDist:
   169        11          3.0      0.3      0.0                      path[0], path[1] = i, j
   170        11          3.7      0.3      0.0                      minDist = distances[i][j]
   171         1          2.2      2.2      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          1.3      1.3      0.0          h = []
   176      1747        357.9      0.2      0.0          for i in set(range(n)) - in_path:
   177      1746       3720.9      2.1      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        108.2    108.2      0.0          heapq.heapify(h)
   179                                           
   180      1747        628.8      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1746       1343.8      0.8      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1746        427.0      0.2      0.0              best_increase = np.inf
   186      1746        294.2      0.2      0.0              best_position = None
   187   1528623     245230.1      0.2      6.0              for i in range(len(path)):
   188   1526877     372468.5      0.2      9.2                  next_i = (i + 1) % len(path)
   189   1526877    1196998.3      0.8     29.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   1526877     283185.2      0.2      7.0                  if increase < best_increase:
   191     96228      12408.4      0.1      0.3                      best_increase = increase
   192     96228      18119.0      0.2      0.4                      best_position = i + 1
   193                                           
   194      1746        875.1      0.5      0.0              path.insert(best_position, to_insert)
   195      1746        514.1      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   1525131     321115.8      0.2      7.9              for i, (cost, node) in enumerate(h):
   199   1523385     544472.9      0.4     13.4                  if node not in in_path and distances[to_insert, node] < cost:
   200    114071      38075.6      0.3      0.9                      h[i] = (distances[to_insert, node], node)
   201      1746     104318.3     59.7      2.6              heapq.heapify(h)
   202                                           
   203         1         16.6     16.6      0.0          self.tour = path
   204         1       1046.2   1046.2      0.0          self.calculateCost()

Total time: 8.57719 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1     108949.2 108949.2      1.3          adj = np.array(self.adj)
   210         1     111117.5 111117.5      1.3          distances = np.array(self.adj)
   211         1          1.0      1.0      0.0          path = [0, 0]
   212                                           
   213         1          1.3      1.3      0.0          minDist = np.inf
   214      1749        229.3      0.1      0.0          for i in range(n):
   215   1528626     235323.9      0.2      2.7              for j in range(0, i):
   216   1526878     543272.0      0.4      6.3                  if distances[i][j] < minDist:
   217        11          3.3      0.3      0.0                      path[0], path[1] = i, j
   218        11          3.8      0.3      0.0                      minDist = distances[i][j]
   219         1          2.3      2.3      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.8      0.8      0.0          h = []
   222      1747        360.7      0.2      0.0          for i in set(range(n)) - in_path:
   223      1746       1757.0      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1746        735.1      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1        107.5    107.5      0.0          heapq.heapify(h)
   226                                           
   227      1747        693.1      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1746       1330.0      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1746        459.3      0.3      0.0              best_increase = np.inf
   233      1746        252.6      0.1      0.0              best_pos = None
   234   1528623     231680.1      0.2      2.7              for i in range(len(path)):
   235   1526877     377088.9      0.2      4.4                  next_i = (i + 1) % len(path)
   236   1526877    1212368.2      0.8     14.1                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   1526877     282664.7      0.2      3.3                  if increase < best_increase:
   238     70364       9610.6      0.1      0.1                      best_increase = increase
   239     70364      10592.0      0.2      0.1                      best_pos = next_i
   240                                           
   241      1746       1035.4      0.6      0.0              path.insert(best_pos, to_ins)
   242      1746        481.6      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   1525131     358202.2      0.2      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   1523385     543599.8      0.4      6.3                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      1239        257.6      0.2      0.0                      best_cost = np.inf
   251      1239        201.5      0.2      0.0                      posL, posR = -1, -1
   252    276783      43558.9      0.2      0.5                      for i2 in range(len(path)):
   253    275544      68381.4      0.2      0.8                          next_i = (i2 + 1) % len(path)
   254    275544     256661.6      0.9      3.0                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    275544      50674.5      0.2      0.6                          if best_cost > insertion_cost:
   256     20124       4149.6      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      1239        312.1      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   1523385    1851524.0      1.2     21.6                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261     70757      75190.0      1.1      0.9                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262     70757      26886.1      0.4      0.3                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265     70757      17070.9      0.2      0.2                      best_pos = (best_pos + 1) % (len(path))
   266   1523385    1921217.4      1.3     22.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267     79459      87298.4      1.1      1.0                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268     79459      35210.8      0.4      0.4                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1746     105618.9     60.5      1.2              heapq.heapify(h)
   270                                           
   271         1         16.1     16.1      0.0          self.tour = path
   272         1       1039.2   1039.2      0.0          self.calculateCost()

Total time: 4.43518 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.5      0.5      0.0          n = self.numCity
   277         1     108256.9 108256.9      2.4          distances = np.array(self.adj)
   278         1          1.2      1.2      0.0          path = [0, 0]
   279                                           
   280         1          0.3      0.3      0.0          maxDist = 0
   281      1749        252.4      0.1      0.0          for i in range(n):
   282   1528626     242816.6      0.2      5.5              for j in range(0, i):
   283   1526878     577972.9      0.4     13.0                  if distances[i][j] > maxDist:
   284        29          7.8      0.3      0.0                      path[0], path[1] = i, j
   285        29          9.7      0.3      0.0                      maxDist = distances[i][j]
   286         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.5      0.5      0.0          h = []
   291      1747        304.4      0.2      0.0          for i in set(range(n)) - in_path:
   292      1746       1214.4      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1        104.2    104.2      0.0          heapq.heapify(h)
   294                                           
   295      1747        633.7      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1746       1290.2      0.7      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1746        411.6      0.2      0.0              best_increase = np.inf
   301      1746        263.4      0.2      0.0              best_position = None
   302   1528623     237341.3      0.2      5.4              for i in range(len(path)):
   303   1526877     370322.9      0.2      8.3                  next_i = (i + 1) % len(path)
   304   1526877    1226375.1      0.8     27.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   1526877     277643.6      0.2      6.3                  if increase < best_increase:
   306    208796      27568.1      0.1      0.6                      best_increase = increase
   307    208796      38361.8      0.2      0.9                      best_position = i + 1
   308                                           
   309      1746        874.7      0.5      0.0              path.insert(best_position, to_insert)
   310      1746        468.8      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   1525131     323323.4      0.2      7.3              for i, (cost, node) in enumerate(h):
   314   1523385     313752.0      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   1523385     580894.9      0.4     13.1                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1746     103652.4     59.4      2.3              heapq.heapify(h)
   319                                           
   320         1         16.0     16.0      0.0          self.tour = path
   321         1       1038.5   1038.5      0.0          self.calculateCost()

Total time: 8.59867 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          1.0      1.0      0.0          n = self.numCity
   326         1     107926.0 107926.0      1.3          adj = np.array(self.adj)
   327         1     110182.5 110182.5      1.3          distances = np.array(self.adj)
   328         1          0.9      0.9      0.0          path = [0, 0]
   329                                           
   330         1          0.1      0.1      0.0          maxDist = 0
   331      1749        248.6      0.1      0.0          for i in range(n):
   332   1528626     236195.6      0.2      2.7              for j in range(0, i):
   333   1526878     559784.4      0.4      6.5                  if distances[i][j] > maxDist:
   334        29          8.2      0.3      0.0                      path[0], path[1] = i, j
   335        29          9.6      0.3      0.0                      maxDist = distances[i][j]
   336         1          1.4      1.4      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339      1747        307.0      0.2      0.0          for i in set(range(n)) - in_path:
   340      1746       1677.7      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1746        645.7      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1        102.9    102.9      0.0          heapq.heapify(h)
   343                                           
   344      1747        687.2      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1746       1449.6      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1746        406.3      0.2      0.0              best_increase = np.inf
   350      1746        283.0      0.2      0.0              best_pos = None
   351   1528623     237182.3      0.2      2.8              for i in range(len(path)):
   352   1526877     367047.3      0.2      4.3                  next_i = (i + 1) % len(path)
   353   1526877    1182259.9      0.8     13.7                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   1526877     286594.8      0.2      3.3                  if increase < best_increase:
   355    121110      16725.5      0.1      0.2                      best_increase = increase
   356    121110      18902.0      0.2      0.2                      best_pos = next_i
   357                                           
   358      1746        924.8      0.5      0.0              path.insert(best_pos, to_ins)
   359      1746        470.2      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   1525131     367198.4      0.2      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   1523385     309905.2      0.2      3.6                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   1523385     569616.3      0.4      6.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       524        115.7      0.2      0.0                      best_cost = np.inf
   367       524         87.2      0.2      0.0                      posL, posR = -1, -1
   368    134049      20505.0      0.2      0.2                      for i2 in range(len(path)):
   369    133525      31808.0      0.2      0.4                          next_i = (i2 + 1) % len(path)
   370    133525     125741.2      0.9      1.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    133525      24428.6      0.2      0.3                          if best_cost > insertion_cost:
   372     15187       3151.5      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       524        162.2      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   1523385    1924961.9      1.3     22.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       941       1042.4      1.1      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       941        379.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       941        246.6      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   1523385    1973898.9      1.3     23.0                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      3669       4134.9      1.1      0.0                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      3669       1576.2      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1746     108590.1     62.2      1.3              heapq.heapify(h)
   386                                           
   387         1         15.9     15.9      0.0          self.tour = path
   388         1       1077.4   1077.4      0.0          self.calculateCost()


Optimal 316536
_________________
rl1889
randomInsertion 1.1792551973415
nearestInsertion 1.247891222225345
cheapestInsertion 1.262578745955574
nearestNeighbor 1.2658422373310316
farthestInsertion 1.2756412795285461
furthestInsertion 1.178872780575816

[('rl1889', 1.1792551973415, 1.247891222225345, 1.262578745955574, 1.2658422373310316, 1.2756412795285461, 1.178872780575816)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 2.68013 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.8      0.8      0.0          n = self.numCity
   115         1     132781.3 132781.3      5.0          distances = np.array(self.adj)
   116         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.2      1.2      0.0          in_path = {0}
   118         1        144.1    144.1      0.0          notInPath = [x for x in range(1, n)]
   119         1       1920.0   1920.0      0.1          random.shuffle(notInPath)
   120                                           
   121      1889        583.8      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      1888        392.7      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      1888        448.3      0.2      0.0              best_increase = np.inf
   127      1888        255.1      0.1      0.0              best_position = None
   128   1785104     289657.5      0.2     10.8              for i in range(len(path)):
   129   1783216     447439.8      0.3     16.7                  next_i = (i + 1) % len(path)
   130   1783216    1432757.0      0.8     53.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   1783216     343440.0      0.2     12.8                  if increase < best_increase:
   132     94226      12697.6      0.1      0.5                      best_increase = increase
   133     94226      14877.6      0.2      0.6                      best_position = next_i
   134                                           
   135      1888        919.5      0.5      0.0              path.insert(best_position, to_insert)
   136      1888        657.6      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          5.0      5.0      0.0          self.tour = path
   139         1       1145.1   1145.1      0.0          self.calculateCost()

Total time: 0.892002 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1         10.5     10.5      0.0          self.tour = [0]
   144         1          1.3      1.3      0.0          visited = set([0])
   145         1         28.4     28.4      0.0          notVisited = set(range(1, self.numCity))
   146      1889        807.0      0.4      0.1          while len(self.tour) < self.numCity:
   147      1888        489.2      0.3      0.1              cost = np.inf
   148      1888        280.8      0.1      0.0              j = -1
   149   1785104     291706.5      0.2     32.7              for j2 in notVisited:
   150   1783216     583230.8      0.3     65.4                  if self.adj[self.tour[-1]][j2] < cost:
   151     31176       7729.2      0.2      0.9                      cost = self.adj[self.tour[-1]][j2]
   152     31176       4789.7      0.2      0.5                      j = j2
   153      1888        754.5      0.4      0.1              self.tour.append(j)
   154      1888        600.8      0.3      0.1              visited.add(j)
   155      1888        499.7      0.3      0.1              notVisited.remove(j)
   156         1       1073.5   1073.5      0.1          self.calculateCost()

Total time: 4.83312 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.7      0.7      0.0          n = self.numCity
   162         1     132264.6 132264.6      2.7          distances = np.array(self.adj)
   163         1          1.5      1.5      0.0          path = [0, 0]
   164                                           
   165         1          1.6      1.6      0.0          minDist = np.inf
   166      1890        281.5      0.1      0.0          for i in range(n):
   167   1785105     293021.0      0.2      6.1              for j in range(0, i):
   168   1783216     649333.8      0.4     13.4                  if distances[i][j] < minDist:
   169        11          4.3      0.4      0.0                      path[0], path[1] = i, j
   170        11          4.1      0.4      0.0                      minDist = distances[i][j]
   171         1          2.3      2.3      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.9      0.9      0.0          h = []
   176      1888        393.4      0.2      0.0          for i in set(range(n)) - in_path:
   177      1887       8239.5      4.4      0.2              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        113.5    113.5      0.0          heapq.heapify(h)
   179                                           
   180      1888        712.4      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      1887       1466.0      0.8      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      1887        485.8      0.3      0.0              best_increase = np.inf
   186      1887        298.7      0.2      0.0              best_position = None
   187   1785102     285753.8      0.2      5.9              for i in range(len(path)):
   188   1783215     445993.4      0.3      9.2                  next_i = (i + 1) % len(path)
   189   1783215    1437242.5      0.8     29.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   1783215     352276.6      0.2      7.3                  if increase < best_increase:
   191     89144      11790.5      0.1      0.2                      best_increase = increase
   192     89144      17350.7      0.2      0.4                      best_position = i + 1
   193                                           
   194      1887       1001.0      0.5      0.0              path.insert(best_position, to_insert)
   195      1887        559.2      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   1781328     381103.2      0.2      7.9              for i, (cost, node) in enumerate(h):
   199   1779441     635416.8      0.4     13.1                  if node not in in_path and distances[to_insert, node] < cost:
   200    150342      51831.3      0.3      1.1                      h[i] = (distances[to_insert, node], node)
   201      1887     125021.2     66.3      2.6              heapq.heapify(h)
   202                                           
   203         1         17.2     17.2      0.0          self.tour = path
   204         1       1139.2   1139.2      0.0          self.calculateCost()

Total time: 10.8159 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1     129092.3 129092.3      1.2          adj = np.array(self.adj)
   210         1     131654.7 131654.7      1.2          distances = np.array(self.adj)
   211         1          1.4      1.4      0.0          path = [0, 0]
   212                                           
   213         1          1.6      1.6      0.0          minDist = np.inf
   214      1890        269.6      0.1      0.0          for i in range(n):
   215   1785105     275848.1      0.2      2.6              for j in range(0, i):
   216   1783216     644501.9      0.4      6.0                  if distances[i][j] < minDist:
   217        11          4.3      0.4      0.0                      path[0], path[1] = i, j
   218        11          4.0      0.4      0.0                      minDist = distances[i][j]
   219         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.8      0.8      0.0          h = []
   222      1888        411.0      0.2      0.0          for i in set(range(n)) - in_path:
   223      1887       1963.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      1887      36095.4     19.1      0.3              h.append((cost, i, path[0], path[1]))
   225         1        119.8    119.8      0.0          heapq.heapify(h)
   226                                           
   227      1888        795.7      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      1887       1535.5      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      1887        527.1      0.3      0.0              best_increase = np.inf
   233      1887        336.8      0.2      0.0              best_pos = None
   234   1785102     278596.2      0.2      2.6              for i in range(len(path)):
   235   1783215     448346.5      0.3      4.1                  next_i = (i + 1) % len(path)
   236   1783215    1443013.4      0.8     13.3                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   1783215     342453.1      0.2      3.2                  if increase < best_increase:
   238     99134      13559.1      0.1      0.1                      best_increase = increase
   239     99134      15216.2      0.2      0.1                      best_pos = next_i
   240                                           
   241      1887        985.4      0.5      0.0              path.insert(best_pos, to_ins)
   242      1887        578.2      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   1781328     437649.1      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   1779441     702018.4      0.4      6.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      1729        349.8      0.2      0.0                      best_cost = np.inf
   251      1729        284.5      0.2      0.0                      posL, posR = -1, -1
   252    355000      55991.3      0.2      0.5                      for i2 in range(len(path)):
   253    353271      88938.6      0.3      0.8                          next_i = (i2 + 1) % len(path)
   254    353271     346783.3      1.0      3.2                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    353271      68034.3      0.2      0.6                          if best_cost > insertion_cost:
   256     23130       5054.4      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      1729        437.9      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   1779441    2370098.6      1.3     21.9                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261    102004     119509.7      1.2      1.1                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262    102004      40854.7      0.4      0.4                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265    102004      25651.8      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266   1779441    2475356.1      1.4     22.9                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267    111090     134901.4      1.2      1.2                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268    111090      51397.2      0.5      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      1887     125458.5     66.5      1.2              heapq.heapify(h)
   270                                           
   271         1         17.1     17.1      0.0          self.tour = path
   272         1       1154.6   1154.6      0.0          self.calculateCost()

Total time: 5.06025 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1     129452.6 129452.6      2.6          distances = np.array(self.adj)
   278         1          1.7      1.7      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281      1890        270.2      0.1      0.0          for i in range(n):
   282   1785105     259294.3      0.1      5.1              for j in range(0, i):
   283   1783216     639605.4      0.4     12.6                  if distances[i][j] > maxDist:
   284        13          5.4      0.4      0.0                      path[0], path[1] = i, j
   285        13          4.7      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.6      0.6      0.0          h = []
   291      1888        317.6      0.2      0.0          for i in set(range(n)) - in_path:
   292      1887       1278.7      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1        120.2    120.2      0.0          heapq.heapify(h)
   294                                           
   295      1888        735.6      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      1887       1428.5      0.8      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      1887        473.8      0.3      0.0              best_increase = np.inf
   301      1887        277.3      0.1      0.0              best_position = None
   302   1785102     280616.0      0.2      5.5              for i in range(len(path)):
   303   1783215     446197.6      0.3      8.8                  next_i = (i + 1) % len(path)
   304   1783215    1453260.2      0.8     28.7                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   1783215     330414.4      0.2      6.5                  if increase < best_increase:
   306     98156      12810.9      0.1      0.3                      best_increase = increase
   307     98156      18034.5      0.2      0.4                      best_position = i + 1
   308                                           
   309      1887        976.6      0.5      0.0              path.insert(best_position, to_insert)
   310      1887        491.9      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   1781328     359417.9      0.2      7.1              for i, (cost, node) in enumerate(h):
   314   1779441     357945.3      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   1779441     641568.6      0.4     12.7                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      1887     124084.7     65.8      2.5              heapq.heapify(h)
   319                                           
   320         1         17.0     17.0      0.0          self.tour = path
   321         1       1143.0   1143.0      0.0          self.calculateCost()

Total time: 10.7352 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          1.3      1.3      0.0          n = self.numCity
   326         1     130440.0 130440.0      1.2          adj = np.array(self.adj)
   327         1     131926.1 131926.1      1.2          distances = np.array(self.adj)
   328         1          1.3      1.3      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331      1890        302.6      0.2      0.0          for i in range(n):
   332   1785105     273758.3      0.2      2.6              for j in range(0, i):
   333   1783216     638371.7      0.4      5.9                  if distances[i][j] > maxDist:
   334        13          6.1      0.5      0.0                      path[0], path[1] = i, j
   335        13          5.1      0.4      0.0                      maxDist = distances[i][j]
   336         1          2.0      2.0      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.8      0.8      0.0          h = []
   339      1888        347.9      0.2      0.0          for i in set(range(n)) - in_path:
   340      1887       1922.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      1887        707.0      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1        116.5    116.5      0.0          heapq.heapify(h)
   343                                           
   344      1888        805.9      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      1887       1552.3      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      1887        510.3      0.3      0.0              best_increase = np.inf
   350      1887        306.4      0.2      0.0              best_pos = None
   351   1785102     275339.8      0.2      2.6              for i in range(len(path)):
   352   1783215     443410.7      0.2      4.1                  next_i = (i + 1) % len(path)
   353   1783215    1432541.7      0.8     13.3                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   1783215     343195.0      0.2      3.2                  if increase < best_increase:
   355    108338      15536.5      0.1      0.1                      best_increase = increase
   356    108338      17242.0      0.2      0.2                      best_pos = next_i
   357                                           
   358      1887       1008.6      0.5      0.0              path.insert(best_pos, to_ins)
   359      1887        512.3      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   1781328     434059.2      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   1779441     364059.9      0.2      3.4                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   1779441     699204.3      0.4      6.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       780        175.1      0.2      0.0                      best_cost = np.inf
   367       780        137.5      0.2      0.0                      posL, posR = -1, -1
   368    338227      52893.8      0.2      0.5                      for i2 in range(len(path)):
   369    337447      84091.1      0.2      0.8                          next_i = (i2 + 1) % len(path)
   370    337447     330728.9      1.0      3.1                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    337447      64201.1      0.2      0.6                          if best_cost > insertion_cost:
   372     22409       4722.8      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       780        269.2      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   1779441    2363793.6      1.3     22.0                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       859       1030.9      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       859        374.2      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       859        230.2      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   1779441    2488276.8      1.4     23.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      4988       6099.8      1.2      0.1                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      4988       2175.6      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      1887     127574.3     67.6      1.2              heapq.heapify(h)
   386                                           
   387         1         16.7     16.7      0.0          self.tour = path
   388         1       1166.0   1166.0      0.0          self.calculateCost()


Optimal 64253
_________________
u2152
randomInsertion 1.2070828653100578
nearestInsertion 1.2219117031203635
cheapestInsertion 1.264760900953167
nearestNeighbor 1.2259567766673958
farthestInsertion 1.270399899826854
furthestInsertion 1.2520034416262877

[('u2152', 1.2070828653100578, 1.2219117031203635, 1.264760900953167, 1.2259567766673958, 1.270399899826854, 1.2520034416262877)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 3.46405 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          1.2      1.2      0.0          n = self.numCity
   115         1     170437.6 170437.6      4.9          distances = np.array(self.adj)
   116         1          1.1      1.1      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1        182.9    182.9      0.0          notInPath = [x for x in range(1, n)]
   119         1       2117.5   2117.5      0.1          random.shuffle(notInPath)
   120                                           
   121      2152        698.9      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      2151        463.9      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      2151        532.5      0.2      0.0              best_increase = np.inf
   127      2151        308.1      0.1      0.0              best_position = None
   128   2316627     370736.2      0.2     10.7              for i in range(len(path)):
   129   2314476     569987.4      0.2     16.5                  next_i = (i + 1) % len(path)
   130   2314476    1865068.4      0.8     53.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   2314476     444425.9      0.2     12.8                  if increase < best_increase:
   132    121212      16318.7      0.1      0.5                      best_increase = increase
   133    121212      19698.2      0.2      0.6                      best_position = next_i
   134                                           
   135      2151       1136.8      0.5      0.0              path.insert(best_position, to_insert)
   136      2151        730.1      0.3      0.0              in_path.add(to_insert)
   137                                           
   138         1          5.7      5.7      0.0          self.tour = path
   139         1       1196.8   1196.8      0.0          self.calculateCost()

Total time: 1.13666 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1          9.2      9.2      0.0          self.tour = [0]
   144         1          1.2      1.2      0.0          visited = set([0])
   145         1         30.0     30.0      0.0          notVisited = set(range(1, self.numCity))
   146      2152        895.9      0.4      0.1          while len(self.tour) < self.numCity:
   147      2151        504.9      0.2      0.0              cost = np.inf
   148      2151        289.3      0.1      0.0              j = -1
   149   2316627     369377.5      0.2     32.5              for j2 in notVisited:
   150   2314476     723462.4      0.3     63.6                  if self.adj[self.tour[-1]][j2] < cost:
   151     99705      23936.3      0.2      2.1                      cost = self.adj[self.tour[-1]][j2]
   152     99705      15067.3      0.2      1.3                      j = j2
   153      2151        832.0      0.4      0.1              self.tour.append(j)
   154      2151        566.9      0.3      0.0              visited.add(j)
   155      2151        546.8      0.3      0.0              notVisited.remove(j)
   156         1       1140.7   1140.7      0.1          self.calculateCost()

Total time: 6.25622 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.6      0.6      0.0          n = self.numCity
   162         1     170078.3 170078.3      2.7          distances = np.array(self.adj)
   163         1          1.1      1.1      0.0          path = [0, 0]
   164                                           
   165         1          1.7      1.7      0.0          minDist = np.inf
   166      2153        340.9      0.2      0.0          for i in range(n):
   167   2316628     364406.7      0.2      5.8              for j in range(0, i):
   168   2314476     845501.3      0.4     13.5                  if distances[i][j] < minDist:
   169         2          1.1      0.5      0.0                      path[0], path[1] = i, j
   170         2          0.9      0.5      0.0                      minDist = distances[i][j]
   171         1          2.6      2.6      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.8      0.8      0.0          h = []
   176      2151        422.4      0.2      0.0          for i in set(range(n)) - in_path:
   177      2150       6182.2      2.9      0.1              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        174.8    174.8      0.0          heapq.heapify(h)
   179                                           
   180      2151        786.2      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      2150       1833.0      0.9      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      2150        592.6      0.3      0.0              best_increase = np.inf
   186      2150        372.3      0.2      0.0              best_position = None
   187   2316625     383476.8      0.2      6.1              for i in range(len(path)):
   188   2314475     589435.6      0.3      9.4                  next_i = (i + 1) % len(path)
   189   2314475    1834134.9      0.8     29.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   2314475     453559.6      0.2      7.2                  if increase < best_increase:
   191    128045      17774.4      0.1      0.3                      best_increase = increase
   192    128045      24940.3      0.2      0.4                      best_position = i + 1
   193                                           
   194      2150       1346.2      0.6      0.0              path.insert(best_position, to_insert)
   195      2150        683.6      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   2312325     495957.7      0.2      7.9              for i, (cost, node) in enumerate(h):
   199   2310175     836285.4      0.4     13.4                  if node not in in_path and distances[to_insert, node] < cost:
   200    185780      63898.0      0.3      1.0                      h[i] = (distances[to_insert, node], node)
   201      2150     162804.0     75.7      2.6              heapq.heapify(h)
   202                                           
   203         1         17.1     17.1      0.0          self.tour = path
   204         1       1211.5   1211.5      0.0          self.calculateCost()

Total time: 13.553 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.8      0.8      0.0          n = self.numCity
   209         1     170827.6 170827.6      1.3          adj = np.array(self.adj)
   210         1     170084.9 170084.9      1.3          distances = np.array(self.adj)
   211         1          1.3      1.3      0.0          path = [0, 0]
   212                                           
   213         1          1.9      1.9      0.0          minDist = np.inf
   214      2153        300.9      0.1      0.0          for i in range(n):
   215   2316628     373698.5      0.2      2.8              for j in range(0, i):
   216   2314476     840530.5      0.4      6.2                  if distances[i][j] < minDist:
   217         2          1.2      0.6      0.0                      path[0], path[1] = i, j
   218         2          0.8      0.4      0.0                      minDist = distances[i][j]
   219         1          2.2      2.2      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222      2151        422.0      0.2      0.0          for i in set(range(n)) - in_path:
   223      2150       2259.7      1.1      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      2150      45740.0     21.3      0.3              h.append((cost, i, path[0], path[1]))
   225         1        142.0    142.0      0.0          heapq.heapify(h)
   226                                           
   227      2151        866.9      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      2150       1825.0      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      2150        560.9      0.3      0.0              best_increase = np.inf
   233      2150        354.6      0.2      0.0              best_pos = None
   234   2316625     374073.5      0.2      2.8              for i in range(len(path)):
   235   2314475     599367.1      0.3      4.4                  next_i = (i + 1) % len(path)
   236   2314475    1826787.7      0.8     13.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   2314475     444731.8      0.2      3.3                  if increase < best_increase:
   238    142725      19822.5      0.1      0.1                      best_increase = increase
   239    142725      22765.6      0.2      0.2                      best_pos = next_i
   240                                           
   241      2150       1293.7      0.6      0.0              path.insert(best_pos, to_ins)
   242      2150        628.4      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   2312325     602598.8      0.3      4.4              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   2310175     889721.3      0.4      6.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      1271        283.5      0.2      0.0                      best_cost = np.inf
   251      1271        218.2      0.2      0.0                      posL, posR = -1, -1
   252    366524      62475.8      0.2      0.5                      for i2 in range(len(path)):
   253    365253      92868.6      0.3      0.7                          next_i = (i2 + 1) % len(path)
   254    365253     344884.7      0.9      2.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    365253      71920.0      0.2      0.5                          if best_cost > insertion_cost:
   256     25979       5937.4      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      1271        346.3      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   2310175    2958560.5      1.3     21.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261    117391     134551.4      1.1      1.0                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262    117391      46929.2      0.4      0.3                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265    117391      29824.6      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266   2310175    3033205.8      1.3     22.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267    137454     157075.8      1.1      1.2                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268    137454      62063.1      0.5      0.5                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      2150     161243.6     75.0      1.2              heapq.heapify(h)
   270                                           
   271         1         16.8     16.8      0.0          self.tour = path
   272         1       1203.1   1203.1      0.0          self.calculateCost()

Total time: 6.57363 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.9      0.9      0.0          n = self.numCity
   277         1     169534.9 169534.9      2.6          distances = np.array(self.adj)
   278         1          1.1      1.1      0.0          path = [0, 0]
   279                                           
   280         1          0.1      0.1      0.0          maxDist = 0
   281      2153        312.9      0.1      0.0          for i in range(n):
   282   2316628     362846.7      0.2      5.5              for j in range(0, i):
   283   2314476     836587.5      0.4     12.7                  if distances[i][j] > maxDist:
   284       223         53.5      0.2      0.0                      path[0], path[1] = i, j
   285       223         72.8      0.3      0.0                      maxDist = distances[i][j]
   286         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.8      0.8      0.0          h = []
   291      2151        379.9      0.2      0.0          for i in set(range(n)) - in_path:
   292      2150       1464.2      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1        140.2    140.2      0.0          heapq.heapify(h)
   294                                           
   295      2151        859.4      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      2150       1621.5      0.8      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      2150        520.7      0.2      0.0              best_increase = np.inf
   301      2150        353.5      0.2      0.0              best_position = None
   302   2316625     367227.1      0.2      5.6              for i in range(len(path)):
   303   2314475     558019.8      0.2      8.5                  next_i = (i + 1) % len(path)
   304   2314475    1767540.4      0.8     26.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   2314475     435913.0      0.2      6.6                  if increase < best_increase:
   306    127537      16481.8      0.1      0.3                      best_increase = increase
   307    127537      23857.8      0.2      0.4                      best_position = i + 1
   308                                           
   309      2150       1215.8      0.6      0.0              path.insert(best_position, to_insert)
   310      2150        620.2      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   2312325     468884.2      0.2      7.1              for i, (cost, node) in enumerate(h):
   314   2310175     499951.6      0.2      7.6                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   2310175     896333.2      0.4     13.6                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      2150     161614.8     75.2      2.5              heapq.heapify(h)
   319                                           
   320         1         18.0     18.0      0.0          self.tour = path
   321         1       1195.9   1195.9      0.0          self.calculateCost()

Total time: 13.3541 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.5      0.5      0.0          n = self.numCity
   326         1     169702.2 169702.2      1.3          adj = np.array(self.adj)
   327         1     170940.0 170940.0      1.3          distances = np.array(self.adj)
   328         1          1.7      1.7      0.0          path = [0, 0]
   329                                           
   330         1          0.1      0.1      0.0          maxDist = 0
   331      2153        304.5      0.1      0.0          for i in range(n):
   332   2316628     369185.9      0.2      2.8              for j in range(0, i):
   333   2314476     834815.6      0.4      6.3                  if distances[i][j] > maxDist:
   334       223         52.0      0.2      0.0                      path[0], path[1] = i, j
   335       223         71.9      0.3      0.0                      maxDist = distances[i][j]
   336         1          1.1      1.1      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339      2151        389.3      0.2      0.0          for i in set(range(n)) - in_path:
   340      2150       2152.3      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      2150        822.3      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1        136.2    136.2      0.0          heapq.heapify(h)
   343                                           
   344      2151        845.5      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      2150       1717.1      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      2150        484.4      0.2      0.0              best_increase = np.inf
   350      2150        323.9      0.2      0.0              best_pos = None
   351   2316625     359859.4      0.2      2.7              for i in range(len(path)):
   352   2314475     564982.6      0.2      4.2                  next_i = (i + 1) % len(path)
   353   2314475    1850204.2      0.8     13.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   2314475     427951.9      0.2      3.2                  if increase < best_increase:
   355    126358      16962.4      0.1      0.1                      best_increase = increase
   356    126358      19518.3      0.2      0.1                      best_pos = next_i
   357                                           
   358      2150       1284.1      0.6      0.0              path.insert(best_pos, to_ins)
   359      2150        582.3      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   2312325     594330.7      0.3      4.5              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   2310175     455075.4      0.2      3.4                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   2310175     865017.4      0.4      6.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       468        108.6      0.2      0.0                      best_cost = np.inf
   367       468         83.2      0.2      0.0                      posL, posR = -1, -1
   368    280798      43784.6      0.2      0.3                      for i2 in range(len(path)):
   369    280330      68516.8      0.2      0.5                          next_i = (i2 + 1) % len(path)
   370    280330     259282.9      0.9      1.9                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    280330      52045.1      0.2      0.4                          if best_cost > insertion_cost:
   372     18443       3879.6      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       468        181.6      0.4      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   2310175    3012995.2      1.3     22.6                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       880       1012.6      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       880        357.0      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       880        215.7      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   2310175    3027593.9      1.3     22.7                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      4667       5327.7      1.1      0.0                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      4667       2022.0      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      2150     167694.6     78.0      1.3              heapq.heapify(h)
   386                                           
   387         1         16.0     16.0      0.0          self.tour = path
   388         1       1237.6   1237.6      0.0          self.calculateCost()


Optimal 378032
_________________
pr2392
randomInsertion 1.1583883215207609
nearestInsertion 1.2433207604381584
cheapestInsertion 1.2486526741747905
nearestNeighbor 1.2200223520750098
farthestInsertion 1.3090645301762134
furthestInsertion 1.187739257708469

[('pr2392', 1.1583883215207609, 1.2433207604381584, 1.2486526741747905, 1.2200223520750098, 1.3090645301762134, 1.187739257708469)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 4.3517 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.9      0.9      0.0          n = self.numCity
   115         1     222521.8 222521.8      5.1          distances = np.array(self.adj)
   116         1          1.3      1.3      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.7      1.7      0.0          in_path = {0}
   118         1        209.6    209.6      0.0          notInPath = [x for x in range(1, n)]
   119         1       2474.3   2474.3      0.1          random.shuffle(notInPath)
   120                                           
   121      2392        792.8      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      2391        565.5      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      2391        616.2      0.3      0.0              best_increase = np.inf
   127      2391        346.9      0.1      0.0              best_position = None
   128   2862027     474585.2      0.2     10.9              for i in range(len(path)):
   129   2859636     710688.6      0.2     16.3                  next_i = (i + 1) % len(path)
   130   2859636    2321519.5      0.8     53.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   2859636     568943.4      0.2     13.1                  if increase < best_increase:
   132    147118      20076.7      0.1      0.5                      best_increase = increase
   133    147118      24764.6      0.2      0.6                      best_position = next_i
   134                                           
   135      2391       1342.5      0.6      0.0              path.insert(best_position, to_insert)
   136      2391        868.1      0.4      0.0              in_path.add(to_insert)
   137                                           
   138         1          6.2      6.2      0.0          self.tour = path
   139         1       1377.9   1377.9      0.0          self.calculateCost()

Total time: 1.38602 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1         10.2     10.2      0.0          self.tour = [0]
   144         1          1.3      1.3      0.0          visited = set([0])
   145         1         36.8     36.8      0.0          notVisited = set(range(1, self.numCity))
   146      2392       1035.1      0.4      0.1          while len(self.tour) < self.numCity:
   147      2391        548.7      0.2      0.0              cost = np.inf
   148      2391        329.7      0.1      0.0              j = -1
   149   2862027     456704.2      0.2     33.0              for j2 in notVisited:
   150   2859636     887209.2      0.3     64.0                  if self.adj[self.tour[-1]][j2] < cost:
   151     95577      22430.0      0.2      1.6                      cost = self.adj[self.tour[-1]][j2]
   152     95577      14094.8      0.1      1.0                      j = j2
   153      2391        891.7      0.4      0.1              self.tour.append(j)
   154      2391        705.2      0.3      0.1              visited.add(j)
   155      2391        635.5      0.3      0.0              notVisited.remove(j)
   156         1       1383.4   1383.4      0.1          self.calculateCost()

Total time: 7.60902 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.7      0.7      0.0          n = self.numCity
   162         1     217354.0 217354.0      2.9          distances = np.array(self.adj)
   163         1          1.1      1.1      0.0          path = [0, 0]
   164                                           
   165         1          2.3      2.3      0.0          minDist = np.inf
   166      2393        326.4      0.1      0.0          for i in range(n):
   167   2862028     462768.2      0.2      6.1              for j in range(0, i):
   168   2859636    1046258.0      0.4     13.8                  if distances[i][j] < minDist:
   169         9          3.5      0.4      0.0                      path[0], path[1] = i, j
   170         9          3.4      0.4      0.0                      minDist = distances[i][j]
   171         1          1.9      1.9      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.9      0.9      0.0          h = []
   176      2391        465.3      0.2      0.0          for i in set(range(n)) - in_path:
   177      2390       3022.3      1.3      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        145.0    145.0      0.0          heapq.heapify(h)
   179                                           
   180      2391        947.4      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      2390       1883.9      0.8      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      2390        612.3      0.3      0.0              best_increase = np.inf
   186      2390        407.1      0.2      0.0              best_position = None
   187   2862025     472155.1      0.2      6.2              for i in range(len(path)):
   188   2859635     725671.8      0.3      9.5                  next_i = (i + 1) % len(path)
   189   2859635    2187933.2      0.8     28.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   2859635     574005.2      0.2      7.5                  if increase < best_increase:
   191    126509      17548.3      0.1      0.2                      best_increase = increase
   192    126509      24857.4      0.2      0.3                      best_position = i + 1
   193                                           
   194      2390       1238.4      0.5      0.0              path.insert(best_position, to_insert)
   195      2390        674.9      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   2857245     593050.2      0.2      7.8              for i, (cost, node) in enumerate(h):
   199   2854855    1027979.1      0.4     13.5                  if node not in in_path and distances[to_insert, node] < cost:
   200    153563      52084.3      0.3      0.7                      h[i] = (distances[to_insert, node], node)
   201      2390     196233.7     82.1      2.6              heapq.heapify(h)
   202                                           
   203         1         17.6     17.6      0.0          self.tour = path
   204         1       1365.7   1365.7      0.0          self.calculateCost()

Total time: 16.2494 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1     216561.8 216561.8      1.3          adj = np.array(self.adj)
   210         1     217199.3 217199.3      1.3          distances = np.array(self.adj)
   211         1          1.0      1.0      0.0          path = [0, 0]
   212                                           
   213         1          1.2      1.2      0.0          minDist = np.inf
   214      2393        353.3      0.1      0.0          for i in range(n):
   215   2862028     449964.9      0.2      2.8              for j in range(0, i):
   216   2859636    1038401.5      0.4      6.4                  if distances[i][j] < minDist:
   217         9          3.0      0.3      0.0                      path[0], path[1] = i, j
   218         9          3.2      0.4      0.0                      minDist = distances[i][j]
   219         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222      2391        447.5      0.2      0.0          for i in set(range(n)) - in_path:
   223      2390       2456.0      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      2390      57936.7     24.2      0.4              h.append((cost, i, path[0], path[1]))
   225         1        148.0    148.0      0.0          heapq.heapify(h)
   226                                           
   227      2391       1059.0      0.4      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      2390       1970.9      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      2390        684.4      0.3      0.0              best_increase = np.inf
   233      2390        430.1      0.2      0.0              best_pos = None
   234   2862025     456015.3      0.2      2.8              for i in range(len(path)):
   235   2859635     722534.3      0.3      4.4                  next_i = (i + 1) % len(path)
   236   2859635    2207307.3      0.8     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   2859635     541624.7      0.2      3.3                  if increase < best_increase:
   238    122057      16322.3      0.1      0.1                      best_increase = increase
   239    122057      18735.3      0.2      0.1                      best_pos = next_i
   240                                           
   241      2390       1476.5      0.6      0.0              path.insert(best_pos, to_ins)
   242      2390        672.0      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   2857245     682944.8      0.2      4.2              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   2854855    1084547.1      0.4      6.7                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      1424        293.5      0.2      0.0                      best_cost = np.inf
   251      1424        241.0      0.2      0.0                      posL, posR = -1, -1
   252    408182      66952.1      0.2      0.4                      for i2 in range(len(path)):
   253    406758     106511.1      0.3      0.7                          next_i = (i2 + 1) % len(path)
   254    406758     386102.8      0.9      2.4                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    406758      77871.4      0.2      0.5                          if best_cost > insertion_cost:
   256     21779       4687.9      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      1424        348.3      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   2854855    3539384.3      1.2     21.8                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261    101591     113829.2      1.1      0.7                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262    101591      38362.9      0.4      0.2                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265    101591      24555.8      0.2      0.2                      best_pos = (best_pos + 1) % (len(path))
   266   2854855    3776251.9      1.3     23.2                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267    119820     138420.4      1.2      0.9                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268    119820      52709.9      0.4      0.3                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      2390     201649.8     84.4      1.2              heapq.heapify(h)
   270                                           
   271         1         19.0     19.0      0.0          self.tour = path
   272         1       1393.5   1393.5      0.0          self.calculateCost()

Total time: 8.00401 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.7      0.7      0.0          n = self.numCity
   277         1     215906.5 215906.5      2.7          distances = np.array(self.adj)
   278         1          2.0      2.0      0.0          path = [0, 0]
   279                                           
   280         1          0.1      0.1      0.0          maxDist = 0
   281      2393        349.2      0.1      0.0          for i in range(n):
   282   2862028     425017.4      0.1      5.3              for j in range(0, i):
   283   2859636    1021622.5      0.4     12.8                  if distances[i][j] > maxDist:
   284       166         37.7      0.2      0.0                      path[0], path[1] = i, j
   285       166         57.0      0.3      0.0                      maxDist = distances[i][j]
   286         1          1.8      1.8      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.7      0.7      0.0          h = []
   291      2391        408.1      0.2      0.0          for i in set(range(n)) - in_path:
   292      2390       1631.3      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1        151.2    151.2      0.0          heapq.heapify(h)
   294                                           
   295      2391       1088.8      0.5      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      2390       1957.6      0.8      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      2390        677.5      0.3      0.0              best_increase = np.inf
   301      2390        387.8      0.2      0.0              best_position = None
   302   2862025     453574.0      0.2      5.7              for i in range(len(path)):
   303   2859635     699755.4      0.2      8.7                  next_i = (i + 1) % len(path)
   304   2859635    2201968.1      0.8     27.5                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   2859635     556888.2      0.2      7.0                  if increase < best_increase:
   306    150508      20399.6      0.1      0.3                      best_increase = increase
   307    150508      29169.7      0.2      0.4                      best_position = i + 1
   308                                           
   309      2390       1481.1      0.6      0.0              path.insert(best_position, to_insert)
   310      2390        759.9      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   2857245     590898.6      0.2      7.4              for i, (cost, node) in enumerate(h):
   314   2854855     552244.8      0.2      6.9                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   2854855    1029994.2      0.4     12.9                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      2390     196137.1     82.1      2.5              heapq.heapify(h)
   319                                           
   320         1         24.1     24.1      0.0          self.tour = path
   321         1       1414.6   1414.6      0.0          self.calculateCost()

Total time: 16.5943 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          1.4      1.4      0.0          n = self.numCity
   326         1     223667.3 223667.3      1.3          adj = np.array(self.adj)
   327         1     223343.7 223343.7      1.3          distances = np.array(self.adj)
   328         1          2.0      2.0      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331      2393        374.0      0.2      0.0          for i in range(n):
   332   2862028     440431.9      0.2      2.7              for j in range(0, i):
   333   2859636    1027238.1      0.4      6.2                  if distances[i][j] > maxDist:
   334       166         44.0      0.3      0.0                      path[0], path[1] = i, j
   335       166         61.0      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.9      0.9      0.0          h = []
   339      2391        406.5      0.2      0.0          for i in set(range(n)) - in_path:
   340      2390       2328.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      2390        911.6      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1        155.1    155.1      0.0          heapq.heapify(h)
   343                                           
   344      2391        996.3      0.4      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      2390       1994.2      0.8      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      2390        618.0      0.3      0.0              best_increase = np.inf
   350      2390        391.1      0.2      0.0              best_pos = None
   351   2862025     449440.2      0.2      2.7              for i in range(len(path)):
   352   2859635     696888.5      0.2      4.2                  next_i = (i + 1) % len(path)
   353   2859635    2301579.7      0.8     13.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   2859635     528900.6      0.2      3.2                  if increase < best_increase:
   355    155382      21740.9      0.1      0.1                      best_increase = increase
   356    155382      24130.9      0.2      0.1                      best_pos = next_i
   357                                           
   358      2390       1323.1      0.6      0.0              path.insert(best_pos, to_ins)
   359      2390        737.2      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   2857245     684555.8      0.2      4.1              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   2854855     581055.5      0.2      3.5                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   2854855    1087515.3      0.4      6.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       662        169.3      0.3      0.0                      best_cost = np.inf
   367       662        125.2      0.2      0.0                      posL, posR = -1, -1
   368    320555      50742.3      0.2      0.3                      for i2 in range(len(path)):
   369    319893      83356.2      0.3      0.5                          next_i = (i2 + 1) % len(path)
   370    319893     306147.5      1.0      1.8                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    319893      61608.4      0.2      0.4                          if best_cost > insertion_cost:
   372     22396       4716.3      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       662        227.8      0.3      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   2854855    3730130.5      1.3     22.5                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377       946       1151.3      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378       946        403.0      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381       946        237.7      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   2854855    3836900.8      1.3     23.1                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      5035       5820.5      1.2      0.0                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      5035       2202.6      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      2390     208035.1     87.0      1.3              heapq.heapify(h)
   386                                           
   387         1         17.8     17.8      0.0          self.tour = path
   388         1       1437.0   1437.0      0.0          self.calculateCost()


Optimal 137694
_________________
pcb3038
randomInsertion 1.1636187551415302
nearestInsertion 1.2307725448619498
cheapestInsertion 1.217898512451063
nearestNeighbor 1.27509369891956
farthestInsertion 1.287083136296118
furthestInsertion 1.1910857707269618

[('pcb3038', 1.1636187551415302, 1.2307725448619498, 1.217898512451063, 1.27509369891956, 1.287083136296118, 1.1910857707269618)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 7.01969 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.6      0.6      0.0          n = self.numCity
   115         1     360028.1 360028.1      5.1          distances = np.array(self.adj)
   116         1          1.8      1.8      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.1      1.1      0.0          in_path = {0}
   118         1        255.3    255.3      0.0          notInPath = [x for x in range(1, n)]
   119         1       3151.5   3151.5      0.0          random.shuffle(notInPath)
   120                                           
   121      3038        941.3      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      3037        678.1      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      3037        751.7      0.2      0.0              best_increase = np.inf
   127      3037        462.2      0.2      0.0              best_position = None
   128   4616240     785180.5      0.2     11.2              for i in range(len(path)):
   129   4613203    1159308.4      0.3     16.5                  next_i = (i + 1) % len(path)
   130   4613203    3765598.3      0.8     53.6                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   4613203     881879.1      0.2     12.6                  if increase < best_increase:
   132    194029      25663.4      0.1      0.4                      best_increase = increase
   133    194029      31045.0      0.2      0.4                      best_position = next_i
   134                                           
   135      3037       1841.3      0.6      0.0              path.insert(best_position, to_insert)
   136      3037       1099.0      0.4      0.0              in_path.add(to_insert)
   137                                           
   138         1          6.7      6.7      0.0          self.tour = path
   139         1       1794.5   1794.5      0.0          self.calculateCost()

Total time: 2.26861 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1         14.0     14.0      0.0          self.tour = [0]
   144         1          1.4      1.4      0.0          visited = set([0])
   145         1         41.4     41.4      0.0          notVisited = set(range(1, self.numCity))
   146      3038       1260.7      0.4      0.1          while len(self.tour) < self.numCity:
   147      3037        679.9      0.2      0.0              cost = np.inf
   148      3037        413.0      0.1      0.0              j = -1
   149   4616240     721917.1      0.2     31.8              for j2 in notVisited:
   150   4613203    1459137.1      0.3     64.3                  if self.adj[self.tour[-1]][j2] < cost:
   151    206435      50000.7      0.2      2.2                      cost = self.adj[self.tour[-1]][j2]
   152    206435      30343.7      0.1      1.3                      j = j2
   153      3037       1300.9      0.4      0.1              self.tour.append(j)
   154      3037        913.8      0.3      0.0              visited.add(j)
   155      3037        833.3      0.3      0.0              notVisited.remove(j)
   156         1       1756.7   1756.7      0.1          self.calculateCost()

Total time: 12.2813 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.7      0.7      0.0          n = self.numCity
   162         1     358915.1 358915.1      2.9          distances = np.array(self.adj)
   163         1          1.3      1.3      0.0          path = [0, 0]
   164                                           
   165         1          1.6      1.6      0.0          minDist = np.inf
   166      3039        451.0      0.1      0.0          for i in range(n):
   167   4616241     729603.2      0.2      5.9              for j in range(0, i):
   168   4613203    1661153.7      0.4     13.5                  if distances[i][j] < minDist:
   169         7          2.7      0.4      0.0                      path[0], path[1] = i, j
   170         7          2.8      0.4      0.0                      minDist = distances[i][j]
   171         1          1.7      1.7      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          1.1      1.1      0.0          h = []
   176      3037        570.6      0.2      0.0          for i in set(range(n)) - in_path:
   177      3036     114829.5     37.8      0.9              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        190.7    190.7      0.0          heapq.heapify(h)
   179                                           
   180      3037       1242.1      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      3036       2582.9      0.9      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      3036        825.3      0.3      0.0              best_increase = np.inf
   186      3036        515.3      0.2      0.0              best_position = None
   187   4616238     724657.6      0.2      5.9              for i in range(len(path)):
   188   4613202    1141953.5      0.2      9.3                  next_i = (i + 1) % len(path)
   189   4613202    3545397.7      0.8     28.9                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   4613202     893148.7      0.2      7.3                  if increase < best_increase:
   191    164342      21733.3      0.1      0.2                      best_increase = increase
   192    164342      31603.4      0.2      0.3                      best_position = i + 1
   193                                           
   194      3036       1932.5      0.6      0.0              path.insert(best_position, to_insert)
   195      3036        898.5      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   4610166     996147.8      0.2      8.1              for i, (cost, node) in enumerate(h):
   199   4607130    1651457.7      0.4     13.4                  if node not in in_path and distances[to_insert, node] < cost:
   200    212891      73329.4      0.3      0.6                      h[i] = (distances[to_insert, node], node)
   201      3036     326212.0    107.4      2.7              heapq.heapify(h)
   202                                           
   203         1         27.1     27.1      0.0          self.tour = path
   204         1       1938.4   1938.4      0.0          self.calculateCost()

Total time: 26.6386 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          1.8      1.8      0.0          n = self.numCity
   209         1     371641.8 371641.8      1.4          adj = np.array(self.adj)
   210         1     370848.9 370848.9      1.4          distances = np.array(self.adj)
   211         1          1.4      1.4      0.0          path = [0, 0]
   212                                           
   213         1          1.7      1.7      0.0          minDist = np.inf
   214      3039        429.7      0.1      0.0          for i in range(n):
   215   4616241     713198.5      0.2      2.7              for j in range(0, i):
   216   4613203    1633300.7      0.4      6.1                  if distances[i][j] < minDist:
   217         7          3.7      0.5      0.0                      path[0], path[1] = i, j
   218         7          2.8      0.4      0.0                      minDist = distances[i][j]
   219         1          2.2      2.2      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.6      0.6      0.0          h = []
   222      3037        511.9      0.2      0.0          for i in set(range(n)) - in_path:
   223      3036       3074.2      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      3036       1165.2      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1        187.7    187.7      0.0          heapq.heapify(h)
   226                                           
   227      3037       1504.2      0.5      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      3036       2850.7      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      3036        922.5      0.3      0.0              best_increase = np.inf
   233      3036        545.2      0.2      0.0              best_pos = None
   234   4616238     750450.1      0.2      2.8              for i in range(len(path)):
   235   4613202    1168535.8      0.3      4.4                  next_i = (i + 1) % len(path)
   236   4613202    3667912.8      0.8     13.8                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   4613202     898712.0      0.2      3.4                  if increase < best_increase:
   238    187240      26373.8      0.1      0.1                      best_increase = increase
   239    187240      31147.8      0.2      0.1                      best_pos = next_i
   240                                           
   241      3036       2094.4      0.7      0.0              path.insert(best_pos, to_ins)
   242      3036        939.5      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   4610166    1075043.0      0.2      4.0              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   4607130    1772934.1      0.4      6.7                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      2306        516.6      0.2      0.0                      best_cost = np.inf
   251      2306        397.8      0.2      0.0                      posL, posR = -1, -1
   252    735321     120070.6      0.2      0.5                      for i2 in range(len(path)):
   253    733015     190723.1      0.3      0.7                          next_i = (i2 + 1) % len(path)
   254    733015     716743.2      1.0      2.7                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255    733015     139522.0      0.2      0.5                          if best_cost > insertion_cost:
   256     34702       7673.8      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      2306        563.3      0.2      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   4607130    5932475.1      1.3     22.3                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261    133097     154317.9      1.2      0.6                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262    133097      52111.8      0.4      0.2                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265    133097      34418.1      0.3      0.1                      best_pos = (best_pos + 1) % (len(path))
   266   4607130    6210313.9      1.3     23.3                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267    152276     181522.2      1.2      0.7                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268    152276      67576.2      0.4      0.3                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      3036     333487.8    109.8      1.3              heapq.heapify(h)
   270                                           
   271         1         23.6     23.6      0.0          self.tour = path
   272         1       1826.1   1826.1      0.0          self.calculateCost()

Total time: 13.2835 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          1.2      1.2      0.0          n = self.numCity
   277         1     358508.5 358508.5      2.7          distances = np.array(self.adj)
   278         1          1.4      1.4      0.0          path = [0, 0]
   279                                           
   280         1          0.3      0.3      0.0          maxDist = 0
   281      3039        430.4      0.1      0.0          for i in range(n):
   282   4616241     776445.9      0.2      5.8              for j in range(0, i):
   283   4613203    1707885.5      0.4     12.9                  if distances[i][j] > maxDist:
   284       170         41.0      0.2      0.0                      path[0], path[1] = i, j
   285       170         58.8      0.3      0.0                      maxDist = distances[i][j]
   286         1          2.0      2.0      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.8      0.8      0.0          h = []
   291      3037        520.2      0.2      0.0          for i in set(range(n)) - in_path:
   292      3036       2205.8      0.7      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1        194.2    194.2      0.0          heapq.heapify(h)
   294                                           
   295      3037       1241.7      0.4      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      3036       2440.8      0.8      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      3036        729.5      0.2      0.0              best_increase = np.inf
   301      3036        528.8      0.2      0.0              best_position = None
   302   4616238     752559.4      0.2      5.7              for i in range(len(path)):
   303   4613202    1122817.6      0.2      8.5                  next_i = (i + 1) % len(path)
   304   4613202    3621208.9      0.8     27.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   4613202     862660.3      0.2      6.5                  if increase < best_increase:
   306    199791      25351.4      0.1      0.2                      best_increase = increase
   307    199791      37099.0      0.2      0.3                      best_position = i + 1
   308                                           
   309      3036       1860.8      0.6      0.0              path.insert(best_position, to_insert)
   310      3036        920.5      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   4610166     953709.0      0.2      7.2              for i, (cost, node) in enumerate(h):
   314   4607130     971545.5      0.2      7.3                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   4607130    1752502.3      0.4     13.2                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      3036     328240.7    108.1      2.5              heapq.heapify(h)
   319                                           
   320         1         25.9     25.9      0.0          self.tour = path
   321         1       1800.1   1800.1      0.0          self.calculateCost()

Total time: 26.8661 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          1.0      1.0      0.0          n = self.numCity
   326         1     362212.5 362212.5      1.3          adj = np.array(self.adj)
   327         1     358577.8 358577.8      1.3          distances = np.array(self.adj)
   328         1          0.9      0.9      0.0          path = [0, 0]
   329                                           
   330         1          0.1      0.1      0.0          maxDist = 0
   331      3039        420.1      0.1      0.0          for i in range(n):
   332   4616241     695391.7      0.2      2.6              for j in range(0, i):
   333   4613203    1671549.1      0.4      6.2                  if distances[i][j] > maxDist:
   334       170         40.7      0.2      0.0                      path[0], path[1] = i, j
   335       170         57.9      0.3      0.0                      maxDist = distances[i][j]
   336         1          1.2      1.2      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.6      0.6      0.0          h = []
   339      3037        570.9      0.2      0.0          for i in set(range(n)) - in_path:
   340      3036       2964.3      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      3036       1241.7      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1        196.2    196.2      0.0          heapq.heapify(h)
   343                                           
   344      3037       1466.4      0.5      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      3036       2851.9      0.9      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      3036        838.1      0.3      0.0              best_increase = np.inf
   350      3036        508.8      0.2      0.0              best_pos = None
   351   4616238     713967.7      0.2      2.7              for i in range(len(path)):
   352   4613202    1125342.0      0.2      4.2                  next_i = (i + 1) % len(path)
   353   4613202    3735771.5      0.8     13.9                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   4613202     855767.9      0.2      3.2                  if increase < best_increase:
   355    205643      28087.2      0.1      0.1                      best_increase = increase
   356    205643      31928.8      0.2      0.1                      best_pos = next_i
   357                                           
   358      3036       2163.8      0.7      0.0              path.insert(best_pos, to_ins)
   359      3036       1035.4      0.3      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   4610166    1158298.9      0.3      4.3              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   4607130     938196.8      0.2      3.5                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   4607130    1762014.8      0.4      6.6                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366       711        238.4      0.3      0.0                      best_cost = np.inf
   367       711        151.5      0.2      0.0                      posL, posR = -1, -1
   368    408297      65632.6      0.2      0.2                      for i2 in range(len(path)):
   369    407586     103804.0      0.3      0.4                          next_i = (i2 + 1) % len(path)
   370    407586     400395.4      1.0      1.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371    407586      77874.5      0.2      0.3                          if best_cost > insertion_cost:
   372     25910       5688.1      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373       711        295.9      0.4      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   4607130    6108723.0      1.3     22.7                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377      1199       1473.1      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378      1199        510.8      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381      1199        310.0      0.3      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   4607130    6295456.5      1.4     23.4                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383      6688       8118.7      1.2      0.0                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384      6688       3006.3      0.4      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      3036     341054.3    112.3      1.3              heapq.heapify(h)
   386                                           
   387         1         23.7     23.7      0.0          self.tour = path
   388         1       1853.9   1853.9      0.0          self.calculateCost()


Optimal 28772
_________________
fl3795
randomInsertion 1.1915995372091315
nearestInsertion 1.1620568333459935
cheapestInsertion 1.1825468930117295
nearestNeighbor 1.2804602891114583
farthestInsertion 1.2643925364015602
furthestInsertion 1.2423029297550179

[('fl3795', 1.1915995372091315, 1.1620568333459935, 1.1825468930117295, 1.2804602891114583, 1.2643925364015602, 1.2423029297550179)]
1
Wrote profile results to tempi.py.lprof
Timer unit: 1e-06 s

Total time: 10.9418 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: randomInsertion at line 111

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   111                                               @profile
   112                                               def randomInsertion(self):
   113                                                   # sceglie casualmente il nodo da inserisce MA lo inserisce nel modo migilore possibile (minimizzando l'inserimento)
   114         1          0.9      0.9      0.0          n = self.numCity
   115         1     592248.9 592248.9      5.4          distances = np.array(self.adj)
   116         1          1.5      1.5      0.0          path = [0]  # Inizia da una città arbitraria, in questo caso la prima
   117         1          1.3      1.3      0.0          in_path = {0}
   118         1        304.4    304.4      0.0          notInPath = [x for x in range(1, n)]
   119         1       4016.1   4016.1      0.0          random.shuffle(notInPath)
   120                                           
   121      3795       1171.3      0.3      0.0          while len(path) < n:
   122                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   123      3794        847.6      0.2      0.0              to_insert = notInPath.pop()
   124                                           
   125                                                       # Trova la posizione ottimale per inserire la città trovata
   126      3794       1004.9      0.3      0.0              best_increase = np.inf
   127      3794        560.1      0.1      0.0              best_position = None
   128   7202909    1189150.1      0.2     10.9              for i in range(len(path)):
   129   7199115    1786776.4      0.2     16.3                  next_i = (i + 1) % len(path)
   130   7199115    5824836.8      0.8     53.2                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   131   7199115    1426751.5      0.2     13.0                  if increase < best_increase:
   132    357952      50448.4      0.1      0.5                      best_increase = increase
   133    357952      57277.3      0.2      0.5                      best_position = next_i
   134                                           
   135      3794       2687.9      0.7      0.0              path.insert(best_position, to_insert)
   136      3794       1454.0      0.4      0.0              in_path.add(to_insert)
   137                                           
   138         1          7.7      7.7      0.0          self.tour = path
   139         1       2241.7   2241.7      0.0          self.calculateCost()

Total time: 3.45814 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestNeighbor at line 141

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   141                                               @profile
   142                                               def nearestNeighbor(self):
   143         1         17.6     17.6      0.0          self.tour = [0]
   144         1          1.4      1.4      0.0          visited = set([0])
   145         1         47.2     47.2      0.0          notVisited = set(range(1, self.numCity))
   146      3795       1782.5      0.5      0.1          while len(self.tour) < self.numCity:
   147      3794        966.2      0.3      0.0              cost = np.inf
   148      3794        528.8      0.1      0.0              j = -1
   149   7202909    1099982.3      0.2     31.8              for j2 in notVisited:
   150   7199115    2331771.4      0.3     67.4                  if self.adj[self.tour[-1]][j2] < cost:
   151     44398      10371.1      0.2      0.3                      cost = self.adj[self.tour[-1]][j2]
   152     44398       6493.9      0.1      0.2                      j = j2
   153      3794       1746.9      0.5      0.1              self.tour.append(j)
   154      3794       1173.1      0.3      0.0              visited.add(j)
   155      3794       1088.5      0.3      0.0              notVisited.remove(j)
   156         1       2173.3   2173.3      0.1          self.calculateCost()

Total time: 19.7588 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: nearestInsertion at line 158

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   158                                               @profile
   159                                               def nearestInsertion(self):
   160                                                   # inizializzo il path con i due nodi più vicini
   161         1          0.5      0.5      0.0          n = self.numCity
   162         1     594001.6 594001.6      3.0          distances = np.array(self.adj)
   163         1          1.8      1.8      0.0          path = [0, 0]
   164                                           
   165         1          1.1      1.1      0.0          minDist = np.inf
   166      3796        587.5      0.2      0.0          for i in range(n):
   167   7202910    1151489.4      0.2      5.8              for j in range(0, i):
   168   7199115    2917285.3      0.4     14.8                  if distances[i][j] < minDist:
   169        10          4.3      0.4      0.0                      path[0], path[1] = i, j
   170        10          3.9      0.4      0.0                      minDist = distances[i][j]
   171         1          1.6      1.6      0.0          in_path = {path[0], path[1]}
   172                                           
   173                                           
   174                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   175         1          0.8      0.8      0.0          h = []
   176      3794        651.6      0.2      0.0          for i in set(range(n)) - in_path:
   177      3793       5005.1      1.3      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   178         1        247.4    247.4      0.0          heapq.heapify(h)
   179                                           
   180      3794       1488.3      0.4      0.0          while len(path) < n:
   181                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   182      3793       3496.7      0.9      0.0              _, to_insert = heapq.heappop(h)
   183                                           
   184                                                       # Trova la posizione ottimale per inserire la città trovata
   185      3793        932.7      0.2      0.0              best_increase = np.inf
   186      3793        640.5      0.2      0.0              best_position = None
   187   7202907    1168594.6      0.2      5.9              for i in range(len(path)):
   188   7199114    1770698.2      0.2      9.0                  next_i = (i + 1) % len(path)
   189   7199114    5598768.1      0.8     28.3                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   190   7199114    1393350.7      0.2      7.1                  if increase < best_increase:
   191    478297      66758.3      0.1      0.3                      best_increase = increase
   192    478297      90582.2      0.2      0.5                      best_position = i + 1
   193                                           
   194      3793       2314.5      0.6      0.0              path.insert(best_position, to_insert)
   195      3793       1071.0      0.3      0.0              in_path.add(to_insert)
   196                                           
   197                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   198   7195321    1553446.0      0.2      7.9              for i, (cost, node) in enumerate(h):
   199   7191528    2621878.7      0.4     13.3                  if node not in in_path and distances[to_insert, node] < cost:
   200    834597     278898.5      0.3      1.4                      h[i] = (distances[to_insert, node], node)
   201      3793     534380.2    140.9      2.7              heapq.heapify(h)
   202                                           
   203         1         35.8     35.8      0.0          self.tour = path
   204         1       2194.2   2194.2      0.0          self.calculateCost()

Total time: 50.0373 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: cheapestInsertion at line 206

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   206                                               @profile
   207                                               def cheapestInsertion(self):
   208         1          0.5      0.5      0.0          n = self.numCity
   209         1     589803.7 589803.7      1.2          adj = np.array(self.adj)
   210         1     590661.8 590661.8      1.2          distances = np.array(self.adj)
   211         1          1.2      1.2      0.0          path = [0, 0]
   212                                           
   213         1          1.3      1.3      0.0          minDist = np.inf
   214      3796        541.6      0.1      0.0          for i in range(n):
   215   7202910    1164086.9      0.2      2.3              for j in range(0, i):
   216   7199115    2791935.8      0.4      5.6                  if distances[i][j] < minDist:
   217        10          4.0      0.4      0.0                      path[0], path[1] = i, j
   218        10          3.7      0.4      0.0                      minDist = distances[i][j]
   219         1          2.5      2.5      0.0          in_path = {path[0], path[1]}
   220                                           
   221         1          0.7      0.7      0.0          h = []
   222      3794        681.1      0.2      0.0          for i in set(range(n)) - in_path:
   223      3793       3858.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   224      3793       1430.6      0.4      0.0              h.append((cost, i, path[0], path[1]))
   225         1        308.5    308.5      0.0          heapq.heapify(h)
   226                                           
   227      3794       2069.3      0.5      0.0          while len(path) < n:
   228                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   229      3793       3744.0      1.0      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   230                                           
   231                                                       # Trova la posizione ottimale per inserire la città trovata
   232      3793       1094.7      0.3      0.0              best_increase = np.inf
   233      3793        756.0      0.2      0.0              best_pos = None
   234   7202907    1229960.1      0.2      2.5              for i in range(len(path)):
   235   7199114    1853093.9      0.3      3.7                  next_i = (i + 1) % len(path)
   236   7199114    5733742.0      0.8     11.5                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   237   7199114    1389266.3      0.2      2.8                  if increase < best_increase:
   238    462027      66938.4      0.1      0.1                      best_increase = increase
   239    462027      74801.9      0.2      0.1                      best_pos = next_i
   240                                           
   241      3793       3132.4      0.8      0.0              path.insert(best_pos, to_ins)
   242      3793       1269.5      0.3      0.0              in_path.add(to_ins)
   243                                           
   244                                                       # A - B - C
   245                                           
   246                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   247   7195321    1749252.0      0.2      3.5              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   248                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   249   7191528    2756414.5      0.4      5.5                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   250      7324       1740.5      0.2      0.0                      best_cost = np.inf
   251      7324       1231.2      0.2      0.0                      posL, posR = -1, -1
   252   5675818     941393.0      0.2      1.9                      for i2 in range(len(path)):
   253   5668494    1463780.2      0.3      2.9                          next_i = (i2 + 1) % len(path)
   254   5668494    5755154.4      1.0     11.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   255   5668494    1089250.2      0.2      2.2                          if best_cost > insertion_cost:
   256    251372      55311.1      0.2      0.1                              best_cost, posL, posR = insertion_cost, i2, next_i
   257      7324       2007.9      0.3      0.0                      h[i] = (best_cost, node, posL, posR)
   258                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   259                                                           # path[best_pos - 1] -- node -- to_ins
   260   7191528    9309067.0      1.3     18.6                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   261    295021     345114.1      1.2      0.7                      new_cost = adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins]
   262    295021     116429.4      0.4      0.2                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   263                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   264                                                           # to_ins -- node -- path[best_pos + 1] 
   265    295021      76634.1      0.3      0.2                      best_pos = (best_pos + 1) % (len(path))
   266   7191528    9768715.9      1.4     19.5                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   267    337709     402485.9      1.2      0.8                      new_cost = adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]]
   268    337709     155666.2      0.5      0.3                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   269      3793     542233.8    143.0      1.1              heapq.heapify(h)
   270                                           
   271         1         32.7     32.7      0.0          self.tour = path
   272         1       2191.5   2191.5      0.0          self.calculateCost()

Total time: 20.8346 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: farthestInsertion at line 274

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   274                                               @profile
   275                                               def farthestInsertion(self):
   276         1          0.9      0.9      0.0          n = self.numCity
   277         1     598649.4 598649.4      2.9          distances = np.array(self.adj)
   278         1          1.9      1.9      0.0          path = [0, 0]
   279                                           
   280         1          0.2      0.2      0.0          maxDist = 0
   281      3796        542.3      0.1      0.0          for i in range(n):
   282   7202910    1142778.2      0.2      5.5              for j in range(0, i):
   283   7199115    2897612.5      0.4     13.9                  if distances[i][j] > maxDist:
   284         6          2.9      0.5      0.0                      path[0], path[1] = i, j
   285         6          2.5      0.4      0.0                      maxDist = distances[i][j]
   286         1          1.5      1.5      0.0          in_path = {path[0], path[1]}
   287                                           
   288                                           
   289                                                   # Inizializza le distanze minime e le città più vicine per ogni città non nel percorso
   290         1          0.7      0.7      0.0          h = []
   291      3794        635.4      0.2      0.0          for i in set(range(n)) - in_path:
   292      3793       5134.9      1.4      0.0              h.append((min(distances[path[0], i], distances[path[1], i]), i))
   293         1        258.1    258.1      0.0          heapq.heapify(h)
   294                                           
   295      3794       1772.0      0.5      0.0          while len(path) < n:
   296                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   297      3793       3429.9      0.9      0.0              _, to_insert = heapq.heappop(h)
   298                                           
   299                                                       # Trova la posizione ottimale per inserire la città trovata
   300      3793        966.2      0.3      0.0              best_increase = np.inf
   301      3793        678.5      0.2      0.0              best_position = None
   302   7202907    1141340.6      0.2      5.5              for i in range(len(path)):
   303   7199114    1719216.7      0.2      8.3                  next_i = (i + 1) % len(path)
   304   7199114    5585201.8      0.8     26.8                  increase = distances[path[i], to_insert] + distances[to_insert, path[next_i]] - distances[path[i], path[next_i]]
   305   7199114    1442112.4      0.2      6.9                  if increase < best_increase:
   306    305607      38585.0      0.1      0.2                      best_increase = increase
   307    305607      58387.8      0.2      0.3                      best_position = i + 1
   308                                           
   309      3793       2656.9      0.7      0.0              path.insert(best_position, to_insert)
   310      3793       1154.7      0.3      0.0              in_path.add(to_insert)
   311                                           
   312                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   313   7195321    1443257.7      0.2      6.9              for i, (cost, node) in enumerate(h):
   314   7191528    1487578.8      0.2      7.1                  cost *= -1
   315                                                           # cerco comunque di minimizzare distances!
   316   7191528    2732588.9      0.4     13.1                  if node not in in_path and distances[to_insert, node] < cost:
   317                                                               h[i] = (-distances[to_insert, node], node)
   318      3793     527755.0    139.1      2.5              heapq.heapify(h)
   319                                           
   320         1         32.9     32.9      0.0          self.tour = path
   321         1       2217.1   2217.1      0.0          self.calculateCost()

Total time: 44.8322 s
File: /media/asafcohen/2TB/Triennale/Tesi/Furthest-insertion/TSP.py
Function: furthestInsertion at line 323

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   323                                               @profile
   324                                               def furthestInsertion(self):
   325         1          0.6      0.6      0.0          n = self.numCity
   326         1     599349.1 599349.1      1.3          adj = np.array(self.adj)
   327         1     600488.0 600488.0      1.3          distances = np.array(self.adj)
   328         1          1.5      1.5      0.0          path = [0, 0]
   329                                           
   330         1          0.2      0.2      0.0          maxDist = 0
   331      3796        532.6      0.1      0.0          for i in range(n):
   332   7202910    1145786.6      0.2      2.6              for j in range(0, i):
   333   7199115    2802751.9      0.4      6.3                  if distances[i][j] > maxDist:
   334         6          2.7      0.5      0.0                      path[0], path[1] = i, j
   335         6          2.4      0.4      0.0                      maxDist = distances[i][j]
   336         1          1.3      1.3      0.0          in_path = {path[0], path[1]}
   337                                           
   338         1          0.5      0.5      0.0          h = []
   339      3794        654.6      0.2      0.0          for i in set(range(n)) - in_path:
   340      3793       3700.4      1.0      0.0              cost = adj[path[0]][i] + adj[i][path[1]] - adj[path[0]][path[1]]
   341      3793       1587.1      0.4      0.0              h.append((-cost, i, path[0], path[1]))
   342         1        236.7    236.7      0.0          heapq.heapify(h)
   343                                           
   344      3794       2437.8      0.6      0.0          while len(path) < n:
   345                                                       # Trova la città non inserita più vicina a qualsiasi città nel percorso
   346      3793       4678.3      1.2      0.0              (_, to_ins, _, _) = heapq.heappop(h)
   347                                           
   348                                                       # Trova la posizione ottimale per inserire la città trovata
   349      3793       1553.3      0.4      0.0              best_increase = np.inf
   350      3793        709.7      0.2      0.0              best_pos = None
   351   7202907    1202296.9      0.2      2.7              for i in range(len(path)):
   352   7199114    1813592.0      0.3      4.0                  next_i = (i + 1) % len(path)
   353   7199114    6079259.9      0.8     13.6                  increase = adj[path[i], to_ins] + adj[to_ins, path[next_i]] - adj[path[i], path[next_i]]
   354   7199114    1421759.6      0.2      3.2                  if increase < best_increase:
   355    272844      39751.9      0.1      0.1                      best_increase = increase
   356    272844      44291.3      0.2      0.1                      best_pos = next_i
   357                                           
   358      3793       4276.8      1.1      0.0              path.insert(best_pos, to_ins)
   359      3793       1706.9      0.5      0.0              in_path.add(to_ins)
   360                                           
   361                                                       # Aggiorna le distanze minime e le città più vicine per ogni città non nel percorso
   362   7195321    1974121.9      0.3      4.4              for i, (cost, node, nodeLeft, nodeRight) in enumerate(h):
   363   7191528    1555289.1      0.2      3.5                  cost *= -1
   364                                                           # se ho inserito to_ins proprio tra nodeLeft e nodeRight: ricalcolo completamente il costo migliore
   365   7191528    2873965.7      0.4      6.4                  if node not in in_path and nodeLeft == path[(best_pos - 1) % len(path)] and nodeRight == path[(best_pos + 1) % len(path)]:
   366      2529        702.0      0.3      0.0                      best_cost = np.inf
   367      2529        464.0      0.2      0.0                      posL, posR = -1, -1
   368   1031365     170726.7      0.2      0.4                      for i2 in range(len(path)):
   369   1028836     264898.4      0.3      0.6                          next_i = (i2 + 1) % len(path)
   370   1028836    1110174.3      1.1      2.5                          insertion_cost = adj[path[i2]][node] + adj[node][path[next_i]] - adj[path[i2]][path[next_i]]
   371   1028836     197532.0      0.2      0.4                          if best_cost > insertion_cost:
   372     47125      10436.4      0.2      0.0                              best_cost, posL, posR = insertion_cost, i2, next_i
   373      2529       1020.6      0.4      0.0                      h[i] = (-best_cost, node, posL, posR)
   374                                                           # se il nuovo arco a sinistra permette un inserimento migliore di cost, quindi:
   375                                                           # (best_pos - 1) -- node -- to_ins
   376   7191528   10023394.6      1.4     22.4                  if node not in in_path and adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins] < cost:
   377      3565       4385.1      1.2      0.0                      new_cost = -(adj[path[(best_pos - 1) % len(path)]][node] + adj[node][to_ins] - adj[path[(best_pos - 1) % len(path)]][to_ins])
   378      3565       1495.3      0.4      0.0                      h[i] = (new_cost, node, path[(best_pos - 1) % len(path)], to_ins)
   379                                                           # se il nuovo arco a destra permette un inserimento migliore di cost, quindi:
   380                                                           # to_ins -- node -- (best_pos + 1) 
   381      3565        884.2      0.2      0.0                      best_pos = (best_pos + 1) % (len(path))
   382   7191528   10223803.7      1.4     22.8                  if node not in in_path and adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]] < cost:
   383     11071      13256.4      1.2      0.0                      new_cost = -(adj[to_ins][node] + adj[node][path[(best_pos + 1) % (len(path))]] - adj[to_ins][path[(best_pos + 1) % (len(path))]])
   384     11071       5056.2      0.5      0.0                      h[i] = (new_cost, node, to_ins, path[(best_pos + 1) % (len(path))])
   385      3793     626815.6    165.3      1.4              heapq.heapify(h)
   386                                           
   387         1         32.4     32.4      0.0          self.tour = path
   388         1       2374.5   2374.5      0.0          self.calculateCost()

